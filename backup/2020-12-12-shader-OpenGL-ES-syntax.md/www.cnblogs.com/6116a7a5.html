<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta name="description" content="变量 GLSL的变量命名方式与C语言类似。变量的名称可以使用字母，数字以及下划线，但变量名不能以数字开头，还有变量名不能以gl_作为前缀，这个是GLSL保留的前缀，用于GLSL的内部变量。当然还有一些" />
    <meta property="og:description" content="变量 GLSL的变量命名方式与C语言类似。变量的名称可以使用字母，数字以及下划线，但变量名不能以数字开头，还有变量名不能以gl_作为前缀，这个是GLSL保留的前缀，用于GLSL的内部变量。当然还有一些" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>GLSL语法入门 - KefeiGame - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=R2wBwmwSMG0Sqiw8GFSVjHT4Payg_JFAn51R8XcuvN0" />
    <link id="MainCss" rel="stylesheet" href="/skins/dark/bundle-dark.min.css?v=gZT0VoaXKIHshkKJce2-MsYUqbrUPXKoMMgQDoRBz6g" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/dark/bundle-dark-mobile.min.css?v=iwyTBCq0yI4S4G_W1Q6v2XTVbfYZ47nSVT8NVCgIXiI" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/kefeiGame/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/kefeiGame/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/kefeiGame/wlwmanifest.xml" />
    <script>
        var currentBlogId = 370040;
        var currentBlogApp = 'kefeiGame';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'Dark';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2019-06-04 10:40';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=gWQ9VKr6FSwo14EgofSprzXJrAEO7ppQ1I5Or4uqKuo"></script>
    
    
    
</head>
<body class="has-navbar">
    <a name="top"></a>
        <div id="bannerbar" class="bannerbar-mobile formobile">
            <a href="https://brands.cnblogs.com/aws/free?source=mobile-banner" target="_blank" onclick="ga('send', 'event', 'Link', 'click', 'aws-mobile-bannerbar')">
            <img src="https://img2020.cnblogs.com/blog/35695/202012/35695-20201211073419417-355442931.jpg" alt="" />
            </a>
        </div>
    <div id="top_nav" class="navbar forpc">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding"><a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a></li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=oS4PkibyMjZ9rGD5XAcLt99uW_s76Javy2up4dbnZNY" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" onclick="logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    
    <table width="100%" cellspacing="0" cellpadding="5" border="0">
<tr>
<td class="banner" height="100">

<div id="header">
	<span>
		<a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/kefeiGame/">KefeiGame</a>
<br/>
		<div class="sub"></div>
	</span>
</div>


</td>
</tr>
<tr>
<td style="padding-left: 5px" height="35">
<div style="border: solid 4px #333333; padding: 0px">
<div style="border: solid 1px #666666; padding: 5px">

<a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
 | 

<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/kefeiGame/">
首页</a>
 | 


<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
 | 
<a id="MyLinks1_NewArticleLink" class="menu" href="https://i.cnblogs.com/EditArticles.aspx?opt=1">新文章</a>
 | 

<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/KefeiGame">
联系</a> | 

<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/kefeiGame/rss/">
订阅</a> 
<a id="blog_nav_rss_image" href="https://www.cnblogs.com/kefeiGame/rss/">
    <img src="/skins/dark/images/xml.gif" alt="订阅" />
</a> | 

<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>



<div id="blog_stats">随笔：78
文章：16
评论：2
引用：
0

</div>
</div>
</div>
</td>
</tr>
</table>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top" style="padding: 0">
<table align="center" width="100%" height="1400" cellspacing="0" cellpadding="5" border="0" class="index">
<tr>
<td class="banner" valign="top">
<div id="post_detail">
<div class="block">
	<h1 class="block_title">
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kefeiGame/p/10972139.html">
    <span>GLSL语法入门</span>
    


</a>
</h1>
	<div class="post">
		<div class="postcontent">
			
<div id="cnblogs_post_body" class="blogpost-body">
    <h3>变量</h3>
<p>GLSL的变量命名方式与C语言类似。变量的名称可以使用字母，数字以及下划线，但变量名不能以数字开头，还有变量名不能以gl_作为前缀，这个是GLSL保留的前缀，用于GLSL的内部变量。当然还有一些GLSL保留的名称是不能够作为变量的名称的。</p>
<p>&nbsp;</p>
<h4>基本类型</h4>
<p>除了布尔型，整型，浮点型基本类型外，GLSL还引入了一些在着色器中经常用到的类型作为基本类型。这些基本类型都可以作为结构体内部的类型。如下表:</p>
<h4>&nbsp;</h4>
<table border="2" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td>类型</td>
<td>描述</td>
</tr>
<tr>
<td>void</td>
<td>跟C语言的void类似，表示空类型。作为函数的返回类型，表示这个函数不返回值。</td>
</tr>
<tr>
<td>bool</td>
<td>布尔类型，可以是true 和false，以及可以产生布尔型的表达式。</td>
</tr>
<tr>
<td>int</td>
<td>整型 代表至少包含16位的有符号的整数。可以是十进制的，十六进制的，八进制的。</td>
</tr>
<tr>
<td>float</td>
<td>浮点型</td>
</tr>
<tr>
<td>bvec2</td>
<td>包含2个布尔成分的向量</td>
</tr>
<tr>
<td>bvec3</td>
<td>包含3个布尔成分的向量</td>
</tr>
<tr>
<td>bvec4</td>
<td>包含4个布尔成分的向量</td>
</tr>
<tr>
<td>ivec2</td>
<td>包含2个整型成分的向量</td>
</tr>
<tr>
<td>ivec3</td>
<td>包含3个整型成分的向量</td>
</tr>
<tr>
<td>ivec4</td>
<td>包含4个整型成分的向量</td>
</tr>
<tr>
<td>mat2 或者 mat2x2</td>
<td>2×2的浮点数矩阵类型</td>
</tr>
<tr>
<td>mat3或者mat3x3</td>
<td>3×3的浮点数矩阵类型</td>
</tr>
<tr>
<td>mat4x4</td>
<td>4×4的浮点矩阵</td>
</tr>
<tr>
<td>mat2x3</td>
<td>2列3行的浮点矩阵（OpenGL的矩阵是列主顺序的）</td>
</tr>
<tr>
<td>mat2x4</td>
<td>2列4行的浮点矩阵</td>
</tr>
<tr>
<td>mat3x2</td>
<td>3列2行的浮点矩阵</td>
</tr>
<tr>
<td>mat3x4</td>
<td>3列4行的浮点矩阵</td>
</tr>
<tr>
<td>mat4x2</td>
<td>4列2行的浮点矩阵</td>
</tr>
<tr>
<td>mat4x3</td>
<td>4列3行的浮点矩阵</td>
</tr>
<tr>
<td>sampler1D</td>
<td>用于内建的纹理函数中引用指定的1D纹理的句柄。只可以作为一致变量或者函数参数使用</td>
</tr>
<tr>
<td>sampler2D</td>
<td>二维纹理句柄</td>
</tr>
<tr>
<td>sampler3D</td>
<td>三维纹理句柄</td>
</tr>
<tr>
<td>samplerCube</td>
<td>cube map纹理句柄</td>
</tr>
<tr>
<td>sampler1DShadow</td>
<td>一维深度纹理句柄</td>
</tr>
<tr>
<td>sampler2DShadow</td>
<td>二维深度纹理句柄</td>
</tr>
</tbody>
</table>
<p>结构体</p>
<p>&nbsp;</p>
<h4>结构体</h4>
<p>结构体可以组合基本类型和数组来形成用户自定义的类型。在定义一个结构体的同时，你可以定义一个结构体实例。或者后面再定义。</p>
<pre>struct&nbsp;surface&nbsp;{float&nbsp;indexOfRefraction;

vec3&nbsp;color;float&nbsp;turbulence;

}&nbsp;mySurface;

surface&nbsp;secondeSurface;</pre>
<p>你可以通过=为结构体赋值，或者使用 ==，!=来判断两个结构体是否相等。</p>
<p>mySurface = secondSurface;</p>
<p>mySurface == secondSurface;</p>
<p>只有结构体中的每个成分都相等，那么这两个结构体才是相等的。访问结构体的内部成员使用. 来访问。</p>
<p>vec3 color = mySurface.color + secondSurface.color;</p>
<p>结构体至少包含一个成员。固定大小的数组也可以被包含在结构体中。GLSL的结构体不支持嵌套定义。只有预先声明的结构体可以嵌套其中。</p>
<pre>struct&nbsp;myStruct&nbsp;{

&nbsp;&nbsp;vec3&nbsp;points[3];&nbsp;//固定大小的数组是合法的

&nbsp;&nbsp;surface&nbsp;surf;&nbsp;&nbsp;//可以，之前已经定义了

&nbsp;&nbsp;struct&nbsp;velocity&nbsp;{&nbsp;&nbsp;//不合法float&nbsp;speed;

&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;direction;

&nbsp;&nbsp;}&nbsp;velo;

&nbsp;&nbsp;subSurface&nbsp;sub;&nbsp;//不合法，没有预先声明；};struct&nbsp;subSurface&nbsp;{&nbsp;&nbsp;int&nbsp;id;
};</pre>
<p>&nbsp;</p>
<h4>数组</h4>
<p>GLSL中只可以使用一维的数组。数组的类型可以是一切基本类型或者结构体。下面的几种数组声明是合法的：</p>
<pre>surface&nbsp;mySurfaces[];
vec4&nbsp;lightPositions[8];
vec4&nbsp;lightPos[]&nbsp;=&nbsp;lightPositions;const&nbsp;int&nbsp;numSurfaces&nbsp;=&nbsp;5;
surface&nbsp;myFiveSurfaces[numSurfaces];float[5]&nbsp;values;</pre>
<p>指定显示大小的数组可以作为函数的参数或者使返回值,也可以作为结构体的成员.数组类型内建了一个length()函数，可以返回数组的长度。</p>
<p>lightPositions.length() //返回数组的大小 8</p>
<p>最后，你不能定义数组的数组。</p>
<p>&nbsp;</p>
<h4>修饰符</h4>
<p>变量的声明可以使用如下的修饰符。</p>
<table border="2" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td>修饰符</td>
<td>描述</td>
</tr>
<tr>
<td>const</td>
<td>常量值必须在声明是初始化。它是只读的不可修改的。</td>
</tr>
<tr>
<td>attribute</td>
<td>表示只读的顶点数据，只用在顶点着色器中。数据来自当前的顶点状态或者顶点数组。它必须是全局范围声明的，不能再函数内部。一个attribute可以是浮点数类型的标量，向量，或者矩阵。不可以是数组或则结构体</td>
</tr>
<tr>
<td>uniform</td>
<td>一致变量。在着色器执行期间一致变量的值是不变的。与const常量不同的是，这个值在编译时期是未知的是由着色器外部初始化的。一致变量在顶点着色器和片段着色器之间是共享的。它也只能在全局范围进行声明。</td>
</tr>
<tr>
<td>varying</td>
<td>顶点着色器的输出。例如颜色或者纹理坐标，（插值后的数据）作为片段着色器的只读输入数据。必须是全局范围声明的全局变量。可以是浮点数类型的标量，向量，矩阵。不能是数组或者结构体。</td>
</tr>
<tr>
<td>centorid varying</td>
<td>在没有多重采样的情况下，与varying是一样的意思。在多重采样时，centorid varying在光栅化的图形内部进行求值而不是在片段中心的固定位置求值。</td>
</tr>
<tr>
<td>invariant</td>
<td>(不变量)用于表示顶点着色器的输出和任何匹配片段着色器的输入，在不同的着色器中计算产生的值必须是一致的。所有的数据流和控制流，写入一个invariant变量的是一致的。编译器为了保证结果是完全一致的，需要放弃那些可能会导致不一致值的潜在的优化。除非必要，不要使用这个修饰符。在多通道渲染中避免z-fighting可能会使用到。</td>
</tr>
<tr>
<td>in</td>
<td>用在函数的参数中，表示这个参数是输入的，在函数中改变这个值，并不会影响对调用的函数产生副作用。（相当于C语言的传值），这个是函数参数默认的修饰符</td>
</tr>
<tr>
<td>out</td>
<td>用在函数的参数中，表示该参数是输出参数，值是会改变的。</td>
</tr>
<tr>
<td>inout</td>
<td>用在函数的参数，表示这个参数即是输入参数也是输出参数。</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4>内置变量</h4>
<p>内置变量可以与固定函数功能进行交互。在使用前不需要声明。顶点着色器可用的内置变量如下表：</p>
<table border="2" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td>名称</td>
<td>类型</td>
<td>描述</td>
</tr>
<tr>
<td>gl_Color</td>
<td>vec4</td>
<td>输入属性-表示顶点的主颜色</td>
</tr>
<tr>
<td>gl_SecondaryColor</td>
<td>vec4</td>
<td>输入属性-表示顶点的辅助颜色</td>
</tr>
<tr>
<td>gl_Normal</td>
<td>vec3</td>
<td>输入属性-表示顶点的法线值</td>
</tr>
<tr>
<td>gl_Vertex</td>
<td>vec4</td>
<td>输入属性-表示物体空间的顶点位置</td>
</tr>
<tr>
<td>gl_MultiTexCoordn</td>
<td>vec4</td>
<td>输入属性-表示顶点的第n个纹理的坐标</td>
</tr>
<tr>
<td>gl_FogCoord</td>
<td>float</td>
<td>输入属性-表示顶点的雾坐标</td>
</tr>
<tr>
<td>gl_Position</td>
<td>vec4</td>
<td>输出属性-变换后的顶点的位置，用于后面的固定的裁剪等操作。所有的顶点着色器都必须写这个值。</td>
</tr>
<tr>
<td>gl_ClipVertex</td>
<td>vec4</td>
<td>输出坐标，用于用户裁剪平面的裁剪</td>
</tr>
<tr>
<td>gl_PointSize</td>
<td>float</td>
<td>点的大小</td>
</tr>
<tr>
<td>gl_FrontColor</td>
<td>vec4</td>
<td>正面的主颜色的varying输出</td>
</tr>
<tr>
<td>gl_BackColor</td>
<td>vec4</td>
<td>背面主颜色的varying输出</td>
</tr>
<tr>
<td>gl_FrontSecondaryColor</td>
<td>vec4</td>
<td>正面的辅助颜色的varying输出</td>
</tr>
<tr>
<td>gl_BackSecondaryColor</td>
<td>vec4</td>
<td>背面的辅助颜色的varying输出</td>
</tr>
<tr>
<td>gl_TexCoord[]</td>
<td>vec4</td>
<td>纹理坐标的数组varying输出</td>
</tr>
<tr>
<td>gl_FogFragCoord</td>
<td>float</td>
<td>雾坐标的varying输出</td>
</tr>
</tbody>
</table>
<p>片段着色器的内置变量如下表：</p>
<table border="2" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td>名称</td>
<td>类型</td>
<td>描述</td>
</tr>
<tr>
<td>gl_Color</td>
<td>vec4</td>
<td>包含主颜色的插值只读输入</td>
</tr>
<tr>
<td>gl_SecondaryColor</td>
<td>vec4</td>
<td>包含辅助颜色的插值只读输入</td>
</tr>
<tr>
<td>gl_TexCoord[]</td>
<td>vec4</td>
<td>包含纹理坐标数组的插值只读输入</td>
</tr>
<tr>
<td>gl_FogFragCoord</td>
<td>float</td>
<td>包含雾坐标的插值只读输入</td>
</tr>
<tr>
<td>gl_FragCoord</td>
<td>vec4</td>
<td>只读输入，窗口的x,y,z和1/w</td>
</tr>
<tr>
<td>gl_FrontFacing</td>
<td>bool</td>
<td>只读输入，如果是窗口正面图元的一部分，则这个值为true</td>
</tr>
<tr>
<td>gl_PointCoord</td>
<td>vec2</td>
<td>点精灵的二维空间坐标范围在(0.0, 0.0)到(1.0, 1.0)之间，仅用于点图元和点精灵开启的情况下。</td>
</tr>
<tr>
<td>gl_FragData[]</td>
<td>vec4</td>
<td>使用glDrawBuffers输出的数据数组。不能与gl_FragColor结合使用。</td>
</tr>
<tr>
<td>gl_FragColor</td>
<td>vec4</td>
<td>输出的颜色用于随后的像素操作</td>
</tr>
<tr>
<td>gl_FragDepth</td>
<td>float</td>
<td>输出的深度用于随后的像素操作，如果这个值没有被写，则使用固定功能管线的深度值代替</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3>表达式</h3>
<p>&nbsp;</p>
<h4>操作符</h4>
<p>GLSL语言的操作符与C语言相似。如下表（操作符的优先级从高到低排列）</p>
<table border="2" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td>操作符</td>
<td>描述</td>
</tr>
<tr>
<td>()</td>
<td>用于表达式组合，函数调用，构造</td>
</tr>
<tr>
<td>[]</td>
<td>数组下标，向量或矩阵的选择器</td>
</tr>
<tr>
<td>.</td>
<td>结构体和向量的成员选择</td>
</tr>
<tr>
<td>++ –</td>
<td>前缀或后缀的自增自减操作符</td>
</tr>
<tr>
<td>+ – !</td>
<td>一元操作符，表示正 负 逻辑非</td>
</tr>
<tr>
<td>* /</td>
<td>乘 除操作符</td>
</tr>
<tr>
<td>+ -</td>
<td>二元操作符 表示加 减操作</td>
</tr>
<tr>
<td>&lt;&gt; &lt;= &gt;= == !=</td>
<td>小于，大于，小于等于， 大于等于，等于，不等于 判断符</td>
</tr>
<tr>
<td>&amp;&amp; || ^^</td>
<td>逻辑与 ，或，&nbsp; 异或</td>
</tr>
<tr>
<td>?:</td>
<td>条件判断符</td>
</tr>
<tr>
<td>= += –= *=&nbsp; /=</td>
<td>赋值操作符</td>
</tr>
<tr>
<td>,</td>
<td>表示序列</td>
</tr>
</tbody>
</table>
<p>像 求地址的&amp; 和 解引用的 * 操作符不再GLSL中出现，因为GLSL不能直接操作地址。类型转换操作也是不允许的。 位操作符(&amp;,|,^,~, &lt;&lt;, &gt;&gt; ,&amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=)是GLSL保留的操作符，将来可能会被使用。还有求模操作（%，%=)也是保留的。</p>
<p>&nbsp;</p>
<h4>数组访问</h4>
<p>数组的下标从0开始。合理的范围是[0, size - 1]。跟C语言一样。如果数组访问越界了，那行为是未定义的。如果着色器的编译器在编译时知道数组访问越界了，就会提示编译失败。</p>
<p>vec4 myColor, ambient, diffuse[6], specular[6];</p>
<p>myColor = ambient + diffuse[4] + specular[4];</p>
<p>&nbsp;</p>
<h4>构造函数</h4>
<p>构造函数可以用于初始化包含多个成员的变量，包括数组和结构体。构造函数也可以用在表达式中。调用方式如下：</p>
<p>vec3 myNormal = vec3(1.0, 1.0, 1.0);</p>
<p>greenTint = myColor + vec3(0.0, 1.0, 0.0);</p>
<p>ivec4 myColor = ivec4(255);</p>
<p>还可以使用混合标量和向量的方式来构造，只要你的元素足以填满该向量。</p>
<p>vec4 color = vec4(1.0, vec2(0.0, 1.0), 1.0);</p>
<p>vec3 v = vec3(1.0, 10.0, 1.0);</p>
<p>vec3 v1 = vec3(v);</p>
<p>vec2 fv = vec2(5.0, 6.0);</p>
<p>float f = float(fv);&nbsp;<a rel="nofollow">//用x值2.5构造，y值被舍弃</a></p>
<p>对于矩阵，OpenGL中矩阵是列主顺序的。如果只传了一个值，则会构造成对角矩阵，其余的元素为0.</p>
<p>mat3 m3 = mat3(1.0);</p>
<p>构造出来的矩阵式：</p>
<p>1.0 0.0 0.0</p>
<p>0.0 1.0 0.0</p>
<p>0.0 0.0 1.0</p>
<p>mat2 matrix1 = mat2(1.0, 0.0, 0.0, 1.0);</p>
<p>mat2 matrix2 = mat2(vec2(1.0, 0.0), vec2(0.0, 1.0));</p>
<p>mat2 matrix3 = mat2(1.0);&nbsp;</p>
<p>mat2 matrix4 = mat2(mat4(2.0));&nbsp;<a rel="nofollow">//会取</a>&nbsp;4×4矩阵左上角的2×2矩阵。</p>
<p>构造函数可以用于标量数据类型的转换。GLSL不支持隐式或显示的转换，只能通过构造函数来转。其中int转为float值是一样的。float转为int则小数部分被丢弃。int或float转为bool，0和0.0转为false，其余的值转为true. bool转为int或float，false值转为0和0.0，true转为1和1.0.</p>
<p>float f = 1.7;</p>
<p>int I = int(f); // I = 1</p>
<p>数组的初始化，可以在构造函数中传入值来初始化数组中对应的每一个值。</p>
<p>ivec2 position[3] = ivec2[3]((0,0), (1,1), (2,2));</p>
<p>ivec2 pos2[3] = ivec2[]((3,3), (2,1), (3,1));</p>
<p>构造函数也可以对结构体进行初始化。其中顺序和类型要一一对应。</p>
<pre>struct&nbsp;surface&nbsp;{&nbsp;&nbsp;int&nbsp;&nbsp;index;
&nbsp;&nbsp;vec3&nbsp;color;&nbsp;&nbsp;float&nbsp;rotate;
};

surface&nbsp;mySurface&nbsp;=&nbsp;surface(3,&nbsp;vec3(red,&nbsp;green,&nbsp;blue),&nbsp;0.5);</pre>
<p>&nbsp;</p>
<h4>成分选择</h4>
<p>向量中单独的成分可以通过{x,y,z,w},{r,g,b,a}或者{s,t,p,q}的记法来表示。这些不同的记法用于顶点，颜色，纹理坐标。在成分选择中，你不可以混合使用这些记法。其中{s,t,p,q}中的p替换了纹理的r坐标，因为与颜色r重复了。下面是用法举例：</p>
<pre>vec3&nbsp;myVec&nbsp;=&nbsp;{0.5,&nbsp;0.35,&nbsp;0.7};float&nbsp;r&nbsp;=&nbsp;myVec.r;float&nbsp;myYz&nbsp;=&nbsp;myVec.yz;float&nbsp;myQ&nbsp;=&nbsp;myVec.q;//出错，数组越界访问，q代表第四个元素float&nbsp;myRY&nbsp;=&nbsp;myVec.ry;&nbsp;//不合法，混合使用记法</pre>
<p>较特殊的使用方式，你可以重复向量中的元素，或者颠倒其顺序。如：</p>
<pre>vec3&nbsp;yxz&nbsp;=&nbsp;myVec.yxz;&nbsp;//调换顺序vec4&nbsp;mySSTT&nbsp;=&nbsp;myVec.sstt;&nbsp;//重复其中的值</pre>
<p>在赋值是，也可以选择你想要的顺序，但是不能重复其中的成分。</p>
<pre>vec4&nbsp;myColor&nbsp;=&nbsp;{0.0,&nbsp;1.0,&nbsp;2.0,&nbsp;1.0};
myColor.x&nbsp;=&nbsp;-1.0;
myColor.yz&nbsp;=&nbsp;vec2(3.0,&nbsp;5.0);
myColor.wx&nbsp;=&nbsp;vec2(1.0,&nbsp;3.0);
myColor.zz&nbsp;=&nbsp;vec2(2.0,&nbsp;3.0);&nbsp;//不合法</pre>
<p>我们也可以通过使用下标来访问向量或矩阵中的元素。如果越界那行为将是未定义的。</p>
<p>float myY = myVec[1];</p>
<p>在矩阵中，可以通过一维的下标来获得该列的向量(OpenGL的矩阵是列主顺序的)。二维的小标来获得向量中的元素。</p>
<pre>mat3&nbsp;myMat&nbsp;=&nbsp;mat3(1.0);
vec3&nbsp;myVec&nbsp;=&nbsp;myMat[0];&nbsp;//获得第一列向量&nbsp;1.0,&nbsp;0.0,&nbsp;0.0float&nbsp;f&nbsp;=&nbsp;myMat[0][0];&nbsp;//&nbsp;第一列的第一个向量。</pre>
<p>&nbsp;</p>
<h3>控制流</h3>
<p>&nbsp;</p>
<h4>循环</h4>
<p>与C和C++相似，GLSL语言也提供了for, while, do/while的循环方式。使用continue跳入下一次循环，break结束循环。</p>
<pre>for&nbsp;(l&nbsp;=&nbsp;0;&nbsp;l&nbsp;&lt;&nbsp;numLights;&nbsp;l++)
{if&nbsp;(!lightExists[l])continue;
&nbsp;&nbsp;&nbsp;&nbsp;color&nbsp;+=&nbsp;light[l];
}while&nbsp;(i&nbsp;&lt;&nbsp;num)
{
&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;color[i];
&nbsp;&nbsp;&nbsp;&nbsp;i++;
}do{
&nbsp;&nbsp;&nbsp;&nbsp;color&nbsp;+=&nbsp;light[lightNum];
&nbsp;&nbsp;&nbsp;&nbsp;lightNum--;
}while&nbsp;(lightNum&nbsp;&gt;&nbsp;0)</pre>
<p>&nbsp;</p>
<h4>if/else</h4>
<pre>color&nbsp;=&nbsp;unlitColor;if&nbsp;(numLights&nbsp;&gt;&nbsp;0)
{
&nbsp;&nbsp;&nbsp;&nbsp;color&nbsp;=&nbsp;litColor;
}else{
&nbsp;&nbsp;&nbsp;&nbsp;color&nbsp;=&nbsp;unlitColor;
}</pre>
<p>&nbsp;</p>
<h4>discard</h4>
<p>片段着色器中有一种特殊的控制流成为discard。使用discard会退出片段着色器，不执行后面的片段着色操作。片段也不会写入帧缓冲区。</p>
<p>if (color.a &lt; 0.9)</p>
<blockquote>
<p>discard;</p>
</blockquote>
<p>&nbsp;</p>
<h3>函数</h3>
<p>在每个shader中必须有一个main函数。main函数中的void参数是可选的，但返回值是void时必须的。</p>
<pre>void&nbsp;main(void)
{
&nbsp;...
}</pre>
<p>GLSL中的函数，必须是在全局范围定义和声明的。不能在函数定义中声明或定义函数。函数必须有返回类型，参数是可选的。参数的修饰符(in, out, inout, const等）是可选的。</p>
<pre>//函数声明bool&nbsp;isAnyNegative(const&nbsp;vec4&nbsp;v);//函数调用void&nbsp;main(void)
{bool&nbsp;isNegative&nbsp;=&nbsp;isAnyNegative(gl_Color);
&nbsp;&nbsp;&nbsp;&nbsp;...
}//定义bool&nbsp;isAnyNegative(const&nbsp;vec4&nbsp;v)
{if&nbsp;(v.x&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;v.y&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;v.z&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;v.w&nbsp;&lt;&nbsp;0.0)return&nbsp;true;elsereturn&nbsp;false;
}</pre>
<p>结构体和数组也可以作为函数的参数。如果是数组作为函数的参数，则必须制定其大小。在调用传参时，只传数组名就可以了。</p>
<pre>vec4&nbsp;sumVectors(int&nbsp;sumSize,&nbsp;vec4&nbsp;v[10]);void&nbsp;main()
{
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;myColors[10];
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;sumColor&nbsp;=&nbsp;sumVectors(5,&nbsp;myColors);
}

vec4&nbsp;sumVectors(int&nbsp;sumSize,&nbsp;vec4&nbsp;v[10])
{int&nbsp;i&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;sum&nbsp;=&nbsp;vec4(0.0);for(;&nbsp;i&nbsp;&lt;&nbsp;sumSize;&nbsp;++i)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;v[i];&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}return&nbsp;sum;
}</pre>
<p>GLSL的函数是支持重载的。函数可以同名但其参数类型或者参数个数不同即可。</p>
<pre>float&nbsp;sum(float&nbsp;a,&nbsp;float&nbsp;b)
{return&nbsp;a&nbsp;+&nbsp;b;
}

vec3&nbsp;sum(vec3&nbsp;v1,&nbsp;vec3&nbsp;v2)
{return&nbsp;v1&nbsp;+&nbsp;v2;
}</pre>
<p>GLSL中函数递归是不被允许的。其行为是未定义的。</p>
<p>GLSL中提供了许多内建的函数，来方便我们的使用。可以在官方手册中查找相关的函数<a href="http://www.opengl.org/sdk/docs/man/" rel="nofollow" target="_blank">http://www.opengl.org/sdk/docs/man/</a></p>
<p>GLSL指南&nbsp;<a href="http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf" rel="nofollow" target="_blank">http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf</a></p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
		</div>
		<div class="itemdesc">
			发表于 
<span id="post-date">2019-06-04 10:40</span>&nbsp;
<a href="https://www.cnblogs.com/kefeiGame/">KefeiGame</a>&nbsp;
阅读(<span id="post_view_count">2859</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=10972139" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(10972139);return false;">收藏</a>
		</div>
	</div>
	<div class="seperator">&nbsp;</div>
	
	
<script src="https://common.cnblogs.com/highlight/10.3.1/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 370040, cb_blogApp = 'kefeiGame', cb_blogUserGuid = '515ec782-0c21-4beb-d1c1-08d49c352df2';
    var cb_entryId = 10972139, cb_entryCreatedDate = '2019-06-04 10:40', cb_postType = 1;
    updatePostStats(
        [cb_entryId],
        function(id, count) { $("#post_view_count").text(count) },
        function(id, count) { $("#post_comment_count").text(count) })
</script>
<a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
       var commentManager = new blogCommentManager();
       commentManager.renderComments(0);
       fixPostBody();
       deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);       deliverT2();
       deliverC1C2();
       loadNewsAndKb();
       loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);       LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
       GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
       loadOptUnderPost();
       GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
   </script>
</div>

</div>
</div>

</td>
</tr>
</table>
</td>
<td width="200" valign="top" style="border-left: dashed 1px #CCCCCC">
<table align="center" width="100%" height="1400" cellspacing="0" cellpadding="5" border="0">
<tr>
<td class="banner" valign="top" style="padding-top: 0px">

<table width="100%" height="200">
<tr>
<td>
<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
</td>
</tr>
</table>
<div id="side_right">
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
</div>

<br/>
<div class="footer">
	Powered by: <a href="http://www.cnblogs.com">博客园</a><br>
	Copyright &copy; 2020 KefeiGame
<br /><span id="poweredby">Powered by .NET 5.0.1-servicing.20575.16 on Kubernetes</span>

</div>


</td>
</tr>
</table>
</td>
</tr>
</table>


    
</body>
</html>
