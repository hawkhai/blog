<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="index.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Technologies|Mobile Technologies|Native Development on NVIDIA Android Devices" class=" js no-touch svg inlinesvg svgclippaths no-ie8compat" style=""><!-- saved from url=(0016)http://localhost --><head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta name="googlebot" content="" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="msapplication-config" content="../../../Skins/Favicons/browserconfig.xml" />
        <link rel="apple-touch-icon" sizes="40x40" href="../../../Skins/Favicons/NVLogo-V-White-Small.png" />
        <link rel="shortcut icon" href="../../../Skins/Favicons/nvidia.ico" />
        <link rel="icon" sizes="48x48" href="../../../Skins/Favicons/nvidia.ico" />
        <link rel="icon" sizes="48x48" href="../../../Skins/Favicons/nvidia.ico" />
        <link rel="icon" sizes="48x48" href="../../../Skins/Favicons/nvidia.ico" /><title>OpenGL ES 2.0</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <style>/*&amp;lt;meta /&amp;gt;*/

.needs-pie
{
	behavior: url('../../../Resources/Scripts/PIE.htc');
}

</style>
        <link href="../../resources/stylesheets/style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script><meta class="foundation-mq-small" /><meta class="foundation-mq-medium" /><meta class="foundation-mq-large" /><meta class="foundation-mq-xlarge" /><meta class="foundation-mq-xxlarge" /><style></style>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
        <script src="../../../Skins/Default/Scripts/GW_TopicToolbar.js">
        </script>
    <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/google/code-prettify/master/loader/prettify.css" /><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="../../../Data/Language.js" src="../../../Data/Language.js?t=637480536788895129"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="../../../Data/Tocs/Master.js" src="../../../Data/Tocs/Master.js?t=637480536788895129"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="../../../Data/Tocs/Master_Chunk0.js" src="../../../Data/Tocs/Master_Chunk0.js?t=637480536788895129"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="../../../Data/Tocs/Master_Chunk1.js" src="../../../Data/Tocs/Master_Chunk1.js?t=637480536788895129"></script></head>
    <body>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop"><a href="../../../index.html#technologies/mobile/native_android_opengles.htm">Open topic with navigation</a>
        </p>
        <div class="nocontent">
            <div class="MCBreadcrumbsBox_style.css_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="3" data-mc-toc="True" data-mc-chunk="Data/Toc.xml"><span class="MCBreadcrumbsPrefix">You are here: </span>
            <a href="../../../content/technologies/technologies.htm?TocPath=Technologies|_____0" class="MCBreadcrumbsLink">Technologies</a><span class="MCBreadcrumbsDivider"> &gt; </span><a href="../../../content/technologies/mobile_technologies.htm?TocPath=Technologies|Mobile%20Technologies|_____0" class="MCBreadcrumbsLink">Mobile Technologies</a><span class="MCBreadcrumbsDivider"> &gt; </span><a href="../../../content/technologies/mobile/native_android_development.htm?TocPath=Technologies|Mobile%20Technologies|Native%20Development%20on%20NVIDIA%C2%A0Android%20Devices|_____0" class="MCBreadcrumbsLink">Native Development on NVIDIA Android Devices</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbsSelf">OpenGL ES 2.0</span></div>
        </div>
        <h1><span class="SystemTitle">OpenGL ES 2.0</span>
        </h1><a name="kanchor314"></a>
        <div id="pageheader">
            <hr style="height: 1px;" width="100%" size="0" align="center" />
        </div>
        <p>OpenGL ES provides a fast way to display the camera images, possibly after some image processing, and allows building simple user interfaces.  In this section, we only cover 2D graphics using OpenGL ES 2.0. For 3D graphics, there are other tutorials available, as well as the NativeGlobe example provided in CodeWorks for Android.  From now on, we'll use GL as a shorthand for OpenGL ES 2.0. We also cover how to handle various Android events in a native program.</p>
        <p>We first show how to import an existing native GL project into your workspace, and then we show you how to create the same project from scratch. For the latter, we will follow similar steps to those described in <a href="native_android_devprocess.htm#Creating_nativeactivity">Creating a NativeActivity</a>, in case you need a more in-depth overview.</p>
        <h3><a name="Importing_existing_project"></a>Importing an existing project</h3>
        <p>Let's start the first GL application by importing an existing project to Eclipse. Start by importing <code>/tutorials/SimpleNativeGL</code> project. Open Eclipse, select <b>File &gt; Import &gt; Android &gt; Existing Android Code</b> into <code>Workspace*</code>, and browse into the <b>Root Directory</b> (<code>/tutorials/SimpleNativeGL</code>). You can copy the files into the project directory in the workspace if you want by selecting one of the boxes. Then hit <b>Finish</b>.</p>
        <p>If the project has the default name, like so:</p>
        <p>
            <img src="images/import_wrong_name.png" />
        </p>
        <p>... then you should rename the project (right-click the project and find the <b>Rename</b> option. Its location may vary depending on the operating system, could be under Refactor).</p>
        <p>
            <img src="images/project_rename.png" />
        </p>
        <p>In this case, we'll use the name SimpleNativeGL. Open the project in the <b>Package Explorer</b>. </p>
        <p>
            <img src="images/simple_gl_project.png" />
        </p>
        <p>The files and folders within the red rectangle are the ones you just imported, others were generated during the Import operation.</p>
        <p>As this is a native project, select the C/C++ perspective.</p>
        <p>
            <img src="images/c_cpp_perspective.png" />
        </p>
        <p>By default all Android projects are Java projects, let's convert ours to native by right-clicking the project in <b>Package Explorer</b> and selecting <b>New &gt; Convert to C/C++ Project</b>.  Select <b>Project Type</b> to be <code>Makefile project</code> and <b>Toolchain</b> to be <code>Android GCC</code>.</p>
        <p>
            <img src="images/convert_to_cpp.png" />
        </p>
        <p>Sometimes the project might be imported with the wrong Android version. In the Project Explorer, right-click on the project folder and choose <b>Properties</b>. In the <b>Android</b> tab, make sure that the version selected is at least <b>Android 4.0.3 (API 15)</b>:</p>
        <p>
            <img src="images/gl_setandroid.png" />
        </p>
        <p>Build the project (right-click <b>SimpleNativeGL &gt; Build Project</b>), and run it on your device (right-click <b>SimpleNativeGL &gt; Run As &gt; Android Application</b>). Try tapping the device display, and slide your finger along the display; the solid color that is displayed should vary depending on the touch location.</p>
        <h3><a name="Creating_project_from_scratch"></a>Creating a GL project from scratch</h3>
        <p>To learn how to create a project from scratch, let's go through the steps necessary to create the project we imported in the previous section. If you imported the project already, right-click on the project name in the Project Explorer pane, and click delete. If you copied the files into the workspace when importing the project, in the next window check the box <code>Delete project contents from disk (cannot be undone)</code>, and verify that you're deleting the correct project. As a general rule, you should always be extremely cautious when using this option, since Eclipse does not move the project to the trash, but rather deletes it completely. Finally click <b>OK</b>.</p>
        <p>From the Java perspective, let's create the new project:</p>
        <ul>
            <li value="1"> Create a new Android application (<b>File &gt; New &gt; Android Application Project</b>).</li>
            <li value="2"> Pick an <b>Application Name</b> (in this tutorial we are using <code>SimpleNativeGL</code> as a name).</li>
            <li value="3"> Change the <b>Minimum Required SDK</b> to <code>API 9: Android 2.3 (Gingerbread)</code>.</li>
            <li value="4"> Uncheck <i>Create custom launcher icon</i> and click <b>Next</b>.</li>
            <li value="5"> Uncheck <i>Create activity</i> and click <b>Finish</b>.</li>
        </ul>
        <p>Now we need to add native support:</p>
        <ul>
            <li value="1">Right-click on the project name and choose <b>Android tools &gt; Add Native Support ...</b></li>
            <li value="2">Leave the name of the lib as is and click <b>Finish</b>.</li>
        </ul>
        <p>Eclipse should now have switched to the C/C++ perspective. First let's modify the manifest file. Open the <code>AndroidManifest.xml</code> file, and switch to the <code>AndroidManifest.xml</code> tab at the bottom of the window to be able to see the actual xml code. Now, replace the code within the application block with the lines highlighted below:</p>
        <blockquote><pre class="prettyprint prettyprinted" xml:space="preserve" style=""><span class="tag">&lt;manifest</span><span class="pln"> </span><span class="atn">xmlns:android</span><span class="pun">=</span><span class="atv">"http://schemas.android.com/apk/res/android"</span><br /><span class="pln">    </span><span class="atn">package</span><span class="pun">=</span><span class="atv">"com.nvidia.example.simplenativegl"</span><br /><span class="pln">    </span><span class="atn">android:versionCode</span><span class="pun">=</span><span class="atv">"1"</span><br /><span class="pln">    </span><span class="atn">android:versionName</span><span class="pun">=</span><span class="atv">"1.0"</span><span class="pln"> </span><span class="tag">&gt;</span><span class="pln">
</span><br /><span class="pln">    </span><span class="tag">&lt;uses-sdk</span><br /><span class="pln">	</span><span class="atn">android:minSdkVersion</span><span class="pun">=</span><span class="atv">"14"</span><br /><span class="pln">	</span><span class="atn">android:targetSdkVersion</span><span class="pun">=</span><span class="atv">"15"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
</span><br /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">&lt;!-- We do not have Java code. Therefore android:hasCode is set to false. --&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="tag">&lt;application</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="atn">android:hasCode</span><span class="pun">=</span><span class="atv">"false"</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="atn">android:label</span><span class="pun">=</span><span class="atv">"@string/app_name"</span><span class="pln"> </span><span class="tag">&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="com">&lt;!--</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="com">	    Our activity is the built-in NativeActivity framework class.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="com">	    This will take care of integrating with our NDK code.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="com">	--&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="tag">&lt;activity</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="atn">android:name</span><span class="pun">=</span><span class="atv">"android.app.NativeActivity"</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="atn">android:configChanges</span><span class="pun">=</span><span class="atv">"orientation|keyboard|keyboardHidden"</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="atn">android:label</span><span class="pun">=</span><span class="atv">"@string/app_name"</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="atn">android:theme</span><span class="pun">=</span><span class="atv">"@android:style/Theme.NoTitleBar.Fullscreen"</span><span class="pln"> </span><span class="tag">&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="com">&lt;!-- Tell NativeActivity the name of our .so --&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="tag">&lt;meta-data</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">		</span><span class="atn">android:name</span><span class="pun">=</span><span class="atv">"android.app.lib_name"</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">		</span><span class="atn">android:value</span><span class="pun">=</span><span class="atv">"SimpleNativeGL"</span><span class="pln"> </span><span class="tag">/&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="tag">&lt;intent-filter&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	        </span><span class="tag">&lt;action</span><span class="pln"> </span><span class="atn">android:name</span><span class="pun">=</span><span class="atv">"android.intent.action.MAIN"</span><span class="pln"> </span><span class="tag">/&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">		</span><span class="tag">&lt;category</span><span class="pln"> </span><span class="atn">android:name</span><span class="pun">=</span><span class="atv">"android.intent.category.LAUNCHER"</span><span class="pln"> </span><span class="tag">/&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln"> 	    </span><span class="tag">&lt;/intent-filter&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="tag">&lt;/activity&gt;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="tag">&lt;/application&gt;</span></span><br style="background-color: #ffffe0;" /><span class="tag">&lt;/manifest&gt;</span></pre>
        </blockquote>
        <p>Now open the <code>Android.mk</code> file from the <code>jni</code> folder, and add the lines highlighted below:</p>
        <blockquote><pre class="prettyprint prettyprinted" xml:space="preserve" style=""><span class="pln">LOCAL_PATH </span><span class="pun">:=</span><span class="pln"> $</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">my</span><span class="pun">-</span><span class="pln">dir</span><span class="pun">)</span><span class="pln">
</span><br /><span class="pln">include $</span><span class="pun">(</span><span class="pln">CLEAR_VARS</span><span class="pun">)</span><span class="pln">
</span><br /><span class="pln">LOCAL_MODULE    </span><span class="pun">:=</span><span class="pln"> </span><span class="typ">SimpleNativeGL</span><br /><span class="pln">LOCAL_SRC_FILES </span><span class="pun">:=</span><span class="pln"> </span><span class="typ">SimpleNativeGL</span><span class="pun">.</span><span class="pln">cpp</span><br /><span style="background-color: #ffffe0;"><span class="pln">LOCAL_LDLIBS    </span><span class="pun">:=</span><span class="pln"> </span><span class="pun">-</span><span class="pln">llog </span><span class="pun">-</span><span class="pln">landroid </span><span class="pun">-</span><span class="pln">lEGL </span><span class="pun">-</span><span class="pln">lGLESv2</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">LOCAL_STATIC_LIBRARIES </span><span class="pun">:=</span><span class="pln"> android_native_app_glue</span></span><br /><span class="pln">include $</span><span class="pun">(</span><span class="pln">BUILD_SHARED_LIBRARY</span><span class="pun">)</span><span class="pln">
</span><br /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> android</span><span class="pun">/</span><span class="pln">native_app_glue</span><span class="pun">)</span></span></pre>
        </blockquote>
        <p> </p>
        <p>In addition to what we went over in the tutorial <a href="native_android_devprocess.htm#Creating_nativeactivity">Creating a NativeActivity</a>,  we need to link against the <i>EGL</i> and <i>GLESv2</i> libraries.</p>
        <p>In order to make sure that our application will be fully optimized, let's create an <code>Application.mk</code> file: right-click on the <code>jni</code> folder then <b>New &gt; File</b> and set the name to <code>Application.mk</code>. Open the new file and add to it the line:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">APP_ABI </span><span class="pun">:=</span><span class="pln"> armeabi</span><span class="pun">-</span><span class="pln">v7a</span></pre>
        </blockquote>
        <p>Now we need to populate the file <code>SimpleNativeGL.cpp</code>. Let's start by including headers and creating macros to log events:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;jni.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;errno.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;EGL/egl.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;GLES2/gl2.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;android/sensor.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;android_native_app_glue.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;android/log.h&gt;</span><br /><span class="com">#define</span><span class="pln"> LOGW</span><span class="pun">(...)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">__android_log_print</span><span class="pun">(</span><span class="pln">ANDROID_LOG_WARN</span><span class="pun">,</span><span class="pln"> </span><span class="str">"SimpleNativeGL"</span><span class="pun">,</span><span class="pln"> __VA_ARGS__</span><span class="pun">))</span><br /><span class="com">#define</span><span class="pln"> LOGI</span><span class="pun">(...)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">__android_log_print</span><span class="pun">(</span><span class="pln">ANDROID_LOG_INFO</span><span class="pun">,</span><span class="pln"> </span><span class="str">"SimpleNativeGL"</span><span class="pun">,</span><span class="pln"> __VA_ARGS__</span><span class="pun">))</span></pre>
        </blockquote>
        <p>Now let's create a <code>struct</code> to share the current status between different functions, and let's add placeholders for the functions we'll need to implement for this simple example:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">/**</span><br /><span class="com"> * State of our app</span><br /><span class="com"> */</span><br /><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Save in the engine a pointer to the Android app</span><br /><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">;</span><br /><span class="pln">    </span><span class="com">// EGL Display, surface, and context</span><br /><span class="pln">    </span><span class="typ">EGLDisplay</span><span class="pln"> display</span><span class="pun">;</span><br /><span class="pln">    </span><span class="typ">EGLSurface</span><span class="pln"> surface</span><span class="pun">;</span><br /><span class="pln">    </span><span class="typ">EGLContext</span><span class="pln"> context</span><span class="pun">;</span><br /><span class="pln">    </span><span class="com">// States and touch locations</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln"> animating</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln">  width</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln">  height</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln">  x_touch</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln">  y_touch</span><span class="pun">;</span><br /><span class="pun">};</span><br /><span class="com">/**</span><br /><span class="com"> * Initialize an EGL context for the current display</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> engine_init_display</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">){}</span><span class="pln">
</span><br /><span class="com">/**</span><br /><span class="com"> * Draw the current frame on the display</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> engine_draw_frame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">){}</span><span class="pln">
</span><br /><span class="com">/**</span><br /><span class="com"> * Tear down the EGL context currently associated with the display</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> engine_term_display</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">){}</span><span class="pln">
</span><br /><span class="com">/**</span><br /><span class="com"> * Process the input event</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="typ">int32_t</span><span class="pln"> engine_handle_input</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="kwd">event</span><span class="pln"> </span><span class="pun">){}</span><span class="pln">
</span><br /><span class="com">/**</span><br /><span class="com"> * Process the next main command</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> engine_handle_cmd</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> </span><span class="typ">int32_t</span><span class="pln"> cmd </span><span class="pun">){}</span><span class="pln">
</span><br /><span class="com">/**</span><br /><span class="com"> * This is the main entry point of a native application that is using</span><br /><span class="com"> * android_native_app_glue.  It runs in its own thread, with its own</span><br /><span class="com"> * event loop for receiving input events and doing other things.</span><br /><span class="com"> */</span><br /><span class="kwd">void</span><span class="pln"> android_main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app </span><span class="pun">){}</span></pre>
        </blockquote>
        <p>Now let's implement the different functions starting with the main:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">/**</span><br /><span class="com"> * This is the main entry point of a native application that is using</span><br /><span class="com"> * android_native_app_glue.  It runs in its own thread, with its own</span><br /><span class="com"> * event loop for receiving input events and doing other things.</span><br /><span class="com"> */</span><br /><span class="kwd">void</span><span class="pln"> android_main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Make sure glue isn't stripped</span><br /><span class="pln">    app_dummy</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="com">// Initialize the engine.</span><br /><span class="pln">    </span><span class="com">// The engine stores the state and global variables of the application.</span><br /><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> engine</span><span class="pun">;</span><br /><span class="pln">    memset</span><span class="pun">(</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">engine</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln"> engine </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="com">// The engine needs a pointer to app, e.g., to access the window data</span><br /><span class="pln">    engine</span><span class="pun">.</span><span class="pln">app </span><span class="pun">=</span><span class="pln"> app</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Link the app to the engine and attach callbacks.</span><br /><span class="pln">    </span><span class="com">// Store a pointer to the application engine for event handling.</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">userData     </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">engine</span><span class="pun">;</span><br /><span class="pln">    </span><span class="com">// Callback for handling application status changes</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">onAppCmd     </span><span class="pun">=</span><span class="pln"> engine_handle_cmd</span><span class="pun">;</span><br /><span class="pln">    </span><span class="com">// Callback for handling touch input</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">onInputEvent </span><span class="pun">=</span><span class="pln"> engine_handle_input</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// The core of the main is an infinite loop which waits for events</span><br /><span class="pln">    </span><span class="com">// and redraws the frame when needed.</span><br /><span class="pln">    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// read all pending events</span><br /><span class="pln">	</span><span class="kwd">int</span><span class="pln"> events</span><span class="pun">;</span><br /><span class="pln">	</span><span class="kwd">struct</span><span class="pln"> android_poll_source </span><span class="pun">*</span><span class="pln">source</span><span class="pun">;</span><br /><br /><span class="pln">	</span><span class="com">// If not animating, we will block forever waiting for events.</span><br /><span class="pln">	</span><span class="com">// If animating, we loop until all events are read, then continue</span><br /><span class="pln">	</span><span class="com">// to draw the next frame of animation.</span><br /><span class="pln">	</span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">ALooper_pollAll</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">.</span><span class="pln">animating </span><span class="pun">?</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">events</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">**</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">source </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    </span><span class="com">// Process this event.</span><br /><span class="pln">	    </span><span class="com">// Depending on the event, app-&gt;onAppCmd or app-&gt;onInputEvent may be called.</span><br /><span class="pln">	    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> source </span><span class="pun">!=</span><span class="pln"> NULL </span><span class="pun">)</span><br /><span class="pln">	    </span><span class="pun">{</span><br /><span class="pln">		source</span><span class="pun">-&gt;</span><span class="pln">process</span><span class="pun">(</span><span class="pln"> app</span><span class="pun">,</span><span class="pln"> source </span><span class="pun">);</span><br /><span class="pln">	    </span><span class="pun">}</span><br /><br /><span class="pln">	    </span><span class="com">// Check if we are exiting (e.g., user presses the back button)</span><br /><span class="pln"> 	    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> app</span><span class="pun">-&gt;</span><span class="pln">destroyRequested </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">	    </span><span class="pun">{</span><br /><span class="pln">		engine_term_display</span><span class="pun">(</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">engine </span><span class="pun">);</span><br /><span class="pln">		</span><span class="kwd">return</span><span class="pun">;</span><br /><span class="pln">	    </span><span class="pun">}</span><br /><span class="pln">	</span><span class="pun">}</span><br /><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">.</span><span class="pln">animating </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    </span><span class="com">// Done with events; draw next animation frame.</span><br /><span class="pln">	    </span><span class="com">// Drawing is synched with the screen update rate, so there</span><br /><span class="pln">	    </span><span class="com">// is no need to do timing here.</span><br /><span class="pln">	    engine_draw_frame</span><span class="pun">(</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">engine </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>First, <code>app_dummy()</code> is called to make sure all the Android callbacks are not optimized away by the compiler (more about it <a href="http://blog.beuc.net/posts/Make_sure_glue_isn__39__t_stripped/">here</a>). Next, an instance of <code>struct Engine</code> is created to store the global data of this application, including a pointer back to<code> struct android_app*app</code>. The <code>app</code> stores a pointer to the Engine, as well as pointers to two callbacks defined below. The core of this function is an infinite loop that iterates between handling events such as touches, and drawing a frame.</p>
        <p>Before diving into the functions that perform the GL calls we need to implement the functions that handle the callback inputs:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">/**</span><br /><span class="com"> * Process the input event</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="typ">int32_t</span><span class="pln"> engine_handle_input</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="kwd">event</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Get a local pointer to the engine that we stored in the application</span><br /><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> app</span><span class="pun">-&gt;</span><span class="pln">userData</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Analyze the type of event</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="typ">AInputEvent_getType</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> AINPUT_EVENT_TYPE_MOTION </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// If the user lifted the finger from the screen, stop updating</span><br /><span class="pln">	</span><span class="typ">int32_t</span><span class="pln"> action </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AMotionEvent_getAction</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> action </span><span class="pun">!=</span><span class="pln"> AMOTION_EVENT_ACTION_MOVE </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    engine</span><span class="pun">-&gt;</span><span class="pln">animating </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">	    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><br /><span class="pln">	</span><span class="pun">}</span><br /><br /><span class="pln">	</span><span class="com">// Otherwise get the touch position and set animation to true</span><br /><span class="pln">	engine</span><span class="pun">-&gt;</span><span class="pln">x_touch </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AMotionEvent_getX</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	engine</span><span class="pun">-&gt;</span><span class="pln">y_touch </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AMotionEvent_getY</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	engine</span><span class="pun">-&gt;</span><span class="pln">animating </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><br /><span class="pun">}</span><br /><br /><span class="com">/**</span><br /><span class="com"> * Process the next main command</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> engine_handle_cmd</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> </span><span class="typ">int32_t</span><span class="pln"> cmd </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Get a local pointer to the engine that we stored in the application</span><br /><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> app</span><span class="pun">-&gt;</span><span class="pln">userData</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Analyze the command</span><br /><span class="pln">    </span><span class="kwd">switch</span><span class="pun">(</span><span class="pln"> cmd </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_INIT_WINDOW</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// The window is being shown, get it ready</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">app</span><span class="pun">-&gt;</span><span class="pln">window </span><span class="pun">!=</span><span class="pln"> NULL </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    </span><span class="com">// Initialize the engine based on the current display</span><br /><span class="pln">	    engine_init_display</span><span class="pun">(</span><span class="pln"> engine </span><span class="pun">);</span><br /><span class="pln">	    </span><span class="com">// Start drawing</span><br /><span class="pln">	    engine_draw_frame</span><span class="pun">(</span><span class="pln"> engine </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">	</span><span class="kwd">break</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_TERM_WINDOW</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// The window is being hidden or closed, clean it up</span><br /><span class="pln">	engine_term_display</span><span class="pun">(</span><span class="pln"> engine </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">break</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_LOST_FOCUS</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// When our app loses focus, we stop animating</span><br /><span class="pln">	engine</span><span class="pun">-&gt;</span><span class="pln">animating </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">	</span><span class="kwd">break</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>The GL calls happen in functions static int <code>engine_init_display(struct Engine *engine)</code>, <code>static void engine_draw_frame(struct Engine *engine)</code>, and <code>static void engine_term_display(struct Engine *engine)</code>.  The first one initializes GL context and drawing surface using the GL companion API EGL.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">/**</span><br /><span class="com"> * Initialize an EGL context for the current display</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> engine_init_display</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// initialize OpenGL ES and EGL</span><br /><span class="pln">    </span><span class="typ">EGLDisplay</span><span class="pln"> display </span><span class="pun">=</span><span class="pln"> eglGetDisplay</span><span class="pun">(</span><span class="pln"> EGL_DEFAULT_DISPLAY </span><span class="pun">);</span><br /><br /><span class="pln">    eglInitialize</span><span class="pun">(</span><span class="pln"> display</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Specify the attributes of the desired configuration.</span><br /><span class="pln">    </span><span class="com">// We select an EGLConfig with at least 8 bits per color component</span><br /><span class="pln">    </span><span class="com">// that is compatible with on-screen windows.</span><br /><span class="pln">    </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">EGLint</span><span class="pln"> attribs</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><br /><span class="pln">    </span><span class="pun">{</span><span class="pln"> EGL_SURFACE_TYPE</span><span class="pun">,</span><span class="pln"> EGL_WINDOW_BIT</span><span class="pun">,</span><span class="pln"> EGL_BLUE_SIZE</span><span class="pun">,</span><span class="pln"> </span><span class="lit">8</span><span class="pun">,</span><span class="pln"> EGL_GREEN_SIZE</span><span class="pun">,</span><span class="pln"> </span><span class="lit">8</span><span class="pun">,</span><span class="pln"> EGL_RED_SIZE</span><span class="pun">,</span><span class="pln"> </span><span class="lit">8</span><span class="pun">,</span><span class="pln"> EGL_NONE </span><span class="pun">};</span><br /><br /><span class="pln">    </span><span class="com">// Here, the application chooses the configuration it desires.</span><br /><span class="pln">    </span><span class="com">// eglChooseConfig in general returns all the configurations compatible</span><br /><span class="pln">    </span><span class="com">// with the attributes passed. In this sample, we have a very simplified</span><br /><span class="pln">    </span><span class="com">// selection process, where we pick the first EGLConfig that matches</span><br /><span class="pln">    </span><span class="com">// our criteria (by setting the third argument to 1).</span><br /><span class="pln">    </span><span class="typ">EGLConfig</span><span class="pln"> config</span><span class="pun">;</span><br /><span class="pln">    </span><span class="typ">EGLint</span><span class="pln"> numConfigs</span><span class="pun">;</span><br /><span class="pln">    eglChooseConfig</span><span class="pun">(</span><span class="pln"> display</span><span class="pun">,</span><span class="pln"> attribs</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">config</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">numConfigs </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is</span><br /><span class="pln">    </span><span class="com">// guaranteed to be accepted by ANativeWindow_setBuffersGeometry().</span><br /><span class="pln">    </span><span class="com">// We can use it to make the ANativeWindow buffers to match.</span><br /><span class="pln">    </span><span class="typ">EGLint</span><span class="pln"> format</span><span class="pun">;</span><br /><span class="pln">    eglGetConfigAttrib</span><span class="pun">(</span><span class="pln"> display</span><span class="pun">,</span><span class="pln"> config</span><span class="pun">,</span><span class="pln"> EGL_NATIVE_VISUAL_ID</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">format </span><span class="pun">);</span><br /><span class="pln"> </span><br /><span class="pln">    </span><span class="com">// Set a native Android window to have the format configured by EGL</span><br /><span class="pln">    </span><span class="typ">ANativeWindow_setBuffersGeometry</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">app</span><span class="pun">-&gt;</span><span class="pln">window</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> format </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Create EGL surface and context</span><br /><span class="pln">    </span><span class="typ">EGLSurface</span><span class="pln"> surface </span><span class="pun">=</span><span class="pln"> eglCreateWindowSurface</span><span class="pun">(</span><span class="pln"> display</span><span class="pun">,</span><span class="pln"> config</span><span class="pun">,</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">app</span><span class="pun">-&gt;</span><span class="pln">window</span><span class="pun">,</span><span class="pln"> NULL </span><span class="pun">);</span><br /><span class="pln">    </span><span class="typ">EGLContext</span><span class="pln"> context </span><span class="pun">=</span><span class="pln"> eglCreateContext</span><span class="pun">(</span><span class="pln"> display</span><span class="pun">,</span><span class="pln"> config</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">,</span><span class="pln"> NULL </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Use the surface and context we just created and configure the engine</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> eglMakeCurrent</span><span class="pun">(</span><span class="pln"> display</span><span class="pun">,</span><span class="pln"> surface</span><span class="pun">,</span><span class="pln"> surface</span><span class="pun">,</span><span class="pln"> context </span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> EGL_FALSE </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	LOGW</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Unable to eglMakeCurrent"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="com">// Get width and height of the surface</span><br /><span class="pln">    </span><span class="typ">EGLint</span><span class="pln"> w</span><span class="pun">,</span><span class="pln"> h</span><span class="pun">;</span><br /><span class="pln">    eglQuerySurface</span><span class="pun">(</span><span class="pln"> display</span><span class="pun">,</span><span class="pln"> surface</span><span class="pun">,</span><span class="pln"> EGL_WIDTH</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">w </span><span class="pun">);</span><br /><span class="pln">    eglQuerySurface</span><span class="pun">(</span><span class="pln"> display</span><span class="pun">,</span><span class="pln"> surface</span><span class="pun">,</span><span class="pln"> EGL_HEIGHT</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">h </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Store the app variables so the callbacks can access the data</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">display </span><span class="pun">=</span><span class="pln"> display</span><span class="pun">;</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">context </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">;</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">surface </span><span class="pun">=</span><span class="pln"> surface</span><span class="pun">;</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">width   </span><span class="pun">=</span><span class="pln"> w</span><span class="pun">;</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">height  </span><span class="pun">=</span><span class="pln"> h</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Initialize GL state</span><br /><span class="pln">    glEnable</span><span class="pun">(</span><span class="pln"> GL_CULL_FACE </span><span class="pun">);</span><br /><span class="pln">    glDisable</span><span class="pun">(</span><span class="pln"> GL_DEPTH_TEST </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Now that we have initialized the engine, we can implement the function to draw frames. In this simple example, we will be just setting a solid background color based on the touch location: we set the green channel to zero, and the blue (red) channel is driven by the vertical (horizontal) position of the touch on the screen.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">/**</span><br /><span class="com"> * Draw the current frame on the display</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> engine_draw_frame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">display </span><span class="pun">==</span><span class="pln"> NULL </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="com">// No display</span><br /><br /><span class="pln">    </span><span class="com">// Set the clear color based on the touch location from the engine</span><br /><span class="pln">    glClearColor</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">x_touch </span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">width</span><span class="pun">,</span><span class="pln">  </span><span class="com">// Red channel</span><br /><span class="pln">		  </span><span class="lit">0</span><span class="pun">,</span><span class="pln">                                              </span><span class="com">// Green channel</span><br /><span class="pln">		  </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">y_touch </span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">height</span><span class="pun">,</span><span class="pln"> </span><span class="com">// Blue channel</span><br /><span class="pln">		  </span><span class="lit">1</span><span class="pln"> </span><span class="pun">);</span><span class="pln">                                            </span><span class="com">// Alpha channel</span><br /><span class="pln">    </span><span class="com">// Clear the screen to the color we just set</span><br /><span class="pln">    glClear</span><span class="pun">(</span><span class="pln"> GL_COLOR_BUFFER_BIT </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Swap the buffers, which indicates we're done with rendering this frame</span><br /><span class="pln">    eglSwapBuffers</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">display</span><span class="pun">,</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">surface </span><span class="pun">);</span><br /><span class="pln">    </span><span class="com">// LOGI( "Buffers swapped by eglSwapBuffers..." );</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>The last function that we need to implement cleans up the EGL structures at application exit:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">/** </span><br /><span class="com"> * Tear down the EGL context currently associated with the display</span><br /><span class="com"> */</span><br /><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> engine_term_display</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">display </span><span class="pun">!=</span><span class="pln"> EGL_NO_DISPLAY </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	eglMakeCurrent</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">display</span><span class="pun">,</span><span class="pln"> EGL_NO_SURFACE</span><span class="pun">,</span><span class="pln"> EGL_NO_SURFACE</span><span class="pun">,</span><span class="pln"> EGL_NO_CONTEXT </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">context </span><span class="pun">!=</span><span class="pln"> EGL_NO_CONTEXT </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    eglDestroyContext</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">display</span><span class="pun">,</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">context </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">surface </span><span class="pun">!=</span><span class="pln"> EGL_NO_SURFACE </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    eglDestroySurface</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">display</span><span class="pun">,</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">surface </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">	eglTerminate</span><span class="pun">(</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">display </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">animating </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">display   </span><span class="pun">=</span><span class="pln"> EGL_NO_DISPLAY</span><span class="pun">;</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">context   </span><span class="pun">=</span><span class="pln"> EGL_NO_CONTEXT</span><span class="pun">;</span><br /><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">surface   </span><span class="pun">=</span><span class="pln"> EGL_NO_SURFACE</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <h3>Creating a GL project using the NVIDIA framework</h3>
        <p>In the previous example, we described how to create an application from scratch, using the GL API; for Tegra-based devices, NVIDIA offers a framework that greatly simplifies the process (the framework will probably work on other Android devices too, but we haven't tested that). We will now implement a project that is very similar to the previous one, but we will employ this helper, to show its basic usage. The app will still change the background color based on the x and y position of the touches but, in addition to that, it will also overlay different text if the app is in focus or paused. In order to perform the latter, we will process the events generated by the UI. If the application is in focus, we will display "Active mode!" and we will track the position of the touches. When the return button is pressed once, or the "Recent app" button is pressed, or the bottom right corner is pressed, the app will be considered paused, or out-of-focus, and the text will be changed to:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="typ">Auto</span><span class="pun">-</span><span class="pln">pause</span><br /><span class="typ">Press</span><span class="pln"> back to quit</span><br /><span class="typ">Tap</span><span class="pln"> window to resume</span></pre>
        </blockquote>
        <p>When the app is paused, unless a new event is generated, an additional 4 more frames are going to be rendered, and after that, nothing else will happen.</p>
        <p>To begin, we first create a project (<code>SimpleNativeGL_NV</code>) the same way we did before. Follow the first steps described above up to the part where we modified the <code>AndroidManifest.xml</code> file. The only difference in the manifest file is the name we give to the library:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pun">[...]</span><br /><span class="pun">&lt;!--</span><span class="pln"> </span><span class="typ">Tell</span><span class="pln"> </span><span class="typ">NativeActivity</span><span class="pln"> the name of </span><span class="kwd">our</span><span class="pln"> </span><span class="pun">.</span><span class="pln">so </span><span class="pun">--&gt;</span><br /><span class="pun">&lt;</span><span class="pln">meta</span><span class="pun">-</span><span class="pln">data android</span><span class="pun">:</span><span class="pln">name</span><span class="pun">=</span><span class="str">"android.app.lib_name"</span><br /><span style="background-color: #ffffe0;"><span class="pln">	   android</span><span class="pun">:</span><span class="pln">value</span><span class="pun">=</span><span class="str">"SimpleNativeGL_NV"</span><span class="pln"> </span><span class="pun">/&gt;</span></span><br /><span class="pun">[...]</span></pre>
        </blockquote>
        <p>Now let's modify the <code>Android.mk</code> file in the <code>jni</code> folder of the project:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">LOCAL_PATH </span><span class="pun">:=</span><span class="pln"> $</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">my</span><span class="pun">-</span><span class="pln">dir</span><span class="pun">)</span><span class="pln">
</span><br /><span class="pln">include $</span><span class="pun">(</span><span class="pln">CLEAR_VARS</span><span class="pun">)</span><span class="pln">
</span><br /><span class="pln">LOCAL_MODULE    </span><span class="pun">:=</span><span class="pln"> </span><span class="typ">SimpleNativeGL_NV</span><br /><span class="pln">LOCAL_SRC_FILES </span><span class="pun">:=</span><span class="pln"> </span><span class="typ">SimpleNativeGL_NV</span><span class="pun">.</span><span class="pln">cpp </span><span class="typ">Engine</span><span class="pun">.</span><span class="pln">cpp</span><br /><span class="pln">LOCAL_LDLIBS    </span><span class="pun">:=</span><span class="pln"> </span><span class="pun">-</span><span class="pln">lc </span><span class="pun">-</span><span class="pln">lm </span><span class="pun">-</span><span class="pln">llog </span><span class="pun">-</span><span class="pln">landroid </span><span class="pun">-</span><span class="pln">ldl </span><span class="pun">-</span><span class="pln">lGLESv2 </span><span class="pun">-</span><span class="pln">lEGL</span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">LOCAL_STATIC_LIBRARIES </span><span class="pun">:=</span><span class="pln"> nv_and_util nv_egl_util nv_bitfont nv_math nv_glesutil nv_hhdds nv_log nv_shader nv_file nv_thread</span></span><br /><span class="pln">LOCAL_CFLAGS    </span><span class="pun">+=</span><span class="pln"> </span><span class="pun">-</span><span class="pln">std</span><span class="pun">=</span><span class="pln">gnu</span><span class="pun">++</span><span class="lit">0x</span><span class="pln">
</span><br /><span class="pln">include $</span><span class="pun">(</span><span class="pln">BUILD_SHARED_LIBRARY</span><span class="pun">)</span><span class="pln">
</span><br /><span style="background-color: #ffffe0;"><span class="com"># Add the folder with the NVIDIA helper, assuming we are at the nvsample_workspace</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="pln">add</span><span class="pun">-</span><span class="pln">path</span><span class="pun">,</span><span class="pln"> $</span><span class="pun">(</span><span class="pln">NVPACK_PATH</span><span class="pun">)/</span><span class="pln">TDK_Samples</span><span class="pun">/</span><span class="pln">tegra_android_native_samples_v10p14</span><span class="pun">/</span><span class="pln">libs</span><span class="pun">/</span><span class="pln">jni</span><span class="pun">)</span><span class="pln">
</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="com"># Import the modules from the NVIDIA helper</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_and_util</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_egl_util</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_bitfont</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_math</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_glesutil</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_hhdds</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_log</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_shader</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_file</span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">$</span><span class="pun">(</span><span class="pln">call </span><span class="kwd">import</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">,</span><span class="pln"> nv_thread</span><span class="pun">)</span></span></pre>
        </blockquote>
        <p>In addition to what we did in the example, we created in <a href="#Creating_project_from_scratch">Creating an OpenGL project from scratch</a>, here we are just linking against the NVIDIA libraries and importing the corresponding modules. Note that we are assuming again that you are working in the <code>$NVPACK_PATH/nvsample_workspace</code> workspace. If not, you will have to change the pointer to the NVIDIA helper folder. Because we will create a class called <code>Engine</code>, we added the corresponding source file to the list of <code>LOCAL_SRC_FILES</code>.</p>
        <p>Also, we need the fonts for the text we will overlay on the screen. We can get them from the <code>assets</code> folder of other projects in the workspace. For instance, in the Project Explorer, expand the folder <b>NativeBasic &gt; assets</b>.  Copy the two <code>*.abc</code> and <code>*.dds</code> files to the <code>asset</code>s folder of our project (in total, you should be copying 4 files).  Dragging-and-dropping with holding ALT within Eclipse Project Explorer is probably the easiest way to do this.</p>
        <p>Finally, to make sure that our application is fully optimized, we need the <code>Application.mk</code>. You can create it like we did in <a href="#Creating_project_from_scratch">Creating an OpenGL project from scratch</a>, or copy it directly from the other project. Because we want to use smart pointers of the new C++ 11 STL, we need to add a line to indicate we will be using the GNU STL implementation:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">APP_ABI </span><span class="pun">:=</span><span class="pln"> armeabi</span><span class="pun">-</span><span class="pln">v7a</span><br /><span style="background-color: #ffffe0;"><span class="pln">APP_STL </span><span class="pun">:=</span><span class="pln"> gnustl_static</span></span></pre>
        </blockquote>
        <table>
            <colgroup><col style="width: 35px;" />
            <col style="width: 660px;" />
            </colgroup><tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> The use of C++ 11 features, like <code>std::unique_ptr</code>, requires the compiler flag <code>-std=gnu++0x</code> and GCC version 4.6, which is the default compiler in NDK r8b. The compiler flags are given under <code>LOCAL_C_FLAGS</code> in the <code>Android.mk</code> file.</td>
                </tr>
            </tbody>
        </table>
        <p>We will now create a class expanding the Engine <code>struct</code> from the previous example, and we will move much of the code to it.</p>
        <p>In the <b>Project Explorer</b> pane, right-click on the <code>jni</code> folder and then <b>New &gt; Class</b>. In the <i>Class name</i> field, type <b>Engine</b> and then click <b>Finish</b>. Eclipse has now created for us both the header and source files for the class. Let's start from the header file:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#ifndef</span><span class="pln"> __ENGINE_H</span><br /><span class="com">#define</span><span class="pln"> __ENGINE_H
</span><br /><span class="com">// Includes for the NVIDIA helper libraries</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_and_util/nv_native_app_glue.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_egl_util/nv_egl_util.h&gt;</span><span class="pln">
</span><br /><span class="com">// Logging macros</span><br /><span class="com">#define</span><span class="pln"> APP_NAME </span><span class="str">"SimpleNativeGL_NV"</span><br /><span class="com">#define</span><span class="pln"> LOGD</span><span class="pun">(...)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">__android_log_print</span><span class="pun">(</span><span class="pln">ANDROID_LOG_DEBUG</span><span class="pun">,</span><span class="pln">APP_NAME</span><span class="pun">,</span><span class="pln"> __VA_ARGS__</span><span class="pun">))</span><br /><span class="com">#define</span><span class="pln"> LOGI</span><span class="pun">(...)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">__android_log_print</span><span class="pun">(</span><span class="pln">ANDROID_LOG_INFO</span><span class="pun">,</span><span class="pln"> APP_NAME</span><span class="pun">,</span><span class="pln"> __VA_ARGS__</span><span class="pun">))</span><br /><span class="com">#define</span><span class="pln"> LOGW</span><span class="pun">(...)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">__android_log_print</span><span class="pun">(</span><span class="pln">ANDROID_LOG_WARN</span><span class="pun">,</span><span class="pln"> APP_NAME</span><span class="pun">,</span><span class="pln"> __VA_ARGS__</span><span class="pun">))</span><span class="pln">
</span><br /><span class="com">#define</span><span class="pln"> FRAMES_TO_RENDER </span><span class="lit">4</span><span class="pln">
</span><br /><span class="com">/**</span><br /><span class="com"> *  This is the engine which implements the required callback functions,</span><br /><span class="com"> *  as well as a few utility functions.</span><br /><span class="com"> *  This implementation relies on the NVIDIA utilities.</span><br /><span class="com"> */</span><br /><span class="kwd">class</span><span class="pln"> </span><span class="typ">Engine</span><br /><span class="pun">{</span><br /><span class="kwd">public</span><span class="pun">:</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * The constructor saves a pointer to the engine and to the callback</span><br /><span class="com">     * functions in the Android app. It also initializes the nv_shader library.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="typ">Engine</span><span class="pun">(</span><span class="pln"> </span><span class="typ">NvEGLUtil</span><span class="pun">&amp;</span><span class="pln"> egl</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * The destructor mainly frees the allocated BitFonts.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="pun">~</span><span class="typ">Engine</span><span class="pun">();</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * The application can be active or paused. This function returns</span><br /><span class="com">     * false when the application is paused.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln"> isActiveMode</span><span class="pun">()</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> mActiveMode</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * Render the frame, after checking what the status of the Android app is.</span><br /><span class="com">     * Interactible should be true if the app is running, it is active, focused,</span><br /><span class="com">     * and has a valid surface.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> updateFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> interactible </span><span class="pun">);</span><span class="pln">
</span><br /><span class="kwd">protected</span><span class="pun">:</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     *  Wrapper to handle commands generated by the UI.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> handleCmdThunk</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> </span><span class="typ">int32_t</span><span class="pln"> cmd </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * Handle commands.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> handleCommand</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> cmd </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * Wrapper to handle input events generated by the UI.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">int32_t</span><span class="pln"> handleInputThunk</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * Handle inputs.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> handleInput</span><span class="pun">(</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/* Auxiliary functions */</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * Set mActiveMode; we use mActiveMode to keep track of whether the app is actually</span><br /><span class="com">     * running or paused. Examples of when the app is paused is when the user has pressed</span><br /><span class="com">     * the back button, the "Recent apps" button, or the time at the bottom right corner</span><br /><span class="com">     * of the screen.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> setActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> running </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * If the app's window had been resized returns true and forces the frame to be</span><br /><span class="com">     * rendered.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln"> checkWindowResized</span><span class="pun">();</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * Resets the number of frames that need to be rendered.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> requestForceRender</span><span class="pun">()</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// Even when no events are generated, we required that the system still renders</span><br /><span class="pln">	</span><span class="com">// FRAMES_TO_RENDER frames.</span><br /><span class="pln">	mForceRender </span><span class="pun">=</span><span class="pln"> FRAMES_TO_RENDER</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Check if we are done rendering frames.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln"> isForcedRenderPending</span><span class="pun">()</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// mForceRender is decremented every time a frame is rendered and</span><br /><span class="pln">	</span><span class="com">// reinitialized to FRAMES_TO_RENDER when a new event is generated</span><br /><span class="pln">	</span><span class="com">// by the UI</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> mForceRender </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * This is the actual method which renders the frame.</span><br /><span class="com">     * It returns false if either EGL was not ready to render or</span><br /><span class="com">     * the UI could not be initialized.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln"> renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> allocateIfNeeded </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * Initialize the UI</span><br /><span class="com">     * Returns true if the UI was initialized, false if the fonts could not be</span><br /><span class="com">     * initialized.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln"> initUI</span><span class="pun">();</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/**</span><br /><span class="com">     * If there is a pending window resize, perform it and return true.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln"> resizeIfNeeded</span><span class="pun">();</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">/* Variables */</span><br /><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">mApp</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Pointer to the Android app</span><br /><span class="pln">    </span><span class="typ">NvEGLUtil</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">mEgl</span><span class="pun">;</span><span class="pln">          </span><span class="com">// NvEGLUtil is the NVIDIA wrapper to EGL</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln">  mResizePending</span><span class="pun">;</span><span class="pln">     </span><span class="com">// Is there a window-resize pending?</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln">  mActiveMode</span><span class="pun">;</span><span class="pln">        </span><span class="com">// Is the app active or has it been paused?</span><br /><span class="pln">    </span><span class="kwd">bool</span><span class="pln">  mUiInitialized</span><span class="pun">;</span><span class="pln">     </span><span class="com">// Has the UI been initialized?</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">mUiText</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><span class="pln">         </span><span class="com">// We need this variable to get a pointer to the bftext objects</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln">   mTouchX</span><span class="pun">,</span><span class="pln"> mTouchY</span><span class="pun">;</span><span class="pln">   </span><span class="com">// Position of the touch event</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln">   mForceRender</span><span class="pun">;</span><span class="pln">       </span><span class="com">// This variable counts how many more frames we want</span><br /><span class="pln">   			      </span><span class="com">// to render in case no new requests are generated.</span><br /><span class="pun">};</span><span class="pln">
</span><br /><span class="com">#endif</span><span class="pln"> </span><span class="com">// __ENGINE_H</span></pre>
        </blockquote>
        <p>The comments and the naming of methods and variables should be self-explanatory. Open <code>Engine.cpp</code> so we can look at the implementation of the different methods, starting with the includes, constructor and destructor:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="str">"Engine.h"</span><span class="pln">
</span><br /><span class="com">// Includes for GL and EGL</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;EGL/egl.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;EGL/eglplatform.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;GLES2/gl2.h&gt;</span><span class="pln">
</span><br /><span class="com">// Includes for the NVIDIA helper libraries</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_and_util/nv_native_app_glue.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_egl_util/nv_egl_util.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_bitfont/nv_bitfont.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_shader/nv_shader.h&gt;</span><span class="pln">
</span><br /><span class="typ">Engine</span><span class="pun">::</span><span class="typ">Engine</span><span class="pun">(</span><span class="pln"> </span><span class="typ">NvEGLUtil</span><span class="pun">&amp;</span><span class="pln"> egl</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app </span><span class="pun">)</span><br /><span class="pln">		</span><span class="pun">:</span><span class="pln"> mEgl</span><span class="pun">(</span><span class="pln"> egl </span><span class="pun">),</span><span class="pln"> mApp</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">),</span><span class="pln"> mResizePending</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">),</span><span class="pln"> mActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">),</span><br /><span class="pln">		  mForceRender</span><span class="pun">(</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="pun">),</span><span class="pln"> mUiInitialized</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Save a pointer to the engine in the Android app</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">userData </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">;</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Save pointers to the implementation of the callback functions in the</span><br /><span class="pln">    </span><span class="com">// Android app</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">onAppCmd     </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&amp;</span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleCmdThunk</span><span class="pun">;</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">onInputEvent </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&amp;</span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleInputThunk</span><span class="pun">;</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Initialize the nv_shader library</span><br /><span class="pln">    nv_shader_init</span><span class="pun">(</span><span class="pln"> app</span><span class="pun">-&gt;</span><span class="pln">activity</span><span class="pun">-&gt;</span><span class="pln">assetManager </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Initialize the pointers to the bftext objects</span><br /><span class="pln">    mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span><br /><span class="pln">    mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><br /><span class="typ">Engine</span><span class="pun">::~</span><span class="typ">Engine</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Free the allocated BitFonts</span><br /><span class="pln">    </span><span class="typ">NVBFTextFree</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="typ">NVBFTextFree</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="typ">NVBFCleanup</span><span class="pun">();</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>In the code above, we used some of the NVIDIA libraries, such as an EGL utility. There is no comprehensive documentation of the libraries, but the code is commented pretty well.  Let's study what the EGL utility is made of.  Place the cursor on <code>NvEGLUtil</code> on the argument list of the Engine constructor and hit <b>F3</b> (or CTRL-click [CMD-click on Mac]).  This should take you to the definition of that object in <code>nv_egl_util.h</code>.  If the indexer worked correctly, you could now do the same thing to toggle between the declaration and definition of some member function, such as <code>swap()</code>.  You can always toggle between the header and implementation files with CTRL-TAB.  To get the indexer working for <code>nv_egl_util.h</code>, you'd need to go to <b>Project Properties &gt; C/C++ General &gt; Paths and Symbols &gt; Source Locations</b> and link the folder to where the <code>nv_egl_util.cpp</code> file is (it is in  <code>$NVPACK_PATH/TDK_Samples/tegra_android_native_samples_v10p14/libs/jni/nv_egl_util</code>).</p>
        <p>In any case, browsing these two files allows you to see how the <code>NvEGLUtil</code> class works.</p>
        <p>So far, it is pretty much like before, with the exception that we initialize the <code>nv_shader</code> library. Now we need to write the functions that handle commands from the UI. In the constructor we linked the <code>app-&gt;onAppCmd</code> callback to the method <code>Engine::handleCmdThunk()</code>; this method just gets a pointer to the engine object from the app and calls a method which actually handles the commands.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleCmdThunk</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> </span><span class="typ">int32_t</span><span class="pln"> cmd </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Get a pointer to the Engine we stored in the Android app</span><br /><span class="pln">    </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> app</span><span class="pun">-&gt;</span><span class="pln">userData</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> engine </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">handleCommand</span><span class="pun">(</span><span class="pln"> cmd </span><span class="pun">);</span><span class="pln"> </span><span class="pun">}</span><br /><span class="pun">}</span><br /><br /><span class="kwd">void</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleCommand</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> cmd </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">switch</span><span class="pun">(</span><span class="pln"> cmd </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_INIT_WINDOW</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// The window is being shown, get it ready.</span><br /><span class="pln">	</span><span class="com">// Note that on ICS, the EGL size will often be correct for the new size here,</span><br /><span class="pln">	</span><span class="com">// but on HC it will not be.  We need to defer checking the new res until the</span><br /><span class="pln">	</span><span class="com">// first render with the new surface! Fall through to the window resize case.</span><br /><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_WINDOW_RESIZED</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// A command to resize the window was issued, we need to</span><br /><span class="pln">	</span><span class="com">// redraw it with its new size.</span><br /><span class="pln">	mEgl</span><span class="pun">.</span><span class="pln">setWindow</span><span class="pun">(</span><span class="pln"> mApp</span><span class="pun">-&gt;</span><span class="pln">window </span><span class="pun">);</span><br /><span class="pln">	requestForceRender</span><span class="pun">();</span><br /><span class="pln">	</span><span class="kwd">break</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_TERM_WINDOW</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// The window is being hidden or closed, clean it up.</span><br /><span class="pln">	mEgl</span><span class="pun">.</span><span class="pln">setWindow</span><span class="pun">(</span><span class="pln"> NULL </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">break</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_GAINED_FOCUS</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// The app window gained focus we need to start rendering it.</span><br /><span class="pln">	requestForceRender</span><span class="pun">();</span><br /><span class="pln">	</span><span class="kwd">break</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_LOST_FOCUS</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// The app window lost focus so we need to pause it.</span><br /><span class="pln">	</span><span class="com">// Fall through to the command pause case.</span><br /><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_PAUSE</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// Move out of active mode if we are in it. But if we are</span><br /><span class="pln">	</span><span class="com">// in another dialog mode, leave it as-is.</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mActiveMode </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    setActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">	</span><span class="com">// Note that we still want to render in background.</span><br /><span class="pln">	requestForceRender</span><span class="pun">();</span><br /><span class="pln">	</span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
</span><br /><span class="pln">    </span><span class="kwd">case</span><span class="pln"> APP_CMD_CONFIG_CHANGED</span><span class="pun">:</span><br /><span class="pln">	</span><span class="com">// ICS does not appear to require this, but on GB phones,</span><br /><span class="pln">	</span><span class="com">// not having this causes rotation changes to be delayed or</span><br /><span class="pln">	</span><span class="com">// ignored when we're in a non-rendering mode like autopause.</span><br /><span class="pln">	</span><span class="com">// The forced renders appear to allow GB to process the rotation.</span><br /><span class="pln">	requestForceRender</span><span class="pun">();</span><br /><span class="pln">	</span><span class="kwd">break</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Similarly, in the constructor we also linked the <code>app-&gt;onInputEvent</code> callback to the method <code>Engine::handleInputThunk()</code>. Finally the method <code>Engine::handleInput()</code> analyzes the event and either updates the touch positions or, if the event was a "back button" event, handles pausing the app or closing it.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">/**</span><br /><span class="com"> * Process the next input event.</span><br /><span class="com"> */</span><br /><span class="typ">int32_t</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleInputThunk</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="kwd">event</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Get a pointer to the Engine we stored in the Android app</span><br /><span class="pln">    </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln">engine </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> app</span><span class="pun">-&gt;</span><span class="pln">userData</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">engine </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">handleInput</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pun">}</span><br /><span class="kwd">int</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleInput</span><span class="pun">(</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="kwd">event</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// We only handle motion events (touchscreen) and key (button/key) events</span><br /><span class="pln">    </span><span class="typ">int32_t</span><span class="pln"> eventType </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AInputEvent_getType</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> eventType </span><span class="pun">==</span><span class="pln"> AINPUT_EVENT_TYPE_MOTION </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">int32_t</span><span class="pln"> action </span><span class="pun">=</span><span class="pln"> AMOTION_EVENT_ACTION_MASK </span><span class="pun">&amp;</span><span class="pln"> </span><span class="typ">AMotionEvent_getAction</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">	</span><span class="com">// A tap on the screen takes us out of autopause into active mode if</span><br /><span class="pln">	</span><span class="com">// we were paused.  No other touch processing is done.</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> action </span><span class="pun">==</span><span class="pln"> AMOTION_EVENT_ACTION_DOWN </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    setActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">	mTouchX </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AMotionEvent_getX</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	mTouchY </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AMotionEvent_getY</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> eventType </span><span class="pun">==</span><span class="pln"> AINPUT_EVENT_TYPE_KEY </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">int32_t</span><span class="pln"> code </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AKeyEvent_getKeyCode</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="com">// If we are in active mode, we eat the back button and move into</span><br /><span class="pln">	</span><span class="com">// pause mode.  If we are already in pause mode, we allow the back</span><br /><span class="pln">	</span><span class="com">// button to be handled by the OS, which means we'll be shut down.</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> code </span><span class="pun">==</span><span class="pln"> AKEYCODE_BACK </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> mActiveMode </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    setActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Now let's write the methods that perform the actual rendering of the frame. We will have an auxiliary method, <code>Engine::updateFrame()</code> that looks at the status of our application and decides whether we need to render or not.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">updateFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> interactible </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> interactible </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// Each frame, we check to see if the window has resized.  While the</span><br /><span class="pln">	</span><span class="com">// various events we get _should_ cover this, in practice, it appears</span><br /><span class="pln">	</span><span class="com">// that the safest move across all platforms and OSes is to check at</span><br /><span class="pln">	</span><span class="com">// the top of each frame.</span><br /><span class="pln">	checkWindowResized</span><span class="pun">();</span><span class="pln">
</span><br /><span class="pln">	</span><span class="com">// Time stands still when we're auto-paused, and we don't</span><br /><span class="pln">	</span><span class="com">// automatically render.</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mActiveMode </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    </span><span class="com">// This will try to set up EGL if it isn't set up.</span><br /><span class="pln">	    </span><span class="com">// When we first set up EGL completely, we also load our GLES resources.</span><br /><span class="pln">	    </span><span class="com">// If these are already set up or we succeed at setting them all up now, then</span><br /><span class="pln">	    </span><span class="com">// we go ahead and render.</span><br /><span class="pln">	    renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">	</span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> isForcedRenderPending</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="com">// forced rendering when needed for UI, etc.</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    </span><span class="com">// This forces to change the text when paused.</span><br /><span class="pln">	    renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">else</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// Even if we are not interactive, we may be visible, so we</span><br /><span class="pln">	</span><span class="com">// HAVE to do any forced renderings if we can.  We must also</span><br /><span class="pln">	</span><span class="com">// check for resize, since that may have been the point of the</span><br /><span class="pln">	</span><span class="com">// forced render request in the first place!</span><br /><span class="pln">	</span><span class="com">// Basically it still renders even if the application is not in focus.</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> isForcedRenderPending</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">isReadyToRender</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    checkWindowResized</span><span class="pun">();</span><br /><span class="pln">	    renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>The actual method that performs rendering has to first make sure that everything is ready (EGL ready and UI initialized), then it clears the buffer to the color selected with the touch position and renders the text:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">bool</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> allocateIfNeeded </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Check that EGL is ready to render. If allocateIfNeeded</span><br /><span class="pln">    </span><span class="com">// try to also allocate the rendering surface and bind it</span><br /><span class="pln">    </span><span class="com">// to the context.</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">mEgl</span><span class="pun">.</span><span class="pln">isReadyToRender</span><span class="pun">(</span><span class="pln"> allocateIfNeeded </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="com">// Make sure that the UI is initialized</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">initUI</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	LOGW</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Could not initialize UI - assets may be missing!"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">ANativeActivity_finish</span><span class="pun">(</span><span class="pln"> mApp</span><span class="pun">-&gt;</span><span class="pln">activity </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    resizeIfNeeded</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="com">// Set up viewport</span><br /><span class="pln">    glViewport</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLint</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLint</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><br /><span class="pln">	        </span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLsizei</span><span class="pln"> </span><span class="pun">)(</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getWidth</span><span class="pun">()</span><span class="pln"> </span><span class="pun">),</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLsizei</span><span class="pln"> </span><span class="pun">)(</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getHeight</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Set the clear color...</span><br /><span class="pln">    glClearColor</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> mTouchX </span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getWidth</span><span class="pun">()</span><span class="pln"> </span><span class="pun">),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><br /><span class="pln">	          </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> mTouchY </span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getHeight</span><span class="pun">()</span><span class="pln"> </span><span class="pun">),</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="com">// ...and clear.</span><br /><span class="pln">    glClear</span><span class="pun">(</span><span class="pln"> GL_COLOR_BUFFER_BIT </span><span class="pun">|</span><span class="pln"> GL_DEPTH_BUFFER_BIT </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">/* Do some rendering here */</span><br /><span class="pln">    </span><span class="com">// ...</span><br /><br /><span class="pln">    </span><span class="com">// Render the bitfont text overlaid here</span><br /><span class="pln">    </span><span class="typ">NVBFTextRenderPrep</span><span class="pun">();</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">uiText </span><span class="pun">=</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="pln">mActiveMode </span><span class="pun">?</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">];</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> uiText </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">NVBFTextRender</span><span class="pun">(</span><span class="pln"> uiText </span><span class="pun">);</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="com">// Done rendering overlaid text.</span><br /><span class="pln">    </span><span class="typ">NVBFTextRenderDone</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mForceRender </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> mForceRender</span><span class="pun">--;</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="com">// Swap the buffers, which indicates we're done with rendering this frame</span><br /><span class="pln">    mEgl</span><span class="pun">.</span><span class="pln">swap</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>The magic for rendering with OpenGL ES now happens inside <code>NVBFTextRender()</code> function. If you browse to its declaration and definition as explained above, you can see that  it is here that the maths for placing the text is calculated, the texture map containing the text characters is bound, and so forth.  We will go deeper into all that in the next tutorial.</p>
        <p>Let's now look at the code for the method <code>Engine::initUI()</code>. It's pretty simple, actually. We just initialize the bitfonts and set the properties for the text that we need to overlay. Note that EGL was initialized at the Engine construction, as the <code>NvEGLUtil &amp;mEgl</code> was</p>
        <p>constructed. It's also here that <code>NVBFInitialize()</code> is called, it sets up the vertex and fragment  shaders that are used to render the text strings with GL.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">bool</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">initUI</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// The UI might have been initialized already</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiInitialized </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Initialize the NVIDIA bitfonts</span><br /><span class="pln">    </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> NUM_FONTS </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">NvBool</span><span class="pln"> fontsSplit</span><span class="pun">[</span><span class="pln">NUM_FONTS</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">};</span><span class="pln"> </span><span class="com">// all are split</span><br /><span class="pln">    </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">fontFiles</span><span class="pun">[</span><span class="pln">NUM_FONTS</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="str">"courier+lucida_256.dds"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"utahcond+bold_1024.dds"</span><span class="pln"> </span><span class="pun">};</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="typ">NVBFInitialize</span><span class="pun">(</span><span class="pln"> NUM_FONTS</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">**)</span><span class="pln"> fontFiles</span><span class="pun">,</span><span class="pln"> fontsSplit</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	LOGW</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Could not initialize NvBitFont"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Allocate the text for the paused mode and set its properties</span><br /><span class="pln">    mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">NVBFTextAlloc</span><span class="pun">();</span><br /><span class="pln">    </span><span class="typ">NVBFTextSetFont</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// should look up by font file name</span><br /><span class="pln">    </span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> </span><span class="lit">32</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="typ">NVBFTextSetColor</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> NV_PC_PREDEF_WHITE </span><span class="pun">);</span><br /><span class="pln">    </span><span class="typ">NVBFTextSetString</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> NVBF_COLORSTR_RED NVBF_STYLESTR_BOLD </span><span class="str">"Auto-pause:\n"</span><span class="pln"> NVBF_</span><br /><span class="pln">    TYLESTR_NORMAL</span><br /><span class="pln">    NVBF_COLORSTR_BLUE </span><span class="str">"Press back to quit\nTap window to resume"</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Allocate the text for the active mode and set its properties</span><br /><span class="pln">    mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">NVBFTextAlloc</span><span class="pun">();</span><br /><span class="pln">    </span><span class="typ">NVBFTextSetFont</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// should look up by font file name</span><br /><span class="pln">    </span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">32</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="typ">NVBFTextSetColor</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> NV_PC_PREDEF_WHITE </span><span class="pun">);</span><br /><span class="pln">    </span><span class="typ">NVBFTextSetString</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> NVBF_COLORSTR_GREEN </span><span class="str">"Active mode!"</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    mUiInitialized </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
</span><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p><code>Engine::resizeIfNeeded()</code> basically just sets the height and width of the window and changes the text size accordingly:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">bool</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">resizeIfNeeded</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Do we need to resize?</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">mResizePending </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Get the target height and width</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> w </span><span class="pun">=</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getWidth</span><span class="pun">();</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> h </span><span class="pun">=</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getHeight</span><span class="pun">();</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> textHeight </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> w </span><span class="pun">&gt;</span><span class="pln"> h </span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> h </span><span class="pun">/</span><span class="pln"> </span><span class="lit">16</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> w </span><span class="pun">/</span><span class="pln"> </span><span class="lit">16</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Change the resolution to the correct width and height</span><br /><span class="pln">    </span><span class="typ">NVBFSetScreenRes</span><span class="pun">(</span><span class="pln"> w</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">);</span><span class="pln">
</span><br /><span class="pln">    </span><span class="com">// Also update the size of the characters</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> textHeight </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorAlign</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> NVBF_ALIGN_CENTER</span><span class="pun">,</span><span class="pln"> NVBF_ALIGN_BOTTOM </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorPos</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> w </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> textHeight </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorAlign</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> NVBF_ALIGN_CENTER</span><span class="pun">,</span><span class="pln"> NVBF_ALIGN_CENTER </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorPos</span><span class="pun">(</span><span class="pln"> mUiText</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> w </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><span class="pln">
</span><br /><span class="pln">    mResizePending </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
</span><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>And finally, a couple of auxiliary functions:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">setActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> running </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mActiveMode </span><span class="pun">!=</span><span class="pln"> running </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	requestForceRender</span><span class="pun">();</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    mActiveMode </span><span class="pun">=</span><span class="pln"> running</span><span class="pun">;</span><br /><span class="pun">}</span><span class="pln">
</span><br /><span class="kwd">bool</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">checkWindowResized</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">checkWindowResized</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	mResizePending </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pln">	requestForceRender</span><span class="pun">();</span><br /><span class="pln">	LOGI</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Window size change %dx%d"</span><span class="pun">,</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getWidth</span><span class="pun">(),</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getHeight</span><span class="pun">()</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>We are done with implementing the engine, we now only need to write the main function of our application. Fill <code>SimpleNativeGL_NV.cpp</code> in the <code>jni</code> folder with this code:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">// EGL and GL includes</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;EGL/egl.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;EGL/eglplatform.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;GLES2/gl2.h&gt;</span><br /><br /><span class="com">// NVIDIA helper includes</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_and_util/nv_native_app_glue.h&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_egl_util/nv_egl_util.h&gt;</span><br /><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;memory&gt;</span><br /><br /><span class="com">#include</span><span class="pln"> </span><span class="str">"Engine.h"</span><br /><br /><span class="com">/**</span><br /><span class="com"> * This is the main entry point of a native application that is using</span><br /><span class="com"> * android_native_app_glue.  It runs in its own thread, with its own</span><br /><span class="com"> * event loop for receiving input events and doing other things.</span><br /><span class="com"> */</span><br /><span class="kwd">void</span><span class="pln"> android_main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Make sure glue isn't stripped.</span><br /><span class="pln">    app_dummy</span><span class="pun">();</span><br /><br /><span class="pln">    std</span><span class="pun">::</span><span class="pln">unique_ptr</span><span class="pun">&lt;</span><span class="typ">NvEGLUtil</span><span class="pun">&gt;</span><span class="pln"> egl</span><span class="pun">(</span><span class="pln"> </span><span class="typ">NvEGLUtil</span><span class="pun">::</span><span class="pln">create</span><span class="pun">()</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">egl </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// If we have a basic EGL failure, we need to exit immediately; nothing else we can do</span><br /><span class="pln">	nv_app_force_quit_no_cleanup</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span class="pln">    std</span><span class="pun">::</span><span class="pln">unique_ptr</span><span class="pun">&lt;</span><span class="typ">Engine</span><span class="pun">&gt;</span><span class="pln"> engine</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">(</span><span class="pln"> </span><span class="pun">*</span><span class="pln">egl</span><span class="pun">,</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Loop waiting for stuff to do.</span><br /><span class="pln">    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> nv_app_status_running</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// Read all pending events.</span><br /><span class="pln">	</span><span class="kwd">int</span><span class="pln"> ident</span><span class="pun">;</span><br /><span class="pln">	</span><span class="kwd">int</span><span class="pln"> events</span><span class="pun">;</span><br /><span class="pln">	</span><span class="kwd">struct</span><span class="pln"> android_poll_source </span><span class="pun">*</span><span class="pln">source</span><span class="pun">;</span><br /><br /><span class="pln">	</span><span class="com">// If not rendering, we will block forever waiting for events.</span><br /><span class="pln">	</span><span class="com">// If animating, we loop until all events are read, then continue</span><br /><span class="pln">	</span><span class="com">// to draw the next frame of animation.</span><br /><span class="pln">	</span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> ident </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ALooper_pollAll</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> nv_app_status_focused</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">isActiveMode</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">250</span><span class="pln"> </span><span class="pun">),</span><br /><span class="pln">				NULL</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">events</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">**</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">source </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">				</span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    </span><span class="com">// If we timed out, then there are no pending messages.</span><br /><span class="pln">	    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> ident </span><span class="pun">==</span><span class="pln"> ALOOPER_POLL_TIMEOUT </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">break</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">	    </span><span class="com">// Process this event.</span><br /><span class="pln">	    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> source </span><span class="pun">!=</span><span class="pln"> NULL </span><span class="pun">)</span><span class="pln">                </span><span class="pun">{</span><span class="pln"> source</span><span class="pun">-&gt;</span><span class="pln">process</span><span class="pun">(</span><span class="pln"> app</span><span class="pun">,</span><span class="pln"> source </span><span class="pun">);</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">	    </span><span class="com">// Check if we are exiting.  If so, dump out.</span><br /><span class="pln">	    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">nv_app_status_running</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">break</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><br /><span class="pln">	</span><span class="pun">}</span><br /><br /><span class="pln">	</span><span class="com">// Update the frame, which optionally updates time and animations</span><br /><span class="pln">	</span><span class="com">// and renders.</span><br /><span class="pln">	engine</span><span class="pun">-&gt;</span><span class="pln">updateFrame</span><span class="pun">(</span><span class="pln"> nv_app_status_interactable</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Let's try to compile the application: right-click on the project folder and select <b>Build project</b>. Even if you followed this tutorial to the letter, you will get errors::</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pun">../</span><span class="pln">jni</span><span class="pun">/</span><span class="typ">SimpleNativeGL_NV</span><span class="pun">.</span><span class="pln">cpp</span><span class="pun">:</span><span class="lit">32</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> reference to </span><span class="str">`Engine::Engine(NvEGLUtil&amp;, android_app*)'</span><br /><span class="str">../jni/SimpleNativeGL_NV.cpp:64: undefined reference to `</span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">updateFrame</span><span class="pun">(</span><span class="kwd">bool</span><span class="pun">)</span><span class="str">'</span><br /><span class="str">../obj/local/armeabi-v7a/objs/SimpleNativeGL_NV/SimpleNativeGL_NV.o: In function `std::default_delete&lt;Engine&gt;::operator()(Engine*) const'</span><span class="pun">:</span><br /><span class="pun">../</span><span class="pln">android</span><span class="pun">-</span><span class="pln">ndk</span><span class="pun">-</span><span class="pln">r8b</span><span class="pun">/</span><span class="pln">sources</span><span class="pun">/</span><span class="pln">cxx</span><span class="pun">-</span><span class="pln">stl</span><span class="pun">/</span><span class="pln">gnu</span><span class="pun">-</span><span class="pln">libstdc</span><span class="pun">++</span><span class="str">/4.6/</span><span class="pln">include</span><span class="pun">/</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">unique_ptr</span><span class="pun">.</span><span class="pln">h</span><span class="pun">:</span><span class="lit">63</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> reference to </span><span class="str">`Engine::~Engine()'</span></pre>
        </blockquote>
        <p>But we did include all the necessary includes. And, in fact, if you <b>CTRL + click</b> on the name of the class in the <code>SimpleNativeGL_NV.cpp</code> file, Eclipse will take you to the <code>Engine.h</code> file. The problem is that we didn't include all the source files in the <code>Android.mk</code> file, so the compiler does not know that <code>Engine.cpp</code> is part of the project. However, since we don't want to have to modify that file every time, we add a new class, and we will use wildcards instead. We will replace the line:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">LOCAL_SRC_FILES </span><span class="pun">:=</span><span class="pln"> </span><span class="typ">SimpleNativeGL_NV</span><span class="pun">.</span><span class="pln">cpp </span><span class="typ">Engine</span><span class="pun">.</span><span class="pln">cpp</span></pre>
        </blockquote>
        <p>with the following:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">MY_PREFIX           </span><span class="pun">:=</span><span class="pln"> $</span><span class="pun">(</span><span class="pln">LOCAL_PATH</span><span class="pun">)/</span><br /><span class="pln">MY_SOURCES          </span><span class="pun">:=</span><span class="pln"> $</span><span class="pun">(</span><span class="pln">wildcard $</span><span class="pun">(</span><span class="pln">LOCAL_PATH</span><span class="pun">)</span><span class="com">/*.cpp)</span><br /><span class="com">MY_SOURCES          += $(wildcard $(LOCAL_PATH)/*.c)</span><br /><span class="com">LOCAL_SRC_FILES     += $(MY_SOURCES:$(MY_PREFIX)%=%)</span></pre>
        </blockquote>
        <p>Now let's run the application. Right-click on the project folder and select <b>Run as &gt; Android Application</b>. You should see the text "Active!" on the screen. Drag your finger around. Notice that if you click on the back button, for instance, the text will change to reflect that the application has been paused.</p>
        <p>This concludes our second GL tutorial.</p>
        <h3>Using shaders in your GL project</h3>
        <p>In this third and last GL tutorial,  we will expand the previous tutorial to explore the use of shaders. We will create an application which will load an image as a texture; depending on which button the user presses, we will show either the texture loaded or a filtered version of it. For simplicity we will implement a <a href="http://en.wikipedia.org/wiki/Sobel_filter">Sobel filter</a> along the vertical direction of the image. In addition, we also display the time spent in active mode by the app; this counter will stop when the application is paused. To get an idea, these are screenshots for the two states:</p>
        <p><a class="MCPopupThumbnailLink" href="images/gl_plainshader.png"><img class="MCPopupThumbnail img" data-mc-width="1366" data-mc-height="768" src="images/gl_plainshader_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-height: auto;mc-thumbnail-max-width: 700px;" tabindex="" /></a>
        </p>
        <p><a class="MCPopupThumbnailLink" href="images/gl_filtershader.png"><img class="MCPopupThumbnail img" data-mc-width="1366" data-mc-height="768" src="images/gl_filtershader_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-height: auto;mc-thumbnail-max-width: 700px;" tabindex="" /></a>
        </p>
        <p>We assume that you have the previous project in your workspace already, and we will build on it. If you don't have it, please import the <code>SimpleNativeGL_NV</code> project from the <code>tutorials</code> folder.</p>
        <p>First we will create the background texture from a regular image. We will need to create a <code>DDS</code> file.</p>
        <table>
            <colgroup><col style="width: 35px;" />
            <col style="width: 660px;" />
            </colgroup><tbody>
                <tr>
                    <td style="background-color: #ffffe0;vertical-align: middle;text-align: center;">
                        <img src="images/notebox.png" />
                    </td>
                    <td style="background-color: #ffffe0;vertical-align: middle;"><b>Note:</b> DDS (<a href="http://en.wikipedia.org/wiki/DirectDraw_Surface">DirectDraw Surface</a>) is a compressed picture format whose main advantage over standard <code>jpeg</code> or <code>png</code> formats is that it is not decompressed before it's loaded in memory, and is then decompressed in hardware at access time. Standard image files are usually decompressed (in software) before they are loaded into memory, and use more space.</td>
                </tr>
            </tbody>
        </table>
        <p>To manipulate DDS files, you can use the tools of your choice. GIMP plus the DDS plugin is one option. NVIDIA also provides <a href="https://developer.nvidia.com/legacy-texture-tools">a set of basic tools</a> for Windows, we will start there. You can download the DDS utilities, and convert <a href="http://us.download.nvidia.com/downloads/cool_stuff/wallpapers/NVIDIA_Claw/Claw3_1280x800.jpg">this image</a> typing in a shell::</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">nvdxt </span><span class="pun">-</span><span class="pln">file </span><span class="typ">Claw3_1280x800</span><span class="pun">.</span><span class="pln">jpg </span><span class="pun">-</span><span class="pln">output nvidia_green</span><span class="pun">.</span><span class="pln">dds</span></pre>
        </blockquote>
        <p>(Note that the input image does not necessarily need to be \*.jpeg, but there are some constraints as far as the width and height of the input image go.)</p>
        <p>On Ubuntu, you can install the <code>gimp-dds</code> package, open <code>Claw3_1280x800.jpg</code> using GIMP and save it as <code>nvidia_green.dds</code> selecting DXT5 compression. Now copy <code>nvidia_green.dds</code> in your project's <code>assets</code> folder.</p>
        <p>Next we want to create the shaders, one to render the original texture and one to render the Sobel image. We need to create 4 different files in the <code>assets</code> folder (from the Project Explorer pane, right-click on the <code>assets</code> folder, then <b>New &gt; File</b>):</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">plain</span><span class="pun">.</span><span class="pln">vert</span><br /><span class="pln">plain</span><span class="pun">.</span><span class="pln">frag</span><br /><span class="pln">filter</span><span class="pun">.</span><span class="pln">vert</span><br /><span class="pln">filter</span><span class="pun">.</span><span class="pln">frag</span></pre>
        </blockquote>
        <p>We will draw a 2D rectangle with vertices (0,0), (1,0), (1,1) and (0,1) to render the texture on screen. The texture coordinates for each vertex are the same as their position, drawing the entire texture into the 2D rectangle. The vertex shader will map each vertex of the rectangle to clip coordinates in the range [-1,1] on each axis. The vertex shaders are going to be identical for both the filtered and the original images. Open <code>plain.vert</code> and fill it  with this code (and do the same for <code>filter.vert</code>):</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">attribute vec2 aPos</span><span class="pun">;</span><span class="pln">      </span><span class="com">// Position, in screen coordinates, passed as an attribute.</span><br /><span class="pln">attribute vec2 aUV</span><span class="pun">;</span><span class="pln">       </span><span class="com">// Position, in texture coordinates, passed as an attribute.</span><br /><span class="pln">varying   vec2 vTexCoord</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Texture coordinates to be passed as varying to</span><br /><span class="pln">		          </span><span class="com">// the fragment shader.</span><br /><span class="pln">uniform   vec2 uViewMin</span><span class="pun">;</span><span class="pln">  </span><span class="com">// Bottom left corner of the rectangle in clip coordinates</span><br /><span class="pln">uniform   vec2 uViewDim</span><span class="pun">;</span><span class="pln">  </span><span class="com">// x,y dimensions of the rectangle in clip coordinates</span><br /><br /><span class="com">/*</span><br /><span class="com"> * This vertex shader maps a 2D vertex to clip coordinates coordinates in the</span><br /><span class="com"> * range specified by uViewMin and uViewDim</span><br /><span class="com"> */</span><br /><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Convert to clip coordinates.</span><br /><span class="pln">    gl_Position </span><span class="pun">=</span><span class="pln"> vec4</span><span class="pun">(</span><span class="pln"> uViewMin</span><span class="pun">.</span><span class="pln">x </span><span class="pun">+</span><span class="pln"> aPos</span><span class="pun">.</span><span class="pln">x </span><span class="pun">*</span><span class="pln"> uViewDim</span><span class="pun">.</span><span class="pln">x</span><span class="pun">,</span><span class="pln"> uViewMin</span><span class="pun">.</span><span class="pln">y </span><span class="pun">+</span><span class="pln"> aPos</span><span class="pun">.</span><span class="pln">y </span><span class="pun">*</span><span class="pln"> uViewDim</span><span class="pun">.</span><span class="pln">y</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.0</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Pass the texture coordinates untouched.</span><br /><span class="pln">    vTexCoord </span><span class="pun">=</span><span class="pln"> aUV</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Essentially, this vertex shader maps the 2D rectangle to a region of the clip coordinate space.</p>
        <p>The fragment shader to render the original image is very simple too, as it only sets <code>gl_FragColor</code> to the value of the texture at the corresponding position (copy this in the <code>plain.frag</code> file):</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">precision lowp </span><span class="kwd">float</span><span class="pun">;</span><span class="pln">         </span><span class="com">// Use low precision for floats.</span><br /><br /><span class="pln">uniform sampler2D  uTex</span><span class="pun">;</span><span class="pln">      </span><span class="com">// The texture sampler.</span><br /><span class="pln">varying vec2       vTexCoord</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Texture coordinates.</span><br /><br /><span class="com">/*</span><br /><span class="com"> * This shader just shows the texture on the screen, without performing any</span><br /><span class="com"> * processing to it. Therefore, just set the color of the fragment to the</span><br /><span class="com"> * same as in the texture.</span><br /><span class="com"> */</span><br /><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Look up the texture and set the fragment color</span><br /><span class="pln">    </span><span class="com">// to the same value of the texture at the same location.</span><br /><span class="pln">    gl_FragColor </span><span class="pun">=</span><span class="pln"> texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">);</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>The next step is to implement the fragment shader that performs Sobel filtering. Open the <code>filter.frag</code> fragment shader and paste in the following code:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">precision mediump </span><span class="kwd">float</span><span class="pun">;</span><span class="pln">      </span><span class="com">// Use medium precision for floats.</span><br /><br /><span class="pln">uniform vec2      uD</span><span class="pun">;</span><span class="pln">         </span><span class="com">// Step size corresponding to one pixel in the texture.</span><br /><span class="pln">uniform sampler2D uTex</span><span class="pun">;</span><span class="pln">       </span><span class="com">// The texture sampler.</span><br /><span class="pln">varying vec2      vTexCoord</span><span class="pun">;</span><span class="pln">  </span><span class="com">// Texture coordinates.</span><br /><br /><span class="com">/*</span><br /><span class="com"> * This very simple fragment performs a y gradient (using Sobel filter)</span><br /><span class="com"> * to the green channel of the texture.</span><br /><span class="com"> */</span><br /><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// The origin is in the bottom-left corner, with the y axis</span><br /><span class="pln">    </span><span class="com">// pointing up, and the texture coordinates go from 0 to 1.</span><br /><br /><span class="pln">    </span><span class="com">// Let's accumulate fragment color using a vertical Sobel filter,</span><br /><span class="pln">    </span><span class="com">// with the following weights:</span><br /><span class="pln">    </span><span class="com">//</span><br /><span class="pln">    </span><span class="com">//   -1   -2   -1</span><br /><span class="pln">    </span><span class="com">//    0    0    0</span><br /><span class="pln">    </span><span class="com">//    1    2    1</span><br /><span class="pln">    </span><span class="com">//</span><br /><span class="pln">    </span><span class="com">// We get the colors by doing lookups in the texture map with</span><br /><span class="pln">    </span><span class="com">// correct offsets.</span><br /><br /><span class="pln">    gl_FragColor  </span><span class="pun">=</span><span class="pln">       texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln"> </span><span class="pun">-</span><span class="pln">uD</span><span class="pun">.</span><span class="pln">x</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="pln">uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    gl_FragColor </span><span class="pun">+=</span><span class="pln"> </span><span class="lit">2</span><span class="pln">   </span><span class="pun">*</span><span class="pln"> texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln">   </span><span class="lit">0.0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="pln">uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    gl_FragColor </span><span class="pun">+=</span><span class="pln">       texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln">  uD</span><span class="pun">.</span><span class="pln">x</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="pln">uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    gl_FragColor </span><span class="pun">-=</span><span class="pln">       texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln"> </span><span class="pun">-</span><span class="pln">uD</span><span class="pun">.</span><span class="pln">x</span><span class="pun">,</span><span class="pln">  uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    gl_FragColor </span><span class="pun">-=</span><span class="pln"> </span><span class="lit">2</span><span class="pln">   </span><span class="pun">*</span><span class="pln"> texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln">   </span><span class="lit">0.0</span><span class="pun">,</span><span class="pln">  uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    gl_FragColor </span><span class="pun">-=</span><span class="pln">       texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln">  uD</span><span class="pun">.</span><span class="pln">x</span><span class="pun">,</span><span class="pln">  uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// ... and compute the color of this fragment (we set alpha to 1).</span><br /><span class="pln">    gl_FragColor</span><span class="pun">.</span><span class="pln">r </span><span class="pun">=</span><span class="pln"> gl_FragColor</span><span class="pun">.</span><span class="pln">b </span><span class="pun">=</span><span class="pln"> gl_FragColor</span><span class="pun">.</span><span class="pln">g</span><span class="pun">;</span><br /><span class="pln">    gl_FragColor</span><span class="pun">.</span><span class="pln">a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1.0</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>We are done with the shaders implementation. Now we will add a couple of classes to our project. Right-click on the <code>jni</code> folder under your project in the Project Explorer pane and select <b>New &gt; Class</b>. Call it <code>RectShader</code> (unselect the <i>Namespace</i> checkbox if necessary).</p>
        <p>We will use this class to load and compile the shaders. In fact, we will create one object of this class per shader. An instance of the <code>RectShader</code> class will compute the uniforms for the vertex shader based on the current screen size and the choice of stretching or preserving the image aspect ratio. When stretching is selected the 2D rectangle is mapped to the entire clip coordinates range. If we choose to keep the aspect ratio, the corresponding origin and size of the rectangle in clip space coordinates is computed and assigned to the <code>uViewMin</code> and <code>uViewDim</code> uniforms. The header file of our class will be:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#ifndef</span><span class="pln"> RECT_SHADER_H_</span><br /><span class="com">#define</span><span class="pln"> RECT_SHADER_H_</span><br /><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;GLES2/gl2.h&gt;</span><br /><br /><span class="kwd">class</span><span class="pln"> </span><span class="typ">RectShader</span><br /><span class="pun">{</span><br /><span class="kwd">public</span><span class="pun">:</span><br /><br /><span class="pln">    </span><span class="kwd">enum</span><span class="pln"> </span><span class="typ">ImageRowStorage</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// First byte in memory is top row</span><br /><span class="pln">	STORAGE_TOP_FIRST   </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><br /><br /><span class="pln">	</span><span class="com">// First byte in memory is bottom row</span><br /><span class="pln">	STORAGE_BOTTOM_FIRST </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><br /><span class="pln">    </span><span class="pun">};</span><br /><br /><span class="pln">    </span><span class="kwd">enum</span><span class="pln"> </span><span class="typ">ImageAspectRatio</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	ASPECT_RATIO_KEEP       </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><br /><span class="pln">	ASPECT_RATIO_STRETCH    </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><br /><span class="pln">    </span><span class="pun">};</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Load, compile, and initialize the shader.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="typ">RectShader</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">shaderName </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Destructor.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">virtual</span><span class="pln"> </span><span class="pun">~</span><span class="typ">RectShader</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Set the attributes of the shader.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">virtual</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> bind</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">GLfloat</span><span class="pln"> vertices</span><span class="pun">[</span><span class="lit">8</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">GLfloat</span><span class="pln"> uvs</span><span class="pun">[</span><span class="lit">8</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Set the viewport aspect ratio</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">virtual</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> setViewportAspectRatio</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> width</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> height </span><span class="pun">);</span><br /><br /><span class="pln">   </span><span class="com">/*</span><br /><span class="com">    * To be called when the image size changes. Set image size, which</span><br /><span class="com">    * row is zero, and if we want to keep the aspect ratio or fit the image</span><br /><span class="com">    */</span><br /><span class="pln">   </span><span class="kwd">virtual</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> setImageSize</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> width</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> height</span><span class="pun">,</span><br /><span class="pln">   			</span><span class="typ">ImageRowStorage</span><span class="pln"> zeroRow </span><span class="pun">=</span><span class="pln"> STORAGE_TOP_FIRST</span><span class="pun">,</span><br /><span class="pln">   			</span><span class="typ">ImageAspectRatio</span><span class="pln"> aspect </span><span class="pun">=</span><span class="pln"> ASPECT_RATIO_STRETCH </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Returns the origin of the rectangle in viewport coordinates</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> getOrigUniform</span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLfloat</span><span class="pln"> origin</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">const</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Returns the dimensions of the rectangle in viewport coordinates</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> getDimUniform</span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLfloat</span><span class="pln"> dim</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">const</span><span class="pun">;</span><br /><span class="kwd">protected</span><span class="pun">:</span><br /><br /><span class="pln">    </span><span class="com">/* Functions */</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Computes the viewport region the current image will take.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> updateClipRegion</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="com">/* Variables */</span><br /><span class="pln">    </span><span class="typ">GLint</span><span class="pln"> mProgram</span><span class="pun">;</span><span class="pln">   </span><span class="com">// The shader</span><br /><span class="pln">    </span><span class="typ">GLint</span><span class="pln"> mPosAttrib</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Attribute for the surface corners in screen coordinates</span><br /><span class="pln">    </span><span class="typ">GLint</span><span class="pln"> mUvAttrib</span><span class="pun">;</span><span class="pln">  </span><span class="com">// Attribute for the surface corners in GL coordinates</span><br /><br /><span class="pln">    </span><span class="typ">GLint</span><span class="pln"> mDUniform</span><span class="pun">;</span><span class="pln">        </span><span class="com">// uD uniform location</span><br /><span class="pln">    </span><span class="typ">GLint</span><span class="pln"> mViewOrigUniform</span><span class="pun">;</span><span class="pln"> </span><span class="com">// uViewOrig uniform location</span><br /><span class="pln">    </span><span class="typ">GLint</span><span class="pln"> mViewDimUniform</span><span class="pun">;</span><span class="pln">  </span><span class="com">// uViewDim uniform location</span><br /><br /><span class="pln">    </span><span class="typ">GLfloat</span><span class="pln"> mViewOrig</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><span class="pln">   </span><span class="com">// Current clip coordinates rectangle origin</span><br /><span class="pln">    </span><span class="typ">GLfloat</span><span class="pln"> mViewDim</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><span class="pln">    </span><span class="com">// Current clip coordinates rectangle dimension</span><br /><span class="pln">    </span><span class="typ">GLfloat</span><span class="pln"> mTexelDelta</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><span class="pln"> </span><span class="com">// Current texel delta value</span><br /><br /><span class="pln">    </span><span class="kwd">float</span><span class="pln"> mRectAspectRatio</span><span class="pun">;</span><span class="pln">     </span><span class="com">// The rectangle aspect ratio w / h</span><br /><span class="pln">    </span><span class="kwd">float</span><span class="pln"> mViewportAspectRatio</span><span class="pun">;</span><span class="pln"> </span><span class="com">// The viewport aspect ratio w / h</span><br /><br /><span class="pln">    </span><span class="typ">ImageRowStorage</span><span class="pln">     mZeroRowPos</span><span class="pun">;</span><span class="pln">     </span><span class="com">// Location of zero row (top or bottom)</span><br /><span class="pln">    </span><span class="typ">ImageAspectRatio</span><span class="pln">    mAspectBehavior</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Keep or stretch aspect ratio.</span><br /><span class="pun">};</span><br /><br /><span class="com">#endif</span><span class="pln"> </span><span class="com">/* RECT_SHADER_H_ */</span></pre>
        </blockquote>
        <p>Now let's move to <code>RectShader.cpp</code>. After adding the necessary includes:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="str">"RectShader.h"</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;GLES2/gl2ext.h&gt;</span><br /><br /><span class="com">// NVIDIA helper include</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_shader/nv_shader.h&gt;</span></pre>
        </blockquote>
        <p>Let's look at the constructor. Basically, the constructor takes the shader's file name; it then loads and compiles the program and caches the location of its attributes and uniforms. Finally, it initializes the rectangle and screen aspect ratio to default values. The aspect ratios will be recomputed every time either the screen or the image size change. We will have an object for each shader so that these initialization operations are only performed once:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="typ">RectShader</span><span class="pun">::</span><span class="typ">RectShader</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">shaderName </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Load the fragment and vertex shaders.</span><br /><span class="pln">    mProgram </span><span class="pun">=</span><span class="pln"> nv_load_program</span><span class="pun">(</span><span class="pln"> shaderName </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Compile, link, and attach the shader to the program.</span><br /><span class="pln">    glUseProgram</span><span class="pun">(</span><span class="pln"> mProgram </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Get pointers to the attributes in the program.</span><br /><span class="pln">    mPosAttrib </span><span class="pun">=</span><span class="pln"> glGetAttribLocation</span><span class="pun">(</span><span class="pln"> mProgram</span><span class="pun">,</span><span class="pln"> </span><span class="str">"aPos"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    mUvAttrib  </span><span class="pun">=</span><span class="pln"> glGetAttribLocation</span><span class="pun">(</span><span class="pln"> mProgram</span><span class="pun">,</span><span class="pln"> </span><span class="str">"aUV"</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Set up the texture sampler to texture unit 0</span><br /><span class="pln">    </span><span class="typ">GLint</span><span class="pln"> texUni </span><span class="pun">=</span><span class="pln"> glGetUniformLocation</span><span class="pun">(</span><span class="pln"> mProgram</span><span class="pun">,</span><span class="pln"> </span><span class="str">"uTex"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    glUniform1i</span><span class="pun">(</span><span class="pln"> texUni</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Get the location of the uniforms we will be udpating</span><br /><span class="pln">    mViewOrigUniform </span><span class="pun">=</span><span class="pln"> glGetUniformLocation</span><span class="pun">(</span><span class="pln"> mProgram</span><span class="pun">,</span><span class="pln"> </span><span class="str">"uViewMin"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    mViewDimUniform  </span><span class="pun">=</span><span class="pln"> glGetUniformLocation</span><span class="pun">(</span><span class="pln"> mProgram</span><span class="pun">,</span><span class="pln"> </span><span class="str">"uViewDim"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    mDUniform        </span><span class="pun">=</span><span class="pln"> glGetUniformLocation</span><span class="pun">(</span><span class="pln"> mProgram</span><span class="pun">,</span><span class="pln"> </span><span class="str">"uD"</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Initialize some default values for aspect ratio and uniforms.</span><br /><span class="pln">    mViewportAspectRatio </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pun">;</span><br /><span class="pln">    mRectAspectRatio </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pun">;</span><br /><span class="pln">    mTexelDelta</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mTexelDelta</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pun">;</span><br /><span class="pln">    mZeroRowPos </span><span class="pun">=</span><span class="pln"> STORAGE_TOP_FIRST</span><span class="pun">;</span><br /><span class="pln">    mAspectBehavior </span><span class="pun">=</span><span class="pln"> ASPECT_RATIO_KEEP</span><span class="pun">;</span><br /><br /><span class="pln">    updateClipRegion</span><span class="pun">();</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p><code>RectShader::bind()</code> actually activates the shader (via the call to <code>glUseProgram()</code>), sets the attributes to the arguments passed to the function and the uniforms to the values that have already been computed.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">bind</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">GLfloat</span><span class="pln"> vertices</span><span class="pun">[</span><span class="lit">8</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">GLfloat</span><span class="pln"> uvs</span><span class="pun">[</span><span class="lit">8</span><span class="pun">]</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Install the program object as a part of the current rendering state.</span><br /><span class="pln">    glUseProgram</span><span class="pun">(</span><span class="pln"> mProgram </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Disable VBO's (vertex buffer objects) for attributes.</span><br /><span class="pln">    glBindBuffer</span><span class="pun">(</span><span class="pln"> GL_ARRAY_BUFFER</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    glBindBuffer</span><span class="pun">(</span><span class="pln"> GL_ELEMENT_ARRAY_BUFFER</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Set the attribute mPosAttrib with the vertices in the screen coordinates...</span><br /><span class="pln">    glVertexAttribPointer</span><span class="pun">(</span><span class="pln"> mPosAttrib</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> GL_FLOAT</span><span class="pun">,</span><span class="pln"> GL_FALSE</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> vertices </span><span class="pun">);</span><br /><span class="pln">    </span><span class="com">// ... and enable it.</span><br /><span class="pln">    glEnableVertexAttribArray</span><span class="pun">(</span><span class="pln"> mPosAttrib </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Set the attribute mUvAttrib with the vertices in the GL coordinates...</span><br /><span class="pln">    glVertexAttribPointer</span><span class="pun">(</span><span class="pln"> mUvAttrib</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> GL_FLOAT</span><span class="pun">,</span><span class="pln"> GL_FALSE</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> uvs </span><span class="pun">);</span><br /><span class="pln">    </span><span class="com">// ... and enable it.</span><br /><span class="pln">    glEnableVertexAttribArray</span><span class="pun">(</span><span class="pln"> mUvAttrib </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Update the uniforms</span><br /><span class="pln">    glUniform2f</span><span class="pun">(</span><span class="pln"> mViewOrigUniform</span><span class="pun">,</span><span class="pln"> mViewOrig</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> mViewOrig</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    glUniform2f</span><span class="pun">(</span><span class="pln"> mViewDimUniform</span><span class="pun">,</span><span class="pln">  mViewDim</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">,</span><span class="pln"> mViewDim</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    glUniform2f</span><span class="pun">(</span><span class="pln"> mDUniform</span><span class="pun">,</span><span class="pln"> mTexelDelta</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> mTexelDelta</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>The vertex buffer objects (VBO) are a caching mechanism which allows to keep the vertex data in the high-performance graphics memory and render directly from there, removing the need to resend the data every time a primitive is drawn. In this example, we are disabling VBOs since the number of vertices small.</p>
        <p>We now add functions to be called when the screen size or the image size change. These functions update the aspect ratios and call <code>updateClipRegion()</code> to compute the new values for the uniforms.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">setViewportAspectRatio</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> width</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> height</span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Update the viewport aspect ration</span><br /><span class="pln">    mViewportAspectRatio </span><span class="pun">=</span><span class="pln"> width </span><span class="pun">/</span><span class="pln"> height</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Update the viewport region the image will cover.</span><br /><span class="pln">    updateClipRegion</span><span class="pun">();</span><br /><span class="pun">}</span><br /><br /><span class="kwd">void</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">setImageSize</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> width</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> height</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ImageRowStorage</span><span class="pln"> zeroRowPos</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ImageAspectRatio</span><span class="pln"> aspect </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Update the rectangle aspect ratio</span><br /><span class="pln">    mRectAspectRatio </span><span class="pun">=</span><span class="pln"> width </span><span class="pun">/</span><span class="pln"> height</span><span class="pun">;</span><br /><span class="pln">    mZeroRowPos </span><span class="pun">=</span><span class="pln"> zeroRowPos</span><span class="pun">;</span><br /><span class="pln">    mAspectBehavior </span><span class="pun">=</span><span class="pln"> aspect</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Update the texel delta.</span><br /><span class="pln">    mTexelDelta</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> width</span><span class="pun">;</span><br /><span class="pln">    mTexelDelta</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> height</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Update the viewport region the image will cover.</span><br /><span class="pln">    updateClipRegion</span><span class="pun">();</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>The <code>updateClipRegion</code> function computes the new clip coordinates area that the rectangle will take based on the choice to keep the aspect ratio of the image or stretch it to fill the entire screen. In addition, if the top row is stored first in memory (as it is usually for images), we flip the vertical axis. This is because OpenGL assumes the first byte in the image is the bottom row. See the <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml">glTexImage2D reference</a> for more details.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">updateClipRegion</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mAspectBehavior </span><span class="pun">==</span><span class="pln"> ASPECT_RATIO_KEEP</span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> mViewportAspectRatio </span><span class="pun">&gt;</span><span class="pln"> mRectAspectRatio </span><span class="pun">)</span><br /><span class="pln">      </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// Viewport is wider than rectangle</span><br /><span class="pln">	</span><span class="com">// Use entire viewport height and clip width</span><br /><span class="pln">	mViewOrig</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mViewportAspectRatio </span><span class="pun">-</span><span class="pln"> mRectAspectRatio</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2.0f</span><span class="pun">;</span><br /><span class="pln">	mViewOrig</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1.0f</span><span class="pun">;</span><br /><span class="pln">	mViewDim</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln">  </span><span class="lit">2.0f</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mViewportAspectRatio </span><span class="pun">-</span><span class="pln"> mRectAspectRatio</span><span class="pun">);</span><br /><span class="pln">	mViewDim</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln">  </span><span class="lit">2.0f</span><span class="pun">;</span><br /><span class="pln">      </span><span class="pun">}</span><span class="pln">	
      </span><span class="kwd">else</span><br /><span class="pln">      </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// Viewport is taller than rectangle</span><br /><span class="pln">	</span><span class="com">// Use entire viewport width and clip height</span><br /><span class="pln">	mViewOrig</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1.0f</span><span class="pun">;</span><br /><span class="pln">	mViewOrig</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> mViewportAspectRatio </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> mRectAspectRatio</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2.0f</span><span class="pun">;</span><br /><span class="pln">	mViewDim</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln">  </span><span class="lit">2.0f</span><span class="pun">;</span><br /><span class="pln">	mViewDim</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln">  </span><span class="lit">2.0f</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> mViewportAspectRatio </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> mRectAspectRatio</span><span class="pun">);</span><br /><span class="pln">      </span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">else</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">      mViewOrig</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mViewOrig</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1.0f</span><span class="pun">;</span><br /><span class="pln">      mViewDim</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mViewDim</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2.0f</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="com">// If zero row is at the top, we need to flip the vertical signs</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> mZeroRowPos </span><span class="pun">==</span><span class="pln"> STORAGE_TOP_FIRST </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">      mViewOrig</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="pln">mViewOrig</span><span class="pun">[</span><span class="lit">1</span><span class="pun">];</span><br /><span class="pln">      mViewDim</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="pln">mViewDim</span><span class="pun">[</span><span class="lit">1</span><span class="pun">];</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Finally, we add two functions to return the values of the computed uniforms. We will pass these values to other shaders when we draw features on top of the image in the next section.</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">getOrigUniform</span><span class="pun">(</span><span class="typ">GLfloat</span><span class="pln"> origin</span><span class="pun">[</span><span class="lit">2</span><span class="pun">])</span><span class="pln"> </span><span class="kwd">const</span><br /><span class="pun">{</span><br /><span class="pln">    origin</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mViewOrig</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span><br /><span class="pln">    origin</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mViewOrig</span><span class="pun">[</span><span class="lit">1</span><span class="pun">];</span><br /><span class="pun">}</span><br /><br /><span class="kwd">void</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">getDimUniform</span><span class="pun">(</span><span class="typ">GLfloat</span><span class="pln"> dim</span><span class="pun">[</span><span class="lit">2</span><span class="pun">])</span><span class="pln"> </span><span class="kwd">const</span><br /><span class="pun">{</span><br /><span class="pln">    dim</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mViewDim</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span><br /><span class="pln">    dim</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mViewDim</span><span class="pun">[</span><span class="lit">1</span><span class="pun">];</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>In the destructor, we only need to delete the program and we're done:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="typ">RectShader</span><span class="pun">::~</span><span class="typ">RectShader</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Delete the program object</span><br /><span class="pln">    glDeleteProgram</span><span class="pun">(</span><span class="pln"> mProgram </span><span class="pun">);</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Now we need one more class. Create a class called <code>DrawRect</code>, which will select the correct shader to use and will perform the actual rendering. The header file is really simple and it should only contain the following code:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#ifndef</span><span class="pln"> DRAW_RECT_H</span><br /><span class="com">#define</span><span class="pln"> DRAW_RECT_H</span><br /><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;GLES2/gl2.h&gt;</span><br /><br /><span class="kwd">class</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">;</span><br /><br /><span class="kwd">class</span><span class="pln"> </span><span class="typ">DrawRect</span><br /><span class="pun">{</span><br /><span class="kwd">public</span><span class="pun">:</span><br /><br /><span class="pln">    </span><span class="typ">DrawRect</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Set what shader should be used to render the texture.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> setShader</span><span class="pun">(</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pln"> </span><span class="pun">*</span><span class="pln">shader </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">/*</span><br /><span class="com">     * Render the texture.</span><br /><span class="com">     */</span><br /><span class="pln">    </span><span class="kwd">void</span><span class="pln"> draw</span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLint</span><span class="pln"> tex </span><span class="pun">);</span><br /><br /><span class="kwd">private</span><span class="pun">:</span><br /><br /><span class="pln">    </span><span class="typ">RectShader</span><span class="pln"> </span><span class="pun">*</span><span class="pln">mShader</span><span class="pun">;</span><span class="pln">      </span><span class="com">// Pointer to the current shader</span><br /><span class="pun">};</span><br /><br /><span class="com">#endif</span></pre>
        </blockquote>
        <p>The cpp file is very straight-forward too:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="str">"DrawRect.h"</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">"RectShader.h"</span><br /><br /><span class="kwd">static</span><span class="pln"> </span><span class="typ">GLushort</span><span class="pln"> indices</span><span class="pun">[</span><span class="lit">4</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">};</span><br /><br /><span class="kwd">static</span><span class="pln"> </span><span class="typ">GLfloat</span><span class="pln"> vertices</span><span class="pun">[</span><span class="lit">8</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.0f</span><span class="pun">,</span><br /><span class="pln">			       </span><span class="lit">0.0f</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.0f</span><span class="pun">,</span><br /><span class="pln">			       </span><span class="lit">1.0f</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pun">,</span><br /><span class="pln">			       </span><span class="lit">0.0f</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">};</span><br /><br /><span class="kwd">static</span><span class="pln"> </span><span class="typ">GLfloat</span><span class="pln"> uvs</span><span class="pun">[</span><span class="lit">8</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln">      </span><span class="pun">{</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.0f</span><span class="pun">,</span><br /><span class="pln">			       </span><span class="lit">0.0f</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.0f</span><span class="pun">,</span><br /><span class="pln">			       </span><span class="lit">1.0f</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pun">,</span><br /><span class="pln">			       </span><span class="lit">0.0f</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pln"> </span><span class="pun">};</span><br /><br /><span class="typ">DrawRect</span><span class="pun">::</span><span class="typ">DrawRect</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    mShader </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span><br /><span class="pun">}</span><br /><br /><span class="kwd">void</span><span class="pln"> </span><span class="typ">DrawRect</span><span class="pun">::</span><span class="pln">setShader</span><span class="pun">(</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pln"> </span><span class="pun">*</span><span class="pln">shader </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    mShader </span><span class="pun">=</span><span class="pln"> shader</span><span class="pun">;</span><br /><span class="pun">}</span><br /><br /><span class="kwd">void</span><span class="pln"> </span><span class="typ">DrawRect</span><span class="pun">::</span><span class="pln">draw</span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLint</span><span class="pln"> tex </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Initialize the shader.</span><br /><span class="pln">    mShader</span><span class="pun">-&gt;</span><span class="pln">bind</span><span class="pun">(</span><span class="pln"> vertices</span><span class="pun">,</span><span class="pln"> uvs </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Select the active texture unit.</span><br /><span class="pln">    glActiveTexture</span><span class="pun">(</span><span class="pln"> GL_TEXTURE0 </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Bind our texture to the texturing target.</span><br /><span class="pln">    glBindTexture</span><span class="pun">(</span><span class="pln"> GL_TEXTURE_2D</span><span class="pun">,</span><span class="pln"> tex </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Perform the actual drawing.</span><br /><span class="pln">    glDrawElements</span><span class="pun">(</span><span class="pln"> GL_TRIANGLE_STRIP</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> GL_UNSIGNED_SHORT</span><span class="pun">,</span><span class="pln"> indices </span><span class="pun">);</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Now we need to modify the Engine class. First, in the header file, we need to add a couple of includes:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_ui/nv_ui_rect.h&gt;</span><br /><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;memory&gt;</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;vector&gt;</span><br /><br /><span class="com">#include</span><span class="pln"> </span><span class="str">"DrawRect.h"</span><br /><span class="com">#include</span><span class="pln"> </span><span class="str">"RectShader.h"</span></pre>
        </blockquote>
        <p>Then we need to change <code>updateFrame</code> to take a time step argument, and add a method that advances time:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> updateFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> interactible</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> deltaTime </span><span class="pun">);</span><span class="pln">
</span><br /><span class="com">/**</span><br /><span class="com"> * Advance the time counter by the amount of time elapsed.</span><br /><span class="com"> */</span><br /><span class="kwd">void</span><span class="pln"> advanceTime</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> deltaTime </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    mTimeVal </span><span class="pun">+=</span><span class="pln"> deltaTime </span><span class="pun">*</span><span class="pln"> </span><span class="lit">0.001</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>Finally we need a few member variables:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">// Texture and shaders</span><br /><span class="typ">GLuint</span><span class="pln">                      mImgTexture</span><span class="pun">;</span><br /><span class="pln">std</span><span class="pun">::</span><span class="pln">unique_ptr</span><span class="pun">&lt;</span><span class="typ">DrawRect</span><span class="pun">&gt;</span><span class="pln">   mDrawRect</span><span class="pun">;</span><br /><span class="pln">std</span><span class="pun">::</span><span class="pln">unique_ptr</span><span class="pun">&lt;</span><span class="typ">RectShader</span><span class="pun">&gt;</span><span class="pln"> mRectShader</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><br /><br /><span class="com">// Variables for the UI</span><br /><span class="typ">NvUIRect</span><span class="pln"> mUiButtonZone</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><br /><span class="kwd">void</span><span class="pln">    </span><span class="pun">*</span><span class="pln">mClockText</span><span class="pun">;</span><br /><span class="kwd">void</span><span class="pln">    </span><span class="pun">*</span><span class="pln">mUiPauseText</span><span class="pun">;</span><br /><span class="kwd">void</span><span class="pln">    </span><span class="pun">*</span><span class="pln">mUiButton</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><br /><span class="kwd">int</span><span class="pln">      mHitButton</span><span class="pun">;</span><br /><span class="kwd">double</span><span class="pln">   mTimeVal</span><span class="pun">;</span></pre>
        </blockquote>
        <p>But we are not going to use a couple of the old variables so you can remove the following:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">mUiText</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><br /><span class="kwd">int</span><span class="pln">   mTouchX</span><span class="pun">,</span><span class="pln"> mTouchY</span><span class="pun">;</span></pre>
        </blockquote>
        <p>Now we need to change the implementation of a few functions in the cpp file, but first we need to add an include and define a couple of colors for the UI:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;nv_glesutil/nv_images.h&gt;</span><br /><br /><span class="com">// Define packed colors</span><br /><span class="typ">NvPackedColor</span><span class="pln"> activeColor   </span><span class="pun">=</span><span class="pln"> NV_PACKED_COLOR</span><span class="pun">(</span><span class="pln"> </span><span class="lit">250</span><span class="pun">,</span><span class="pln"> </span><span class="lit">180</span><span class="pun">,</span><span class="pln"> </span><span class="lit">50</span><span class="pun">,</span><span class="pln"> </span><span class="lit">255</span><span class="pln"> </span><span class="pun">);</span><br /><span class="typ">NvPackedColor</span><span class="pln"> deactiveColor </span><span class="pun">=</span><span class="pln"> NV_PACKED_COLOR</span><span class="pun">(</span><span class="pln"> </span><span class="lit">255</span><span class="pun">,</span><span class="pln"> </span><span class="lit">255</span><span class="pun">,</span><span class="pln"> </span><span class="lit">255</span><span class="pun">,</span><span class="pln"> </span><span class="lit">255</span><span class="pln"> </span><span class="pun">);</span></pre>
        </blockquote>
        <p>The constructor and destructor aren't changed much, we just need to initialize a bunch of different UI components and free them:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="typ">Engine</span><span class="pun">::</span><span class="typ">Engine</span><span class="pun">(</span><span class="pln"> </span><span class="typ">NvEGLUtil</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> egl</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> android_app </span><span class="pun">*</span><span class="pln">app </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">:</span><span class="pln"> mEgl</span><span class="pun">(</span><span class="pln"> egl </span><span class="pun">),</span><span class="pln"> mApp</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">),</span><span class="pln"> mResizePending</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">),</span><span class="pln"> mActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">),</span><br /><span class="pln">    mForceRender</span><span class="pun">(</span><span class="pln"> FRAMES_TO_RENDER </span><span class="pun">),</span><span class="pln"> mUiInitialized</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">)</span><span class="pln">   
</span><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Save a pointer to the engine in the Android app</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">userData </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Save pointers to the implementation of the callback functions in the</span><br /><span class="pln">    </span><span class="com">// Android app</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">onAppCmd     </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&amp;</span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleCmdThunk</span><span class="pun">;</span><br /><span class="pln">    app</span><span class="pun">-&gt;</span><span class="pln">onInputEvent </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&amp;</span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleInputThunk</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// Initialize the nv_shader library</span><br /><span class="pln">    nv_shader_init</span><span class="pun">(</span><span class="pln"> app</span><span class="pun">-&gt;</span><span class="pln">activity</span><span class="pun">-&gt;</span><span class="pln">assetManager </span><span class="pun">);</span><br /><br /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Initialize all the UI components</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mClockText   </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mUiPauseText </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mHitButton   </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></span><br /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Initialize the mDrawRect and mRectShader objects</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mDrawRect      </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mRectShader</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mRectShader</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Initialize the texture</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mImgTexture    </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Initialize the time counter</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mTimeVal       </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pun">;</span></span><br /><span class="pun">}</span><br /><br /><span class="typ">Engine</span><span class="pun">::~</span><span class="typ">Engine</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Free the allocated BitFonts</span><br /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextFree</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextFree</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextFree</span><span class="pun">(</span><span class="pln"> mUiPauseText </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextFree</span><span class="pun">(</span><span class="pln"> mClockText </span><span class="pun">);</span></span><br /><span class="pln">    </span><span class="typ">NVBFCleanup</span><span class="pun">();</span><br /><br /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Delete the texture</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    glDeleteTextures</span><span class="pun">(</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">mImgTexture </span><span class="pun">);</span></span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>The method <code>Engine::handleInput()</code> needs to be changed to account for the fact that, instead of tracking the touch positions, we now need to detect and save which button has been pressed by the user:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">handleInput</span><span class="pun">(</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="kwd">event</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">//We only handle motion events (touchscreen) and key (button/key) events</span><br /><span class="pln">    </span><span class="typ">int32_t</span><span class="pln"> eventType </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AInputEvent_getType</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> eventType </span><span class="pun">==</span><span class="pln"> AINPUT_EVENT_TYPE_MOTION </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">int32_t</span><span class="pln"> action </span><span class="pun">=</span><span class="pln"> AMOTION_EVENT_ACTION_MASK </span><span class="pun">&amp;</span><span class="pln"> </span><span class="typ">AMotionEvent_getAction</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">)</span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">int32_t</span><span class="pln"> mx </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AMotionEvent_getX</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">int32_t</span><span class="pln"> </span><span class="kwd">my</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AMotionEvent_getY</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> isActiveMode</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="pun">{</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="com">// Check if the touch was inside of the first button...</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiButtonZone</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">inside</span><span class="pun">(</span><span class="pln"> mx</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">my</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><span class="pln">      </span><span class="pun">{</span><span class="pln"> mHitButton </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="com">// ... or the second</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiButtonZone</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">inside</span><span class="pun">(</span><span class="pln"> mx</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">my</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> mHitButton </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="kwd">else</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="pun">{</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="com">// A tap on the screen takes us out of autopause into active mode if</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="com">// we were paused.  No other touch processing is done.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> action </span><span class="pun">==</span><span class="pln"> AMOTION_EVENT_ACTION_DOWN </span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="pun">{</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">		setActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">		</span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> eventType </span><span class="pun">==</span><span class="pln"> AINPUT_EVENT_TYPE_KEY </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">int32_t</span><span class="pln"> code </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AKeyEvent_getKeyCode</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">AInputEvent</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">	</span><span class="com">// if we are in active mode, we eat the back button and move into</span><br /><span class="pln">	</span><span class="com">// pause mode.  If we are already in pause mode, we allow the back</span><br /><span class="pln">	</span><span class="com">// button to be handled by the OS, which means we'll be shut down</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> code </span><span class="pun">==</span><span class="pln"> AKEYCODE_BACK </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> mActiveMode </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    setActiveMode</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>In <code>Engine::updateFrame()</code> we only need to add a couple of lines of code to advance the clock:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">void</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">updateFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> interactible</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> deltaTime </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> interactible </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// Each frame, we check to see if the window has resized.  While the</span><br /><span class="pln">	</span><span class="com">// various events we get _should_ cover this, in practice, it appears</span><br /><span class="pln">	</span><span class="com">// that the safest move across all platforms and OSes is to check at</span><br /><span class="pln">	</span><span class="com">// the top of each frame</span><br /><span class="pln">	checkWindowResized</span><span class="pun">();</span><br /><br /><span class="pln">	</span><span class="com">// Time stands still when we're auto-paused, and we don't</span><br /><span class="pln">	</span><span class="com">// automatically render</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mActiveMode </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span style="background-color: #ffffe0;"><span class="pln">	    </span><span class="com">// The time needs to advance in active mode.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	    advanceTime</span><span class="pun">(</span><span class="pln"> deltaTime </span><span class="pun">);</span></span><br /><br /><span class="pln">	    </span><span class="com">// This will try to set up EGL if it isn't set up</span><br /><span class="pln">	    </span><span class="com">// When we first set up EGL completely, we also load our GLES resources</span><br /><span class="pln">	    </span><span class="com">// If these are already set up or we succeed at setting them all up now, then</span><br /><span class="pln">	    </span><span class="com">// we go ahead and render.</span><br /><span class="pln">	    renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">	</span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> isForcedRenderPending</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><span class="pln">  </span><span class="com">// forced rendering when needed for UI, etc.</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	    </span><span class="com">// This forces to render.</span><br /><span class="pln">	    renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">else</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// Even if we are not interactible, we may be visible, so we</span><br /><span class="pln">	</span><span class="com">// HAVE to do any forced renderings if we can.  We must also</span><br /><span class="pln">	</span><span class="com">// check for resize, since that may have been the point of the</span><br /><span class="pln">	</span><span class="com">// forced render request in the first place!</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> isForcedRenderPending</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">isReadyToRender</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">	</span><span class="pun">{</span><br /><span class="pln">	     checkWindowResized</span><span class="pun">();</span><br /><span class="pln">	     renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p><code>Engine::renderFrame()</code> is very similar to the previous example as well, but we need to select the shader based on the button that was pressed, and render the button (change colors depeding on selection) and the clock:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">bool</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">renderFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> allocateIfNeeded </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Check that EGL is ready to render. If allocateIfNeeded</span><br /><span class="pln">    </span><span class="com">// try to also allocate the rendering surface and bind it</span><br /><span class="pln">    </span><span class="com">// to the context.</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">mEgl</span><span class="pun">.</span><span class="pln">isReadyToRender</span><span class="pun">(</span><span class="pln"> allocateIfNeeded </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln"> 	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="com">// Make sure that the UI is initialized</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">initUI</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	LOGW</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Could not initialize UI - assets may be missing!"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">ANativeActivity_finish</span><span class="pun">(</span><span class="pln"> mApp</span><span class="pun">-&gt;</span><span class="pln">activity </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    resizeIfNeeded</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="com">// Set up viewport</span><br /><span class="pln">    glViewport</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLint</span><span class="pln"> </span><span class="pun">)</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLint</span><span class="pln"> </span><span class="pun">)</span><span class="lit">0</span><span class="pun">,</span><br /><span class="pln">		</span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLsizei</span><span class="pln"> </span><span class="pun">)(</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getWidth</span><span class="pun">()</span><span class="pln"> </span><span class="pun">),</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="typ">GLsizei</span><span class="pln"> </span><span class="pun">)(</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getHeight</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Clear buffers as necessary</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    glClear</span><span class="pun">(</span><span class="pln"> GL_COLOR_BUFFER_BIT </span><span class="pun">|</span><span class="pln"> GL_DEPTH_BUFFER_BIT </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">/* Do some rendering here */</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Based on the button that is selected choose the shader that should be used...</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mDrawRect</span><span class="pun">-&gt;</span><span class="pln">setShader</span><span class="pun">(</span><span class="pln"> mRectShader</span><span class="pun">[</span><span class="pln">mHitButton</span><span class="pun">].</span><span class="kwd">get</span><span class="pun">()</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// ... and pass the texture to the shader.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mDrawRect</span><span class="pun">-&gt;</span><span class="pln">draw</span><span class="pun">(</span><span class="pln"> mImgTexture </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Render the rendering bitfont text overlaid here.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextRenderPrep</span><span class="pun">();</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Update the clock.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mClockText </span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="pun">{</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="com">// Set the correct color depending on the mActiveMode</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">NVBFTextSetMultiplyColor</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	mActiveMode </span><span class="pun">?</span><span class="pln"> activeColor </span><span class="pun">:</span><span class="pln"> deactiveColor </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">NVBFTextRender</span><span class="pun">(</span><span class="pln"> mClockText </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="com">// We update the clock text &gt;after&lt; rendering, so it will change on pause.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="kwd">int</span><span class="pln"> mins </span><span class="pun">=</span><span class="pln"> mTimeVal </span><span class="pun">/</span><span class="pln"> </span><span class="lit">60</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="kwd">float</span><span class="pln"> secs </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln">mTimeVal </span><span class="pun">-</span><span class="pln"> mins </span><span class="pun">*</span><span class="pln"> </span><span class="lit">60</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="kwd">char</span><span class="pln"> str</span><span class="pun">[</span><span class="lit">32</span><span class="pun">];</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	sprintf</span><span class="pun">(</span><span class="pln"> str</span><span class="pun">,</span><span class="pln"> </span><span class="str">"%03d:%05.2f"</span><span class="pun">,</span><span class="pln"> mins</span><span class="pun">,</span><span class="pln"> secs </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">NVBFTextSetString</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span><span class="pln"> str </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Render the buttons.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">mActiveMode </span><span class="pun">)</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="pun">{</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">NVBFTextRender</span><span class="pun">(</span><span class="pln"> mUiPauseText </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="kwd">else</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="pun">{</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">NVBFTextSetMultiplyColor</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="pln">mHitButton</span><span class="pun">],</span><span class="pln"> activeColor </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">NVBFTextSetMultiplyColor</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[(</span><span class="pln"> mHitButton </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">2</span><span class="pun">],</span><span class="pln"> deactiveColor </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">NVBFTextRender</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">	</span><span class="typ">NVBFTextRender</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="pun">}</span></span><br /><br /><span class="pln">    </span><span class="com">// Done rendering overlaid text.</span><br /><span class="pln">    </span><span class="typ">NVBFTextRenderDone</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mForceRender </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> mForceRender</span><span class="pun">--;</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="com">// Swap the buffers, which indicates we're done with rendering this frame</span><br /><span class="pln">    mEgl</span><span class="pun">.</span><span class="pln">swap</span><span class="pun">();</span><br /><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>In the methods <code>Engine::initUI()</code> and <code>Engine::resizeIfNeeded()</code>, we just need to allocate or update different UI components or objects:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">bool</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">initUI</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// The UI might have been initialized already</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiInitialized </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">   LOGD</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Initializing UI"</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Initialize the NVIDIA bitfonts</span><br /><span class="pln">    </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> NUM_FONTS </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">NvBool</span><span class="pln"> fontsSplit</span><span class="pun">[</span><span class="pln">NUM_FONTS</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">};</span><span class="pln"> </span><span class="com">// all are split</span><br /><span class="pln">    </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> fontFiles</span><span class="pun">[</span><span class="pln">NUM_FONTS</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="str">"courier+lucida_256.dds"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"utahcond+bold_1024.dds"</span><span class="pln"> </span><span class="pun">};</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="typ">NVBFInitialize</span><span class="pun">(</span><span class="pln"> NUM_FONTS</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">**</span><span class="pln"> </span><span class="pun">)</span><span class="pln">fontFiles</span><span class="pun">,</span><span class="pln"> fontsSplit</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	LOGW</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Could not initialize NvBitFont"</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Allocate the text for the clock and set its properties</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mClockText </span><span class="pun">=</span><span class="pln"> </span><span class="typ">NVBFTextAlloc</span><span class="pun">();</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetFont</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// should look up by font file name.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span><span class="pln"> </span><span class="lit">32</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetColor</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span><span class="pln"> NV_PC_PREDEF_WHITE </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetString</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span><span class="pln"> </span><span class="str">"000:00.00"</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Allocate the text for the text of the autopause mode and set its properties</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mUiPauseText </span><span class="pun">=</span><span class="pln"> </span><span class="typ">NVBFTextAlloc</span><span class="pun">();</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetFont</span><span class="pun">(</span><span class="pln"> mUiPauseText</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// should look up by font file name.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiPauseText</span><span class="pun">,</span><span class="pln"> </span><span class="lit">32</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetColor</span><span class="pun">(</span><span class="pln"> mUiPauseText</span><span class="pun">,</span><span class="pln"> NV_PC_PREDEF_WHITE </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetString</span><span class="pun">(</span><span class="pln"> mUiPauseText</span><span class="pun">,</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    			NVBF_COLORSTR_RED NVBF_STYLESTR_BOLD </span><span class="str">"Auto-pause:\n"</span><span class="pln"> NVBF_STYLESTR_NORMAL</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">   			NVBF_COLORSTR_BLUE </span><span class="str">"Press back to quit\nTap window to resume"</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// UI Buttons</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">NVBFTextAlloc</span><span class="pun">();</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetFont</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// should look up by font file name.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> </span><span class="lit">48</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetColor</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> NV_PC_PREDEF_WHITE </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetShadow</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> </span><span class="lit">5</span><span class="pun">,</span><span class="pln"> NV_PC_PREDEF_BLACK </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetString</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> NVBF_STYLESTR_BOLD </span><span class="str">"ON"</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">NVBFTextAlloc</span><span class="pun">();</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetFont</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// should look up by font file name.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">48</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetColor</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> NV_PC_PREDEF_WHITE </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetShadow</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">5</span><span class="pun">,</span><span class="pln"> NV_PC_PREDEF_BLACK </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetString</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> NVBF_STYLESTR_BOLD </span><span class="str">"OFF"</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Set the correct button as active.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mHitButton </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="typ">NVBFTextSetMultiplyColor</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="pln">mHitButton</span><span class="pun">],</span><span class="pln"> activeColor </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Load the texture image</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mImgTexture </span><span class="pun">=</span><span class="pln"> </span><span class="typ">NvCreateTextureFromDDSEx</span><span class="pun">(</span><span class="pln"> </span><span class="str">"nvidia_green.dds"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">,</span><span class="pln"> NULL </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Allocate the objects</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mDrawRect</span><span class="pun">.</span><span class="pln">reset</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">DrawRect</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mRectShader</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">reset</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">(</span><span class="pln"> </span><span class="str">"filter"</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mRectShader</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]-&gt;</span><span class="pln">setImageSize</span><span class="pun">(</span><span class="pln"> </span><span class="lit">1366.0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">720.0</span><span class="pun">,</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    		</span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">STORAGE_TOP_FIRST</span><span class="pun">,</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">ASPECT_RATIO_STRETCH </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mRectShader</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">reset</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">(</span><span class="pln"> </span><span class="str">"plain"</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    mRectShader</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]-&gt;</span><span class="pln">setImageSize</span><span class="pun">(</span><span class="pln"> </span><span class="lit">1366.0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">720.0</span><span class="pun">,</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">   		</span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">STORAGE_TOP_FIRST</span><span class="pun">,</span><span class="pln"> </span><span class="typ">RectShader</span><span class="pun">::</span><span class="pln">ASPECT_RATIO_STRETCH </span><span class="pun">);</span></span><br /><br /><span class="pln">    mUiInitialized </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="kwd">bool</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">::</span><span class="pln">resizeIfNeeded</span><span class="pun">()</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Do we need to resize?</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">mResizePending </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">    </span><span class="com">// Get the target height and width</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> w </span><span class="pun">=</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getWidth</span><span class="pun">();</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> h </span><span class="pun">=</span><span class="pln"> mEgl</span><span class="pun">.</span><span class="pln">getHeight</span><span class="pun">();</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> textHeight </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> w </span><span class="pun">&gt;</span><span class="pln"> h </span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> h </span><span class="pun">/</span><span class="pln"> </span><span class="lit">16</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> w </span><span class="pun">/</span><span class="pln"> </span><span class="lit">16</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Change the resolution to the correct width and height</span><br /><span class="pln">    </span><span class="typ">NVBFSetScreenRes</span><span class="pun">(</span><span class="pln"> w</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">);</span><br /><br /><span class="pln">    </span><span class="com">// Also update the size of the characters and their location</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mClockText </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span><span class="pln"> textHeight </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorAlign</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span><span class="pln"> NVBF_ALIGN_LEFT</span><span class="pun">,</span><span class="pln"> NVBF_ALIGN_TOP </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorPos</span><span class="pun">(</span><span class="pln"> mClockText</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiPauseText </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiPauseText</span><span class="pun">,</span><span class="pln"> textHeight </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorAlign</span><span class="pun">(</span><span class="pln"> mUiPauseText</span><span class="pun">,</span><span class="pln"> NVBF_ALIGN_CENTER</span><span class="pun">,</span><span class="pln"> NVBF_ALIGN_BOTTOM </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorPos</span><span class="pun">(</span><span class="pln"> mUiPauseText</span><span class="pun">,</span><span class="pln"> w </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> textHeight </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorAlign</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> NVBF_ALIGN_RIGHT</span><span class="pun">,</span><span class="pln"> NVBF_ALIGN_BOTTOM </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorPos</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> w </span><span class="pun">-</span><span class="pln"> textHeight </span><span class="pun">*</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">-</span><span class="pln"> </span><span class="lit">10</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	mUiButtonZone</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="kwd">set</span><span class="pun">(</span><span class="pln"> w </span><span class="pun">-</span><span class="pln"> textHeight </span><span class="pun">*</span><span class="pln"> </span><span class="lit">6</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">-</span><span class="pln"> </span><span class="lit">10</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> textHeight</span><span class="pun">,</span><span class="pln"> textHeight </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> textHeight </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="typ">NVBFTextSetSize</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> textHeight </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorAlign</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> NVBF_ALIGN_RIGHT</span><span class="pun">,</span><span class="pln"> NVBF_ALIGN_BOTTOM </span><span class="pun">);</span><br /><span class="pln">	</span><span class="typ">NVBFTextCursorPos</span><span class="pun">(</span><span class="pln"> mUiButton</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> w </span><span class="pun">-</span><span class="pln"> textHeight</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">-</span><span class="pln"> </span><span class="lit">10</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">	mUiButtonZone</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="kwd">set</span><span class="pun">(</span><span class="pln"> w </span><span class="pun">-</span><span class="pln"> textHeight </span><span class="pun">*</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> h </span><span class="pun">-</span><span class="pln"> </span><span class="lit">10</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> textHeight</span><span class="pun">,</span><span class="pln"> textHeight </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> textHeight </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mRectShader</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="kwd">get</span><span class="pun">()</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">nullptr</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	mRectShader</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]-&gt;</span><span class="pln">setViewportAspectRatio</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> w</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">float</span><span class="pun">(</span><span class="pln"> h </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> mRectShader</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="kwd">get</span><span class="pun">()</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">nullptr</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	mRectShader</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]-&gt;</span><span class="pln">setViewportAspectRatio</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> w</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">float</span><span class="pun">(</span><span class="pln"> h </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span class="pln">    mResizePending </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>We need also to update our call to <code>updateFrame</code> in <code>SimpleNativeGL_NV.cpp</code> to pass the time delta since the last call to <code>updateFrame</code>. Open <code>SimpleNativeGL_NV.cpp</code> and add the following lines in the <code>android_main</code> function:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">std</span><span class="pun">::</span><span class="pln">unique_ptr</span><span class="pun">&lt;</span><span class="typ">Engine</span><span class="pun">&gt;</span><span class="pln"> engine</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Engine</span><span class="pun">(</span><span class="pln"> </span><span class="pun">*</span><span class="pln">egl</span><span class="pun">,</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><br /><span style="background-color: #ffffe0;"><span class="kwd">long</span><span class="pln"> lastTime </span><span class="pun">=</span><span class="pln"> egl</span><span class="pun">-&gt;</span><span class="pln">getSystemTime</span><span class="pun">();</span></span><br /><br /><span class="com">// loop waiting for stuff to do.</span><br /><br /><span class="kwd">while</span><span class="pun">(</span><span class="pln"> nv_app_status_running</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pun">{</span><br /><span class="pln">    </span><span class="com">// Read all pending events.</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> ident</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">int</span><span class="pln"> events</span><span class="pun">;</span><br /><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> android_poll_source </span><span class="pun">*</span><span class="pln">source</span><span class="pun">;</span><br /><br /><span class="pln">    </span><span class="com">// If not rendering, we will block forever waiting for events.</span><br /><span class="pln">    </span><span class="com">// If animating, we loop until all events are read, then continue</span><br /><span class="pln">    </span><span class="com">// to draw the next frame of animation.</span><br /><span class="pln">    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> ident </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ALooper_pollAll</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> nv_app_status_focused</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> engine</span><span class="pun">-&gt;</span><span class="pln">isActiveMode</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">250</span><span class="pln"> </span><span class="pun">),</span><br /><span class="pln">    					NULL</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">events</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">**</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">source </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><br /><span class="pln">    </span><span class="pun">{</span><br /><span class="pln">	</span><span class="com">// If we timed out, then there are no pending messages.</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> ident </span><span class="pun">==</span><span class="pln"> ALOOPER_POLL_TIMEOUT </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">break</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">	</span><span class="com">// Process this event.</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> source </span><span class="pun">!=</span><span class="pln"> NULL </span><span class="pun">)</span><span class="pln">                </span><span class="pun">{</span><span class="pln"> source</span><span class="pun">-&gt;</span><span class="pln">process</span><span class="pun">(</span><span class="pln"> app</span><span class="pun">,</span><span class="pln"> source </span><span class="pun">);</span><span class="pln"> </span><span class="pun">}</span><br /><br /><span class="pln">	</span><span class="com">// Check if we are exiting.  If so, dump out.</span><br /><span class="pln">	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln">nv_app_status_running</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">break</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><br /><span class="pln">    </span><span class="pun">}</span><br /><br /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="kwd">long</span><span class="pln"> currentTime </span><span class="pun">=</span><span class="pln"> egl</span><span class="pun">-&gt;</span><span class="pln">getSystemTime</span><span class="pun">();</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Clamp time - it must not go backwards, and we don't</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// want it to be more than a half second to avoid huge</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// delays causing issues.  Note that we do not clamp to above</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// zero because some tools will give us zero delta.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="kwd">long</span><span class="pln"> deltaTime </span><span class="pun">=</span><span class="pln"> currentTime </span><span class="pun">-</span><span class="pln"> lastTime</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="kwd">if</span><span class="pln">     </span><span class="pun">(</span><span class="pln"> deltaTime </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><span class="pln">    </span><span class="pun">{</span><span class="pln"> deltaTime </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> deltaTime </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">500</span><span class="pln"> </span><span class="pun">)</span><span class="pln">  </span><span class="pun">{</span><span class="pln"> deltaTime </span><span class="pun">=</span><span class="pln"> </span><span class="lit">500</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    lastTime </span><span class="pun">=</span><span class="pln"> currentTime</span><span class="pun">;</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// Update the frame, which optionally updates time and animations,</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    </span><span class="com">// and renders.</span></span><br style="background-color: #ffffe0;" /><span style="background-color: #ffffe0;"><span class="pln">    engine</span><span class="pun">-&gt;</span><span class="pln">updateFrame</span><span class="pun">(</span><span class="pln"> nv_app_status_interactable</span><span class="pun">(</span><span class="pln"> app </span><span class="pun">),</span><span class="pln"> deltaTime </span><span class="pun">);</span></span><br /><span class="pun">}</span></pre>
        </blockquote>
        <p>And now you're finally ready to test your application! Right-click on the project folder, <b>Run as &gt; Android Application</b>.</p>
        <p>If you followed the instructions in this tutorial, the application should start on your device and you should see the NVIDIA wallpaper. However, when you press the <b>ON</b> button you will just see a black screen on your device, instead of the gradient image.</p>
        <p>Let's try to find out why. Open the Logcat (<b>Window &gt; Show View &gt; Other &gt; Android &gt; LogCat</b>); if  you filter the messages by with the tag <code>nv_shader</code> you should see something like this:</p>
        <p><a class="MCPopupThumbnailLink" href="images/gl_shadererror.png"><img class="MCPopupThumbnail img" data-mc-width="1275" data-mc-height="864" src="images/gl_shadererror_thumb_700_0.png" style="mc-thumbnail: link;mc-thumbnail-max-width: 700px;mc-thumbnail-max-height: auto;" tabindex="" /></a>
        </p>
        <p>If you look at the line above the selected one, you will notice that <code>filter.vert</code> was correctly compiled while <code>filter.frag</code> generated an error. We also know the lines of the errors, the numbers in parenthesis. Line 59 of the shader is (your line numbering might be different):</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">gl_FragColor </span><span class="pun">+=</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln">   </span><span class="lit">0.0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="pln">uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pun">...</span><br /><span class="pln">gl_FragColor </span><span class="pun">-=</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln">   </span><span class="lit">0.0</span><span class="pun">,</span><span class="pln">  uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span></pre>
        </blockquote>
        <p>and the error says::</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">error C7011 </span><span class="typ">Implicit</span><span class="pln"> cast </span><span class="kwd">from</span><span class="pln"> </span><span class="str">"int"</span><span class="pln"> to </span><span class="str">"mediump float"</span></pre>
        </blockquote>
        <p>Basically, the problem is that we cannot do implicit casting in GL and everything is assumed to be float; we can fix the problem by replacing the above lines with:</p>
        <blockquote><pre class="prettyprint prettyprinted" style=""><span class="pln">gl_FragColor </span><span class="pun">+=</span><span class="pln"> </span><span class="lit">2.0</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln">   </span><span class="lit">0.0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="pln">uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><br /><span class="pun">...</span><br /><span class="pln">gl_FragColor </span><span class="pun">-=</span><span class="pln"> </span><span class="lit">2.0</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> texture2D</span><span class="pun">(</span><span class="pln"> uTex</span><span class="pun">,</span><span class="pln"> vTexCoord </span><span class="pun">+</span><span class="pln"> vec2</span><span class="pun">(</span><span class="pln">   </span><span class="lit">0.0</span><span class="pun">,</span><span class="pln">  uD</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span></pre>
        </blockquote>
        <p>In general, when you get a black screen instead of what you were expecting, the first thing you should do is go look at the LogCat and check for errors. Much like in the implicit cast example shown above, if you are using the utility functions from NVIDIA, errors shoud be caught and logged in the LogCat.</p>
        <p> </p>
        <p>This concludes our GL tutorial.</p>
        <p> </p>
        <p> </p>
        <div id="pagefooter">
            <br />
        </div>
        <hr style="height: 1px;" width="100%" size="0" align="center" />
        
        <p>
        </p><div class="buttons popup-container clearfix topicToolbarProxy topicToolbarProxystyle.css _Skins_GW_TopicToolbar mc-component nocontent" style="mc-topic-toolbar-items: ;">
        </div>
        <p>
        <img src="../../resources/prettify/onload.png" onload="prettyprint()" />
        </p><p><span style="color: #696969; font-size: 8pt;">NVIDIA® GameWorks™ Documentation Rev. 1.0.210204 ©2014-<span class="MyVariablesCopyrightCurrentYear">2021</span>. NVIDIA Corporation. All Rights Reserved.</span>
        </p>
    
</body></html>