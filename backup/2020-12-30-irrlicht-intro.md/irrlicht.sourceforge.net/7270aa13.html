<!--?xml version="1.0" encoding="iso-8859-1"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>Irrlicht Engine - A free open source 3d engine</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
<link rel="stylesheet" href="style.css" type="text/css" />
<!-- (c) 2005 by N.Gebhardt -->
</head>
<body>
<div align="center"><br />
  <table cellspacing="0" class="main">
    <tbody><tr> 
      <td colspan="2" class="logobar"><img alt="Irrlicht Engine logo" src="images/general/irrlichtlogo.gif" width="233" height="60" /></td>
    </tr>
    <tr> 
      <td colspan="2" class="linkbar"><a href="index.html">Home</a> | <a href="phpBB2/index.php">Forum</a> 
        | <a href="docu/index.html" target="_blank">API</a> | <a href="http://www.google.com/custom?domains=irrlicht.sourceforge.net&amp;sitesearch=irrlicht.sourceforge.net" target="_blank">Search</a></td>
    </tr>
    <tr> 
      <td class="sidebar"> <div class="sidebarentry"> 
          <p class="sideBarTitle">Engine</p>
          <a href="index.html">News</a> <a href="features.html">Features</a> <a href="screenshots.html">Screenshots</a> 
          <a href="downloads.html">Downloads</a> <a href="development.html">Development</a>
	  <a href="toolset.html">Tool set</a> 
        </div>
        <div class="sidebarentry"> 
          <p class="sideBarTitle">Documentation</p>
          <a href="faq.html">FAQ</a> <a href="docu/index.html" target="_blank">API</a> 
          <a href="docu.net/index.html" target="_blank">API.NET</a> <a href="tutorials.html">Tutorials</a> 
          <a href="license.html">License</a> <a href="newsarchive.html">News-Archive</a> 
          <a href="http://www.irrlicht3d.org/wiki" target="_blank">Wiki</a> </div>
        <div class="sidebarentry"> 
          <p class="sideBarTitle">Sourceforge</p>
          <a href="http://sourceforge.net/projects/irrlicht/">Project Page</a> 
          <a href="phpBB2/index.php">Forums</a>
	  <a href="shirts.html">Shirts</a> </div>
        <div class="sidebarentry"> 
          <p class="sideBarTitle">Contact</p>
          <a href="links.html">Links</a> <a href="author.html">Author</a> <a href="impressum.html">Impressum</a> </div>
        <p><a href="http://irrlicht.sourceforge.net"><br />
          <img alt="Irrlicht Engine logo button" src="images/general/irrlicht.png" width="88" height="31" border="0" /></a></p>
        <p><a href="http://sourceforge.net"> <img src="http://sourceforge.net/sflogo.php?group_id=74339&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a></p>
        <p> <a href="http://opensource.org/" target="_blank"><img alt="OSI Certified logo" src="images/general/osi-certified-72x60-t.png" width="72" height="60" border="0" /></a> 
        </p>
        <p>  </p></td>
      <td class="mainframe"> <table class="newsbox">
          <tbody><tr> 
            <td class="newscontent"><p><strong>Tutorial: Ageia PhysX &amp; Irrlicht 
                </strong>by Andrew J Santa Maria <br />
                Original tutorial can be found at: <a href="http://www.twilightstar.net/%7Eandrew/works/tutorial/irrlicht_physx/physxtutorial.htm" target="_blank">http://www.twilightstar.net/~andrew/works/tutorial/irrlicht_physx/physxtutorial.htm</a><br />
              </p>
              <p> <span style="font-family: Tahoma;"><span style="font-weight: bold;">Basic 
                Integration of Ageia PhysX (formerly called Novodex) with Irrlicht</span> 
                by Andrew J. "<a href="http://www.twilightstar.net/%7Eandrew/">andyZER0</a>" 
                Santa Maria<br />
                <br />
                I'm assuming you have:<br />
                </span> </p>
              <ul style="font-family: Tahoma;">
                <li><a href="http://irrlicht.sourceforge.net/downloads.html">Irrlicht 
                  SDK 0.14.0</a></li>
                <li><a href="http://ageia.com/developers/downloads.html">Ageia 
                  PhysX SDK 2.3.1</a></li>
                <li>Enough knowledge of C++ :) I won't spend time describing every 
                  single line of code.  (That's what comments are for right? 
                  :)  I'm hoping all the function names and variables are 
                  self explanatory.</li>
                <li>Your paths set up correctly pointing to the proper PhysX and 
                  Irrlicht headers etc.<br />
                </li>
              </ul>
              <span style="font-family: Tahoma;">You can download the sourcecode/binaries 
              used in this tutorial <a href="http://www.twilightstar.net/%7Eandrew/works/tutorial/irrlicht_physx.zip">here</a>. 
               Be aware that </span>the <span style="font-weight: bold;"><small style="font-family: Tahoma;">binaries</small></span> 
              provided in the tutorial <span style="font-weight: bold;"><small style="font-family: Tahoma;">rely 
              on .NET Framework 2.0</small></span>, so you may wanna compile it 
              for yourself if you don't have it.<span style="font-family: Tahoma;"> 
              <small style="font-family: Tahoma;"> I successfully compiled 
              this under <a href="http://msdn.microsoft.com/vstudio/">Microsoft 
              Visual C++ 2005 Express Edition</a>.  If you experience problems 
              with your compiler, you can <a href="mailto:andyzer0%5Bat%5Dgmail%5Bdot%5Dcom">email 
              me</a> and I'll see what I can do :)  Otherwise, the <a href="http://irrlicht.sourceforge.net/phpBB2/index.php">forums</a> 
              are a great resource too.<br />
              <br />
              This tutorial uses some existing and modified code from the PhysX 
              SDK 2.3.1 Training Program Beginner Lesson 101 written by Bob Schade. 
               <br />
              This tutorial uses a Quake3 map from Mercior's "<a href="http://www.mercior.com/tut-newton.shtml">Integrating 
              Newton Game Dynamics with Irrlicht</a>" tutorial.<br />
              It also uses a free wood texture from <a href="http://www.mayang.com/">http://www.mayang.com/</a><br />
              <br />
              <span style="font-weight: bold; text-decoration: underline;">Now 
              let's begin!</span><br />
              <br />
              We'll be using this libraries and including these headers<br />
              <br />
              <span style="font-family: Courier New;"></span></small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">#pragma 
                      comment(lib, "PhysXLoader.lib")</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">#pragma comment(lib, 
                      "NxCooking.lib")</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">#pragma comment(lib, 
                      "Irrlicht.lib")</span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">#include &lt;NxPhysics.h&gt;</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">#include &lt;NxCooking.h&gt;</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">#include &lt;Stream.h&gt;</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">#include &lt;irrlicht.h&gt;</span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><span style="font-family: Courier New;"></span><br />
              <span style="text-decoration: underline;"><span style="font-weight: bold;">Custom 
              Scene Node</span></span><br />
              <br />
              </small></span><span style="font-family: Tahoma;"><small style="font-family: Tahoma;">Using 
              code from the original Irrlicht engine SDK (in source.zip), we create 
              a new scene node similar to CAnimatedMeshSceneNode<br />
              <br />
              </small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">class 
                      CPhysXAnimatedMeshSceneNode : public IAnimatedMeshSceneNode;</span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><br />
              Give it some special variables<br />
              <br />
              </small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;">private:<br />
                          // NEW STUFF<br />
                          NxActor *Actor;<br />
                          bool PhysXControlled;</small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"></span><span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><br />
              Along with special functions...<br />
              <br />
              </small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">virtual 
                      bool isPhysXControlled() const { return PhysXControlled; 
                      }</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">virtual void setPhysXControlled(const 
                      bool &amp;controlled) { PhysXControlled = controlled; }</span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><br />
              The only difference between CPhysXAnimatedMeshSceneNode and the 
              original CAnimatedMeshSceneNode is the pointer to an NxActor and 
              a bool declaring whether or not the scenenode should be controlled 
              by PhysX.  Thus, you can assume the only other difference is 
              the constructor and a modified post render function to dynamically 
              reposition the scenenode.<br />
              <span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><br />
              </small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">CPhysXAnimatedMeshSceneNode(IAnimatedMesh* 
                      mesh, NxActor* actor, ISceneNode* parent, ISceneManager* 
                      mgr,    s32 id,</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                          const core::vector3df&amp; position = 
                      core::vector3df(0,0,0),</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                          const core::vector3df&amp; rotation = 
                      core::vector3df(0,0,0),</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                          const core::vector3df&amp; scale = core::vector3df(1.0f, 
                      1.0f, 1.0f));</span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">/***** moving along... 
                      you can find the rest of the code in the source :) ****/</span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">void CPhysXAnimatedMeshSceneNode::OnPreRender()<br />
                      {<br />
                          if (IsVisible)<br />
                          {<br />
                              // reorient/reposition 
                      the scene node every frame<br />
                              if (Actor &amp;&amp; 
                      !Actor-&gt;isSleeping() &amp;&amp; PhysXControlled)<br />
                              {<br />
                                  
                      // this code's from the Beginner Lesson 101 tutorial<br />
                                  
                      /* Ageia and PhysX, both stylized and non-stylized, are 
                      trademarks or registered trademarks <br />
                                  
                      of Ageia Technologies Inc. Copyright 2006 Ageia Technologies 
                      Inc. */<br />
                                  
                      // modified to use for a irrlicht matrix4<br />
                                  
                      NxMat34 pose = Actor-&gt;getGlobalPose();<br />
                      <br />
                                  
                      const NxVec3 pos = pose.t;<br />
                                  
                      const NxMat33 orient = pose.M;<br />
                                  
                      core::matrix4 irrMat; // a 4x4 matrix in the irrlicht engine<br />
                                  
                      orient.getColumnMajorStride4(&amp;irrMat.M[0]);<br />
                                  
                      pos.get(&amp;irrMat.M[12]);<br />
                                  
                      //clear the elements we don't need:<br />
                                  
                      irrMat.M[3] = irrMat.M[7] = irrMat.M[11] = 0.0f;<br />
                                  
                      irrMat.M[15] = 1.0f;<br />
                      <br />
                                  
                      // with that newly made matrix, let's use it to transform/rotate 
                      the node<br />
                                  
                      setPosition(irrMat.getTranslation());<br />
                                  
                      setRotation(irrMat.getRotationDegrees());<br />
                              }<br />
                              // because this node 
                      supports rendering of mixed mode meshes consisting of <br />
                              // transparent and 
                      solid material at the same time, we need to go through all 
                      <br />
                              // materials, check 
                      of what type they are and register this node for the right<br />
                              // render pass according 
                      to that.<br />
                      <br />
                              video::IVideoDriver* 
                      driver = SceneManager-&gt;getVideoDriver();<br />
                      <br />
                              PassCount = 0;<br />
                              int transparentCount 
                      = 0;<br />
                              int solidCount = 0;<br />
                      <br />
                              // count transparent 
                      and solid materials in this scene node<br />
                              for (u32 i=0; i&lt;Materials.size(); 
                      ++i)<br />
                              {<br />
                                  
                      video::IMaterialRenderer* rnd = <br />
                                  
                          driver-&gt;getMaterialRenderer(Materials[i].MaterialType);<br />
                      <br />
                                  
                      if (rnd &amp;&amp; rnd-&gt;isTransparent())<br />
                                  
                          ++transparentCount;<br />
                                  
                      else<br />
                                  
                          ++solidCount;<br />
                      <br />
                                  
                      if (solidCount &amp;&amp; transparentCount)<br />
                                  
                          break;<br />
                              }    
                      <br />
                      <br />
                              // register according 
                      to material types counted<br />
                              //! but first, check 
                      if it's in our camera's frustum before we decide we want 
                      to register for rendering<br />
                              if (SceneManager-&gt;getActiveCamera()-&gt;getViewFrustrum()-&gt;getBoundingBox().isPointInside(getPosition()))<br />
                              {<br />
                                  
                      if (solidCount)<br />
                                  
                          SceneManager-&gt;registerNodeForRendering(this, 
                      scene::ESNRP_SOLID);<br />
                      <br />
                                  
                      if (transparentCount)<br />
                                  
                          SceneManager-&gt;registerNodeForRendering(this, 
                      scene::ESNRP_TRANSPARENT);<br />
                              }<br />
                          }<br />
                      <br />
                          ISceneNode::OnPreRender();<br />
                      <br />
                          if (IsVisible)<br />
                              for (s32 i=0; i&lt;(s32)JointChildSceneNodes.size(); 
                      ++i)<br />
                                  
                      if (JointChildSceneNodes[i])<br />
                                  
                          JointChildSceneNodes[i]-&gt;OnPreRender();<br />
                      }</span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"> <small style="font-family: Tahoma;"><br />
              Then, to make things easier on ourselves, let's create a function 
              similar to addAnimatedMeshSceneNode.<br />
              <span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><br />
              </small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">IAnimatedMeshSceneNode* 
                      addPhysXAnimatedMeshSceneNode(IAnimatedMesh* mesh, NxActor* 
                      actor, ISceneNode* parent=0, s32 id=-1,</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                                  
                                  
                                  
                                  
                        const core::vector3df&amp; position = core::vector3df(0,0,0),    
                      const core::vector3df&amp; rotation = core::vector3df(0,0,0),    
                      const core::vector3df&amp; scale = core::vector3df(1.0f, 
                      1.0f, 1.0f))</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">{</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                      if (!mesh)</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                          return 0;</span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                      if (!parent)</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                          parent = smgr-&gt;getRootSceneNode();</span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                      IAnimatedMeshSceneNode* node = </span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                          new CPhysXAnimatedMeshSceneNode(mesh, 
                      actor, parent, smgr, id, position, rotation, scale);</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                      node-&gt;drop();</span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">    
                      return node;    </span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">}</span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"> <small style="font-family: Tahoma;"><br />
              <span style="font-weight: bold; text-decoration: underline;">Initialization 
              and Shuttin' Down functions</span><br />
              <br />
              Now that we have our new, dynamic scene node class ready to use, 
              let's declare some variables and create some functions that that'll 
              make everything work together. (pretty much the use for...every 
              function)<br />
              <span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><br />
              </small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">// 
                      Physics SDK globals<br />
                      NxPhysicsSDK*     gPhysicsSDK = NULL;    
                              // pointer to the 
                      SDK<br />
                      NxScene*          
                      gScene = NULL;            
                          // pointer to the scene<br />
                      NxVec3            
                      gDefaultGravity(0,-9.81f,0);    // NxVec3 
                      representing gravity<br />
                      <br />
                      // Force globals<br />
                      NxVec3 gForceVec(0,0,0);<br />
                      NxReal gForceStrength = 75000000.0f; // some force big enough 
                      to toss them balls and boxes around</span><span style="font-family: Courier New;"></span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">IAnimatedMesh *cubeMesh, 
                      *sphereMesh; // pointers to the actual cube and sphere meshes</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">ITexture *texture0, 
                      *texture1; // pointers to their textures</span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">////////////////////////////////////////////////////////</span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">// function to initialize 
                      PhysX</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">bool InitNx()<br />
                      {<br />
                          /* Ageia and PhysX, both stylized and 
                      non-stylized, are trademarks or registered trademarks <br />
                          of Ageia Technologies Inc. Copyright 
                      2006 Ageia Technologies Inc. */<br />
                      <br />
                          // Create the physics SDK<br />
                          gPhysicsSDK = NxCreatePhysicsSDK(NX_PHYSICS_SDK_VERSION);<br />
                          if (!gPhysicsSDK)  return false;<br />
                      <br />
                          // Set the physics parameters<br />
                          gPhysicsSDK-&gt;setParameter(NX_SKIN_WIDTH, 
                      0.0f); // usually 0.02<br />
                      <br />
                          // Set the debug visualization parameters<br />
                          gPhysicsSDK-&gt;setParameter(NX_VISUALIZATION_SCALE, 
                      1);<br />
                          gPhysicsSDK-&gt;setParameter(NX_VISUALIZE_COLLISION_SHAPES, 
                      1);<br />
                          gPhysicsSDK-&gt;setParameter(NX_VISUALIZE_ACTOR_AXES, 
                      1);<br />
                      <br />
                          // Create the scene<br />
                          NxSceneDesc sceneDesc;<br />
                          sceneDesc.gravity               
                      = gDefaultGravity;<br />
                          sceneDesc.broadPhase            
                      = NX_BROADPHASE_COHERENT;<br />
                          sceneDesc.collisionDetection    
                      = true;<br />
                          gScene = gPhysicsSDK-&gt;createScene(sceneDesc);<br />
                          if (!gScene)<br />
                              return false;<br />
                      <br />
                          // Create the default material<br />
                          NxMaterial* defaultMaterial = gScene-&gt;getMaterialFromIndex(0); 
                      <br />
                          defaultMaterial-&gt;setRestitution(0.125f); 
                      //! 0.5<br />
                          defaultMaterial-&gt;setStaticFriction(0.5f); 
                      //! 0.5<br />
                          defaultMaterial-&gt;setDynamicFriction(0.5f); 
                      //! 0.5<br />
                      <br />
                          // Get the current time<br />
                          UpdateTime();<br />
                      <br />
                          // Start the first frame of the simulation<br />
                          StartPhysics();<br />
                      <br />
                          return true;<br />
                      }</span><span style="font-family: Courier New;"></span><br style="font-family: Courier New;" />
                      <br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">// run this to close 
                      it</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">void ReleaseNx()<br />
                      {<br />
                          /* Ageia and PhysX, both stylized and 
                      non-stylized, are trademarks or registered trademarks <br />
                          of Ageia Technologies Inc. Copyright 
                      2006 Ageia Technologies Inc. */<br />
                          if (gScene)<br />
                          {<br />
                              //GetPhysicsResults();  
                      // Make sure to fetchResults() before shutting down<br />
                              gPhysicsSDK-&gt;releaseScene(*gScene);<br />
                          }<br />
                          if (gPhysicsSDK)  gPhysicsSDK-&gt;release();<br />
                      }</span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><br />
              <span style="text-decoration: underline;"><span style="font-weight: bold;">Per 
              Frame Operations</span></span><br />
              <br />
              Next, we create functions to execute every frame to </small></span><span style="font-family: Tahoma;"><small style="font-family: Tahoma;">perform 
              physical simulation, </small></span><span style="font-family: Tahoma;"><small style="font-family: Tahoma;">get 
              some time based movement, and what not.<br />
              <br style="font-family: Courier New;" />
              <span style="font-family: Courier New;"></span></small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">NxReal 
                      UpdateTime()<br />
                      {<br />
                          /* Ageia and PhysX, both stylized and 
                      non-stylized, are trademarks or registered trademarks <br />
                                  
                         of Ageia Technologies Inc. Copyright 2006 Ageia 
                      Technologies Inc. */<br />
                          NxReal deltaTime;<br />
                      #ifndef LINUX<br />
                          static __int64 gTime,gLastTime;<br />
                          __int64 freq;<br />
                          QueryPerformanceCounter((LARGE_INTEGER 
                      *)&amp;gTime);  // Get current count<br />
                          QueryPerformanceFrequency((LARGE_INTEGER 
                      *)&amp;freq); // Get processor freq<br />
                          deltaTime = (double)(gTime - gLastTime)/(double)freq;<br />
                      #else<br />
                          static clock_t gTime, gLastTime;<br />
                          gTime = clock();<br />
                          deltaTime = (NxReal)((double)(gTime - 
                      gLastTime) / 1000000.0f);<br />
                      #endif<br />
                          gLastTime = gTime;<br />
                          return deltaTime;<br />
                      }<br />
                      <br />
                      // run this every frame<br />
                      void StartPhysics()<br />
                      {<br />
                          /* Ageia and PhysX, both stylized and 
                      non-stylized, are trademarks or registered trademarks<br />
                          of Ageia Technologies Inc. Copyright 
                      2006 Ageia Technologies Inc. */<br />
                          // Update the time step<br />
                          NxReal deltaTime = UpdateTime();<br />
                      <br />
                          // Start collision and dynamics for delta 
                      time since the last frame<br />
                          gScene-&gt;simulate(deltaTime * 5.0f); 
                      // i multiply by five for more faster, realistic looking 
                      dynamics<br />
                          gScene-&gt;flushStream();<br />
                      }<br />
                      <br />
                      // this too<br />
                      void GetPhysicsResults()<br />
                      {<br />
                          /* Ageia and PhysX, both stylized and 
                      non-stylized, are trademarks or registered trademarks<br />
                          of Ageia Technologies Inc. Copyright 
                      2006 Ageia Technologies Inc. */<br />
                          // Get results from gScene-&gt;simulate(deltaTime)<br />
                          while (!gScene-&gt;fetchResults(NX_RIGID_BODY_FINISHED, 
                      false));<br />
                      }</span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><br />
              <span style="text-decoration: underline;"><span style="font-weight: bold;">Entity 
              Creation</span></span><br />
              <br />
              Then, we use these functions to create either boxes or cubes to 
              throw around in the environment.<br />
              <br />
              <span style="font-family: Courier New;"></span></small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">NxActor* 
                      CreateBox(const core::vector3df &amp;pos, const core::vector3df 
                      &amp;scale = core::vector3df(1.0f,1.0f,1.0f))<br />
                      {<br />
                          /* Ageia and PhysX, both stylized and 
                      non-stylized, are trademarks or registered trademarks <br />
                          of Ageia Technologies Inc. Copyright 
                      2006 Ageia Technologies Inc. */<br />
                          // function slightly modified to modify 
                      dimensions/scale<br />
                      <br />
                          // Add a single-shape actor to the scene<br />
                          NxActorDesc actorDesc;<br />
                          NxBodyDesc bodyDesc;<br />
                          bodyDesc.angularDamping = 0.5f;<br />
                      <br />
                          // The actor has one shape, a box, 1m 
                      on a side<br />
                          NxBoxShapeDesc boxDesc;<br />
                          boxDesc.dimensions.set(scale.X,scale.Y,scale.Z); 
                      // should be 0.5<br />
                          actorDesc.shapes.pushBack(&amp;boxDesc);<br />
                      <br />
                          actorDesc.body = &amp;bodyDesc;<br />
                          actorDesc.density = 1.0f;<br />
                          actorDesc.globalPose.t = NxVec3(pos.X,pos.Y,pos.Z);<br />
                          return gScene-&gt;createActor(actorDesc);    
                      <br />
                      }<br />
                      <br />
                      NxActor* CreateSphere(const core::vector3df &amp;pos, const 
                      f32 &amp;radius = 1.0f)<br />
                      {<br />
                          /* Ageia and PhysX, both stylized and 
                      non-stylized, are trademarks or registered trademarks <br />
                          of Ageia Technologies Inc. Copyright 
                      2006 Ageia Technologies Inc. */<br />
                          // function slightly modified to create 
                      spheres<br />
                      <br />
                          // Add a single-shape actor to the scene<br />
                          NxActorDesc actorDesc;<br />
                          NxBodyDesc bodyDesc;<br />
                          bodyDesc.angularDamping = 0.5f;<br />
                      <br />
                          // The actor has one shape, a box, 1m 
                      on a side<br />
                          NxSphereShapeDesc sphereDesc;<br />
                          sphereDesc.radius = radius; // should 
                      be 0.5<br />
                          actorDesc.shapes.pushBack(&amp;sphereDesc);<br />
                      <br />
                          actorDesc.body = &amp;bodyDesc;<br />
                          actorDesc.density = 1.0f;<br />
                          actorDesc.globalPose.t = NxVec3(pos.X,pos.Y,pos.Z);<br />
                          return gScene-&gt;createActor(actorDesc);    
                      <br />
                      }<br />
                      </span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><br />
              Then, we have a function to load a Quake 3 map and properly convert 
              it into a PMAP to use for PhysX.  This way, efficient collisions 
              can be performed with the entities against the actual map.<br />
              <br />
              <span style="font-family: Courier New;"></span></small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">NxActor 
                      *CreateQuake3Map(IAnimatedMesh *q3map, const vector3df &amp;pos 
                      = vector3df(0.0f,0.0f,0.0f), const core::vector3df &amp;scale 
                      = core::vector3df(1.0f,1.0f,1.0f))<br />
                      {<br />
                          if (!q3map)<br />
                              return NULL;<br />
                      <br />
                          // retrieve how many meshes there are<br />
                          irr::s32 meshBufferCount = q3map-&gt;getMesh(0)-&gt;getMeshBufferCount();<br />
                      <br />
                          core::array&lt;NxVec3&gt; vertices; // 
                      used for allocating vertices<br />
                          core::array&lt;NxU32&gt; indices; // 
                      used for allocating indices<br />
                      <br />
                          NxU32 tempIndexCount = 0; // used for 
                      offsetting indices<br />
                      <br />
                          for (int i = 0; i &lt; meshBufferCount; 
                      ++i)<br />
                          {<br />
                              // pointer to the 
                      map's mesh buffer<br />
                              IMeshBuffer *mb = 
                      q3map-&gt;getMesh(0)-&gt;getMeshBuffer(i); // for every 
                      mesh buffer<br />
                      <br />
                              s32 numVertices = 
                      mb-&gt;getVertexCount(); // get vertex num every mesh buffer<br />
                              s32 numIndices = mb-&gt;getIndexCount(); 
                      // get index num every mesh buffer<br />
                      <br />
                              video::S3DVertex2TCoords 
                      *mbVertices = (irr::video::S3DVertex2TCoords*)mb-&gt;getVertices(); 
                      // get pointer to vertices in the mesh buffer<br />
                              irr::u16 *mbIndices 
                      = mb-&gt;getIndices(); // get pointer to indices in the 
                      mesh buffer<br />
                      <br />
                              for (int j = 0; j 
                      &lt; numVertices; ++j) // push vertices into an array<br />
                                  
                      vertices.push_back(NxVec3(mbVertices[j].Pos.X * scale.X, 
                      mbVertices[j].Pos.Y * scale.Y, mbVertices[j].Pos.Z * scale.Z));<br />
                      <br />
                              for (int j = 0; j 
                      &lt; numIndices; ++j) // push indices into an array<br />
                                  
                      indices.push_back(NxU32(mbIndices[j]) + tempIndexCount);<br />
                      <br />
                              // the q3 map when 
                      loaded into irrlicht, is divided into multiply mesh buffers.<br />
                              // we want the sum 
                      of all mesh buffer indices.  this way, when it's loaded 
                      into physx<br />
                              // it's offsetted 
                      correctly instead of the bug i previously had where it indices 
                      only<br />
                              // pointed to the 
                      first 400 or whatever vertices because each set of indices 
                      pointed to only<br />
                              // its own pair of 
                      vertices in the mesh buffer.<br />
                              tempIndexCount += 
                      numIndices;<br />
                          }<br />
                      <br />
                          NxPMap q3mapPMap;<br />
                          q3mapPMap.dataSize    
                      = 0;<br />
                          q3mapPMap.data        
                      = NULL;<br />
                          NxTriangleMeshDesc mapMeshDesc; //  
                      mesh description<br />
                          // Build physical model<br />
                          mapMeshDesc.numVertices = vertices.size();    
                      <br />
                          mapMeshDesc.numTriangles = indices.size() 
                      / 3;<br />
                          mapMeshDesc.pointStrideBytes = sizeof(NxVec3);   
                      <br />
                          mapMeshDesc.triangleStrideBytes = 3*sizeof(NxU32);    
                      <br />
                          mapMeshDesc.points = vertices.const_pointer();    
                      <br />
                          mapMeshDesc.triangles = indices.const_pointer();    
                      <br />
                          mapMeshDesc.flags = 0;<br />
                          cout &lt;&lt; endl &lt;&lt; mapMeshDesc.numVertices 
                      &lt;&lt; " vertices.\n";<br />
                          cout &lt;&lt; indices.size() &lt;&lt; 
                      " indices.\n";<br />
                          cout &lt;&lt; mapMeshDesc.numTriangles 
                      &lt;&lt; " triangles.\n";<br />
                      <br />
                          MemoryWriteBuffer buf;<br />
                          NxCookTriangleMesh(mapMeshDesc, buf);<br />
                          MemoryReadBuffer readBuffer(buf.data);<br />
                          NxTriangleMesh *q3mapTriangleMesh = gPhysicsSDK-&gt;createTriangleMesh(readBuffer);<br />
                      <br />
                          // PMap stuff<br />
                          // Try loading PMAP from disk<br />
                          fstream file("q3map.pmap",ios::in|ios::binary|ios::ate);<br />
                          if (!file.good()) // if the file doesn't 
                      exist, we write ourselves a new PMAP<br />
                          {<br />
                              file.close(); // close 
                      it.  it failed :(<br />
                      <br />
                              file.clear();// CLEAR 
                      THEM FLAGS!!  (so we can attempt opening again properly)<br />
                      <br />
                              cout &lt;&lt; "Please 
                      wait while precomputing pmap...\n";<br />
                              file.open("q3map.pmap",ios::out|ios::binary|ios::trunc);<br />
                              if(NxCreatePMap(q3mapPMap, 
                      *q3mapTriangleMesh, 64))<br />
                              {<br />
                                  
                      // The pmap has successfully been created, save it to disk 
                      for later use<br />
                                  
                      if (file.good())<br />
                                  
                      {<br />
                                  
                          cout &lt;&lt; "writing data size:\t" 
                      &lt;&lt; q3mapPMap.dataSize &lt;&lt; endl;<br />
                                  
                          file.write((char*)q3mapPMap.data, q3mapPMap.dataSize);<br />
                                  
                      }<br />
                                  
                      else<br />
                                  
                          cout &lt;&lt; "Unable to write to file.\n";<br />
                      <br />
                                  
                      //assign pmap to mesh<br />
                                  
                      q3mapTriangleMesh-&gt;loadPMap(q3mapPMap);<br />
                      <br />
                                  
                      // sdk created data =&gt; sdk deletes it<br />
                                  
                      NxReleasePMap(q3mapPMap);<br />
                              }<br />
                      <br />
                              file.close();<br />
                          }<br />
                          else<br />
                          {<br />
                              cout &lt;&lt; "Found 
                      pmap and using it...\n";<br />
                              // Found pmap file<br />
                              q3mapPMap.dataSize    
                      = file.tellg(); //getFileSize("q3map.pmap");<br />
                              file.seekg(0,ios::beg);<br />
                              cout &lt;&lt; "reading 
                      data size:\t" &lt;&lt; q3mapPMap.dataSize &lt;&lt; endl;<br />
                              q3mapPMap.data    
                          = new NxU8[q3mapPMap.dataSize];<br />
                              file.read((char*)q3mapPMap.data, 
                      q3mapPMap.dataSize);//fread(q3mapPMap.data, q3mapPMap.dataSize, 
                      1, fp);<br />
                              file.close();<br />
                      <br />
                              //assign pmap to mesh<br />
                              q3mapTriangleMesh-&gt;loadPMap(q3mapPMap);<br />
                      <br />
                              //we created data 
                      =&gt; we delete it<br />
                              delete [] q3mapPMap.data;<br />
                          }<br />
                      <br />
                          NxTriangleMeshShapeDesc mapMeshShapeDesc;<br />
                          mapMeshShapeDesc.meshData = q3mapTriangleMesh;<br />
                          NxActorDesc actorDesc;<br />
                          actorDesc.shapes.pushBack(&amp;mapMeshShapeDesc);<br />
                          actorDesc.globalPose.t = NxVec3(pos.X,pos.Y,pos.Z);<br />
                          indices.clear();<br />
                          vertices.clear();<br />
                      <br />
                          return gScene-&gt;createActor(actorDesc);<br />
                      }</span></span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><span style="font-family: Courier New;"></span><span style="font-family: Courier New;"></span><br />
              Finally, whenever we left-click, we shoot out some spheres or boxes 
              (depending if the variable sphereOrCube has a remainder when divided 
              by 2).<br />
              <span style="font-family: Courier New;"></span><br />
              </small></span> <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
                <tbody>
                  <tr> 
                    <td><small style="font-family: Tahoma;"><span style="font-family: Tahoma;"><span style="font-family: Courier New;">irr::u16 
                      sphereOrCube = 0;</span><br style="font-family: Courier New;" />
                      <span style="font-family: Courier New;">bool createShape(const 
                      vector3df &amp;position = camera-&gt;getPosition(), const 
                      vector3df &amp;target = camera-&gt;getTarget(), const bool 
                      &amp;applyForce = true)<br />
                      {<br />
                          NxActor *newActor; // pointer to newly 
                      created object<br />
                          IAnimatedMeshSceneNode *newNode; // pointer 
                      to its scene node<br />
                      <br />
                          core::vector3df irrDir = (target - position).normalize(); 
                      // get and normalize the direction<br />
                          f32 dim = 20.0f; // the typical dimension/radius 
                      is 20<br />
                      <br />
                          // we're either shooting out cubes or 
                      spheres<br />
                          if (!(sphereOrCube % 2))<br />
                          {<br />
                              newActor = CreateBox(position, 
                      vector3df(dim,dim,dim));<br />
                              if (!newActor)<br />
                                  
                      return false;<br />
                      <br />
                              newNode = addPhysXAnimatedMeshSceneNode(cubeMesh,newActor);<br />
                              newNode-&gt;setMaterialTexture(0, 
                      texture0);<br />
                          }<br />
                          else<br />
                          {<br />
                              newActor = CreateSphere(position,dim);<br />
                              if (!newActor)<br />
                                  
                      return false;<br />
                      <br />
                              newNode = addPhysXAnimatedMeshSceneNode(sphereMesh,newActor);<br />
                              newNode-&gt;setMaterialTexture(0, 
                      texture1);<br />
                          }<br />
                      <br />
                          newNode-&gt;setMaterialFlag(EMF_LIGHTING, 
                      true);<br />
                          newNode-&gt;setScale(core::vector3df(dim,dim,dim));<br />
                          //newNode-&gt;addShadowVolumeSceneNode();<br />
                      <br />
                          if (applyForce)<br />
                              ApplyForceToActor(newActor,NxVec3(irrDir.X, 
                      irrDir.Y, irrDir.Z),gForceStrength); // apply force to "shoot" 
                      it<br />
                      <br />
                          return true;<br />
                      }</span><span style="font-family: Courier New;"></span><br style="font-family: Courier New;" />
                      </span></small></td>
                  </tr>
                </tbody>
              </table>
              <span style="font-family: Tahoma;"><small style="font-family: Tahoma;"><br />
              So that's all you really need to use PhysX in your Irrlicht applications. 
               The full source/binaries is included <a href="http://www.twilightstar.net/%7Eandrew/works/tutorial/irrlicht_physx.zip">here</a>. 
               This is my first tutorial, so if you need any clarification, 
              just <a href="mailto:andyzer0%5Bat%5Dgmail%5Bdot%5Dcom">email me</a> 
              or message me on AIM--my screenname is <span style="font-weight: bold;">dr0wsy 
              MANdrew</span>.  Enjoy some physics in Irrlicht :)<br />
              <br />
              <br />
              </small></span> <br /> <font color="black" face="Arial" size="2"><small style="font-family: Tahoma;"><span style="font-size: 10pt; font-family: Arial; color: black;"><a href="http://www.ageia.com">Ageia</a> 
              and PhysX, both stylized and non-stylized, are trademarks or registered 
              trademarks of Ageia Technologies Inc. Copyright 2006 Ageia Technologies 
              Inc.</span></small></font> <p>  </p>
              <p>  </p>
              </td>
          </tr>
        </tbody></table>
        <p> </p>
        <p> </p></td>
    </tr>
  </tbody></table>  
  <div align="right"><br />
    <a href="http://validator.w3.org/check?uri=referer" target="_blank"><img src="images/general/valid-xhtml10.png" alt="Valid XHTML 1.0!" width="88" height="31" border="0" /></a> 
    <a href="http://jigsaw.w3.org/css-validator/" target="_blank"><img src="images/general/vcss.gif" alt="Valid CSS!" width="88" height="31" border="0" /></a></div>
</div>
<p class="copyrighttext"><br />
  Irrlicht Engine and Irrlicht Engine webpage © 2003-2005 by Nikolaus Gebhardt</p>


</body></html>