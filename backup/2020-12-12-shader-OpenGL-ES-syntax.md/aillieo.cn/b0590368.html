<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aillieo.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"EM0NG1L32X","apiKey":"862c62ca101f920300ddfebb30fcba33","indexName":"aillieo-collection","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文讲解着色语言GL Shader Language（GLSL）的一些基本的概念，如无特殊说明，文中的GLSL均指OpenGL ES的着色语言。本文是基于OpenGL ES 2.0。">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL ES 2.0 着色器语言GLSL（一）">
<meta property="og:url" content="http://aillieo.cn/post/2017-01-15-opengl-es-glsl-01/index.html">
<meta property="og:site_name" content="Aillieo Collection">
<meta property="og:description" content="本文讲解着色语言GL Shader Language（GLSL）的一些基本的概念，如无特殊说明，文中的GLSL均指OpenGL ES的着色语言。本文是基于OpenGL ES 2.0。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-01-15T11:42:56.000Z">
<meta property="article:modified_time" content="2020-07-09T16:06:33.042Z">
<meta property="article:author" content="Aillieo">
<meta property="article:tag" content="OpenGL">
<meta property="article:tag" content="OpenGL ES">
<meta property="article:tag" content="GLSL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://aillieo.cn/post/2017-01-15-opengl-es-glsl-01/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>OpenGL ES 2.0 着色器语言GLSL（一） | Aillieo Collection</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aillieo Collection</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">SUBTITLE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://aillieo.cn/post/2017-01-15-opengl-es-glsl-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aillieo">
      <meta itemprop="description" content="PROGRAMMING | GAMES | DESIGN">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aillieo Collection">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OpenGL ES 2.0 着色器语言GLSL（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-15 19:42:56" itemprop="dateCreated datePublished" datetime="2017-01-15T19:42:56+08:00">2017-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-10 00:06:33" itemprop="dateModified" datetime="2020-07-10T00:06:33+08:00">2020-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ComputerGraphics/" itemprop="url" rel="index"><span itemprop="name">ComputerGraphics</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ComputerGraphics/OpenGL-ES/" itemprop="url" rel="index"><span itemprop="name">OpenGL ES</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文讲解着色语言GL Shader Language（GLSL）的一些基本的概念，如无特殊说明，文中的GLSL均指OpenGL ES的着色语言。本文是基于OpenGL ES 2.0。</p>
<a id="more"></a>

<h2 id="GLSL概览"><a href="#GLSL概览" class="headerlink" title="GLSL概览"></a>GLSL概览</h2><p>OpenGL ES的渲染管线包含有一个可编程的顶点阶段的一个可编程的片段阶段。其余的阶段则有固定的功能，应用程序对其行为的控制非常有限。每个可编程阶段中编译单元的集合组成了一个着色器。在OpenGL ES 2.0中，每个着色器只支持一个编译单元。着色程序则是一整套编译好并链接在一起的着色器的集合。着色器shader的编写需要使用着色语言GL Shader Language（GLSL），GLSL的语法与C语言很类似。</p>
<h2 id="使用GLSL构建着色器"><a href="#使用GLSL构建着色器" class="headerlink" title="使用GLSL构建着色器"></a>使用GLSL构建着色器</h2><h3 id="变量及变量类型"><a href="#变量及变量类型" class="headerlink" title="变量及变量类型"></a>变量及变量类型</h3><table>
<thead>
<tr>
<th align="left">变量类别</th>
<th align="left">变量类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">空</td>
<td align="left">void</td>
<td align="left">用于无返回值的函数或空的参数列表</td>
</tr>
<tr>
<td align="left">标量</td>
<td align="left">float, int, bool</td>
<td align="left">浮点型，整型，布尔型的标量数据类型</td>
</tr>
<tr>
<td align="left">浮点型向量</td>
<td align="left">float, vec2, vec3, vec4</td>
<td align="left">包含1，2，3，4个元素的浮点型向量</td>
</tr>
<tr>
<td align="left">整数型向量</td>
<td align="left">int, ivec2, ivec3, ivec4</td>
<td align="left">包含1，2，3，4个元素的整型向量</td>
</tr>
<tr>
<td align="left">布尔型向量</td>
<td align="left">bool, bvec2, bvec3, bvec4</td>
<td align="left">包含1，2，3，4个元素的布尔型向量</td>
</tr>
<tr>
<td align="left">矩阵</td>
<td align="left">mat2, mat3, mat4</td>
<td align="left">尺寸为2x2，3x3，4x4的浮点型矩阵</td>
</tr>
<tr>
<td align="left">纹理句柄</td>
<td align="left">sampler2D, samplerCube</td>
<td align="left">表示2D，立方体纹理的句柄</td>
</tr>
</tbody></table>
<p>除上述之外，着色器中还可以将它们构成数组或结构体，以实现更复杂的数据类型。在GLSL中没有指针类型。</p>
<h3 id="变量构造器及类型转换"><a href="#变量构造器及类型转换" class="headerlink" title="变量构造器及类型转换"></a>变量构造器及类型转换</h3><p>对于类型转换，OpenGl ES SL中有非常严格的规则，即只有类型一致时，变量才能完成赋值或其它对应的操作。为了实现类型转换，在GLSL中有多重构造器可以使用。构造器可以用来初始化变量，也可以用来在不同类型之间进行转换。使用构造器对变量的初始化可以在声明时进行，也可以稍后在着色器中完成。每种内置的类型都有一些相对应的构造器。</p>
<p>首先考虑使用构造器对标量的初始化和类型转换，参考如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> myFloat = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">bool</span> myBool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> myInt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">myFloat = <span class="keyword">float</span>(myBool); <span class="comment">// Convert from bool -&gt; float</span></span><br><span class="line">myFloat = <span class="keyword">float</span>(myInt); <span class="comment">// Convert from int -&gt; float</span></span><br><span class="line">myBool = <span class="keyword">bool</span>(myInt); <span class="comment">// Convert from int -&gt; bool</span></span><br></pre></td></tr></table></figure>
<p>与此相似，构造器也可以用来初始化和转换矢量的数据类型。</p>
<p>当构造矢量时，矢量构造器中的各参数将会被转换成相同的类型（浮点型、整型或布尔型）。向矢量构造器中传递参数有两种形式：</p>
<ul>
<li>如果矢量构造器中只提供了一个标量参数，则矢量中所有值都会设定为该标量值</li>
<li>如果提供了多个标量值或提供了矢量参数，则会从左至右使用提供的参数来给矢量赋值，如果使用多个标量来赋值，则需要确保标量的个数要多于矢量构造器中的个数</li>
</ul>
<p>矢量构造器用法可参考以下示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec4 myVec4 = vec4(<span class="number">1.0</span>); <span class="comment">// myVec4 = &#123;1.0, 1.0, 1.0, 1.0&#125;</span></span><br><span class="line"></span><br><span class="line">vec3 myVec3 = vec3(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>); <span class="comment">// myVec3 = &#123;1.0, 0.0, 0.5&#125;</span></span><br><span class="line"></span><br><span class="line">vec3 temp = vec3(myVec3); <span class="comment">// temp = myVec3</span></span><br><span class="line">vec2 myVec2 = vec2(myVec3); <span class="comment">// myVec2 = &#123;myVec3.x, myVec3.y&#125;</span></span><br><span class="line"></span><br><span class="line">myVec4 = vec4(myVec2, temp, <span class="number">0.0</span>); <span class="comment">// myVec4 = &#123;myVec2.x, myVec2.y , temp, 0.0 &#125;</span></span><br></pre></td></tr></table></figure>

<p>矩阵的构造方法相对灵活，有以下规则：</p>
<ul>
<li>如果对矩阵构造器只提供了一个标量参数，该值会作为矩阵的对角线上的值。例如<code>mat4(1.0)</code>可以构造一个4 × 4的单位矩阵</li>
<li>矩阵可以通过多个矢量作为参数来构造，例如一个mat2可以通过两个vec2来构造</li>
<li>矩阵可以通过多个标量作为参数来构造，矩阵中每个值对应一个标量，按照从左到右的顺序</li>
</ul>
<p>除此之外，矩阵的构造方法还可以更灵活，只要有足够的组件来初始化矩阵，其构造器参数可以是标量和矢量的组合。在OpenGL ES中，矩阵的值会以列的顺序来存储。在构造矩阵时，构造器参数会按照列的顺序来填充矩阵，具体可参考以下示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mat3 myMat3 = mat3(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="comment">// First column</span></span><br><span class="line">                   <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="comment">// Second column</span></span><br><span class="line">                   <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); <span class="comment">// Third column</span></span><br></pre></td></tr></table></figure>

<h3 id="矢量和矩阵的分量"><a href="#矢量和矩阵的分量" class="headerlink" title="矢量和矩阵的分量"></a>矢量和矩阵的分量</h3><p>单独获得矢量中的组件有两种方法：即使用<code>&quot;.&quot;</code>符号或使用数组下标方法。依据构成矢量的组件个数，矢量的组件可以通过<code>{x, y, z, w}</code>，<code>{r, g, b, a}</code>或<code>{s, t, r, q}</code>等swizzle操作来获取。之所以采用这三种不同的命名方法，是因为矢量常常会用来表示数学矢量、颜色、纹理坐标等。其中的<code>x</code>、<code>r</code>、<code>s</code>组件总是表示矢量中的第一个元素，如下表：</p>
<table>
<thead>
<tr>
<th>分量访问符</th>
<th>符号描述</th>
</tr>
</thead>
<tbody><tr>
<td>(x,y,z,w)</td>
<td>与位置相关的分量</td>
</tr>
<tr>
<td>(r,g,b,a)</td>
<td>与颜色相关的分量</td>
</tr>
<tr>
<td>(s,t,p,q)</td>
<td>与纹理坐标相关的分量</td>
</tr>
</tbody></table>
<p>不同的命名约定是为了方便使用，在使用矢量时不能混用不同的命名约定，即不能使用<code>.xgr</code>这样的方式，每次只能使用同一种命名约定。当使用<code>&quot;.&quot;</code>操作符时，还可以对矢量中的元素重新排序，参考以下示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec3 myVec3 = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">// myVec3 = &#123;0.0, 1.0, 2.0&#125;</span></span><br><span class="line">vec3 temp;</span><br><span class="line">temp = myVec3.xyz; <span class="comment">// temp = &#123;0.0, 1.0, 2.0&#125;</span></span><br><span class="line">temp = myVec3.xxx; <span class="comment">// temp = &#123;0.0, 0.0, 0.0&#125;</span></span><br><span class="line">temp = myVec3.zyx; <span class="comment">// temp = &#123;2.0, 1.0, 0.0&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了使用<code>&quot;.&quot;</code>操作符之外，还可以使用数组下标操作。在使用数组下标操作时，元素<code>[0]</code>对应的是<code>x</code>，元素<code>[1]</code>对应<code>y</code>，以此类推。值得注意的是，在OpenGL ES 2.0中的某些情况下，数组下标不支持使用非常数的整型表达式（如使用整型变量索引），这是因为对于矢量的动态索引操作，某些硬件设备处理起来很困难。在OpenGL ES 2.0中仅对uniform类型的变量支持这种动态索引。</p>
<p>矩阵可以认为是矢量的组合。例如一个mat2可以认为是两个vec2，一个mat3可以认为是三个vec3等等。对于矩阵来说，可以通过数组下标<code>“[]”</code>来获取某一列的值，然后获取到的矢量又可以继续使用矢量的操作方法，可参考以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mat4 myMat4 = mat4(<span class="number">1.0</span>); <span class="comment">// Initialize diagonal to 1.0 (identity)</span></span><br><span class="line">vec4 col0 = myMat4[<span class="number">0</span>]; <span class="comment">// Get col0 vector out of the matrix </span></span><br><span class="line"><span class="keyword">float</span> m1_1 = myMat4[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// Get element at [1][1] in matrix </span></span><br><span class="line"><span class="keyword">float</span> m2_2 = myMat4[<span class="number">2</span>].z; <span class="comment">// Get element at [2][2] in matrix</span></span><br></pre></td></tr></table></figure>

<h3 id="矢量和矩阵的操作"><a href="#矢量和矩阵的操作" class="headerlink" title="矢量和矩阵的操作"></a>矢量和矩阵的操作</h3><p>绝大多数情况下，矢量和矩阵的计算是逐分量进行的（component-wise）。当运算符作用于矢量或矩阵时，该运算独立地作用于矢量或矩阵的每个分量。<br>以下是一些示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec3 v, u;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line">v = u + f;</span><br></pre></td></tr></table></figure>
<p>等效于： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.x = u.x + f;</span><br><span class="line">v.y = u.y + f;</span><br><span class="line">v.z = u.z + f;</span><br></pre></td></tr></table></figure>
<p>再如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec3 v, u, w;</span><br><span class="line">w = v + u;</span><br></pre></td></tr></table></figure>
<p>等效于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w.x = v.x + u.x;</span><br><span class="line">w.y = v.y + u.y;</span><br><span class="line">w.z = v.z + u.z;</span><br></pre></td></tr></table></figure>

<p>对于整型和浮点型的矢量和矩阵，绝大多数的计算都同上，但是对于矢量乘以矩阵、矩阵乘以矢量、矩阵乘以矩阵则是不同的计算规则。这三种计算使用线性代数的乘法规则，并且要求参与计算的运算数值有相匹配的尺寸或阶数。<br>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec3 v, u;</span><br><span class="line">mat3 m;</span><br><span class="line">u = v * m;</span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u.x = dot(v, m[<span class="number">0</span>]); <span class="comment">// m[0] is the left column of m</span></span><br><span class="line">u.y = dot(v, m[<span class="number">1</span>]); <span class="comment">// dot(a,b) is the inner (dot) product of a and b</span></span><br><span class="line">u.z = dot(v, m[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>再如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u = m * v;</span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u.x = m[<span class="number">0</span>].x * v.x + m[<span class="number">1</span>].x * v.y + m[<span class="number">2</span>].x * v.z;</span><br><span class="line">u.y = m[<span class="number">0</span>].y * v.x + m[<span class="number">1</span>].y * v.y + m[<span class="number">2</span>].y * v.z;</span><br><span class="line">u.z = m[<span class="number">0</span>].z * v.x + m[<span class="number">1</span>].z * v.y + m[<span class="number">2</span>].z * v.z;</span><br></pre></td></tr></table></figure>
<p>再如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mat m, n, r;</span><br><span class="line">r = m * n;</span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r[<span class="number">0</span>].x = m[<span class="number">0</span>].x * n[<span class="number">0</span>].x + m[<span class="number">1</span>].x * n[<span class="number">0</span>].y + m[<span class="number">2</span>].x * n[<span class="number">0</span>].z;</span><br><span class="line">r[<span class="number">1</span>].x = m[<span class="number">0</span>].x * n[<span class="number">1</span>].x + m[<span class="number">1</span>].x * n[<span class="number">1</span>].y + m[<span class="number">2</span>].x * n[<span class="number">1</span>].z;</span><br><span class="line">r[<span class="number">2</span>].x = m[<span class="number">0</span>].x * n[<span class="number">2</span>].x + m[<span class="number">1</span>].x * n[<span class="number">2</span>].y + m[<span class="number">2</span>].x * n[<span class="number">2</span>].z;</span><br><span class="line">r[<span class="number">0</span>].y = m[<span class="number">0</span>].y * n[<span class="number">0</span>].x + m[<span class="number">1</span>].y * n[<span class="number">0</span>].y + m[<span class="number">2</span>].y * n[<span class="number">0</span>].z;</span><br><span class="line">r[<span class="number">1</span>].y = m[<span class="number">0</span>].y * n[<span class="number">1</span>].x + m[<span class="number">1</span>].y * n[<span class="number">1</span>].y + m[<span class="number">2</span>].y * n[<span class="number">1</span>].z;</span><br><span class="line">r[<span class="number">2</span>].y = m[<span class="number">0</span>].y * n[<span class="number">2</span>].x + m[<span class="number">1</span>].y * n[<span class="number">2</span>].y + m[<span class="number">2</span>].y * n[<span class="number">2</span>].z;</span><br><span class="line">r[<span class="number">0</span>].z = m[<span class="number">0</span>].z * n[<span class="number">0</span>].x + m[<span class="number">1</span>].z * n[<span class="number">0</span>].y + m[<span class="number">2</span>].z * n[<span class="number">0</span>].z;</span><br><span class="line">r[<span class="number">1</span>].z = m[<span class="number">0</span>].z * n[<span class="number">1</span>].x + m[<span class="number">1</span>].z * n[<span class="number">1</span>].y + m[<span class="number">2</span>].z * n[<span class="number">1</span>].z;</span><br><span class="line">r[<span class="number">2</span>].z = m[<span class="number">0</span>].z * n[<span class="number">2</span>].x + m[<span class="number">1</span>].z * n[<span class="number">2</span>].y + m[<span class="number">2</span>].z * n[<span class="number">2</span>].z;</span><br></pre></td></tr></table></figure>

<p>对于2阶和4阶的矢量或矩阵也是相似的规则。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>与C语言相似，除了基本的数据类型之外，还可以将多个变量聚合到一个结构体中，下边的示例代码演示了在GLSL中如何声明结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fogStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	vec4 color;</span><br><span class="line">	<span class="keyword">float</span> start;</span><br><span class="line">	<span class="keyword">float</span> <span class="built_in">end</span>;</span><br><span class="line">&#125; fogVar;</span><br></pre></td></tr></table></figure>

<p>首先，定义会产生一个新的类型叫做<code>fogStruct</code>，及一个名为<code>fogVar</code>的变量。结构体可以用构造器来初始化，在定义了新的结构体之后，还会定义一个与结构体类型名称相同的构造器。构造器与结构体中的数据类型必须一一对应，以下代码演示了之前定义的结构体初始化的构造语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fogVar = fogStruct(vec4(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="comment">// color</span></span><br><span class="line">                   <span class="number">0.5</span>, <span class="comment">// start</span></span><br><span class="line">                   <span class="number">2.0</span>); <span class="comment">// end</span></span><br></pre></td></tr></table></figure>

<p>结构体的构造器是基于类型的名称，以参数的形式来赋值。获取结构体内元素的方法和C语言中一致：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec4 color = fogVar.color;</span><br><span class="line"><span class="keyword">float</span> start = fogVar.start;</span><br><span class="line"><span class="keyword">float</span> <span class="built_in">end</span> = fogVar.<span class="built_in">end</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>除了结构体制外，GLSL中还支持数组。 语法与C语言相似，创建数组的方式如下代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> floatArray[<span class="number">4</span>];</span><br><span class="line">vec4 vecArray[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>与C语言不同，在GLSL中，关于数组有两点需要注意：</p>
<ul>
<li>除了uniform变量之外，数组的索引只允许使用常数整型表达式</li>
<li>在GLSL中不能在创建的同时给数组初始化，即数组中的元素需要在定义数组之后逐个初始化，且数组不能使用const限定符</li>
</ul>
<h2 id="存储限定符"><a href="#存储限定符" class="headerlink" title="存储限定符"></a>存储限定符</h2><p>在声明变量时，应根据需要使用存储限定符来修饰，GLSL中支持的存储限定符见下表：<br>| 限定符               | 描述                         |<br>| —————– | ————————– |<br>| &lt; none: default &gt; | 局部可读写变量，或者函数的参数            |<br>| const             | 编译时常量，或只读的函数参数             |<br>| attribute         | 由应用程序传输给顶点着色器的逐顶点的数据       |<br>| uniform           | 在图元处理过程中其值保持不变，由应用程序传输给着色器 |<br>| varying           | 由顶点着色器传输给片段着色器中的插值数据       |</p>
<p>本地变量和方法参数只能使用const限定符，方法返回值和结构体成员不能使用限定符。<br>数据不能从一个着色器程序传递给下一个阶段的着色器程序，这样会阻止同一个着色器程序在多个顶点或者片段中进行并行计算。<br>不包含任何限定符或者包含const限定符的全局变量可以包含初始化器，这种情况下这些变量会在main()函数开始之后第一行代码之前被初始化，这些初始化值必须是常量表达式。没有任何限定符的全局变量如果没有在定义时初始化或者在程序中被初始化，则其值在进入main()函数之后是未定义的。uniform、attribute和varying限定符修饰的变量不能在初始化时被赋值，这些变量的值由OpenGL ES计算提供。</p>
<h3 id="默认限定符"><a href="#默认限定符" class="headerlink" title="默认限定符"></a>默认限定符</h3><p>如果一个全局变量没有指定限定符，则该变量与应用程序或者其他正在运行的处理单元没有任何联系。不管是全局变量还是本地变量，它们总是在自己的处理单元被分配内存，因此可以对它们执行读和写操作。</p>
<h3 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h3><p>任意基础类型的变量都可以声明为常量。常量表示这些变量中的值在着色器中不会发生变化，声明常量只需要在声明时加上限定符const即可，声明时必须赋初值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> zero = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> vec4 red = vec4(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> mat4 identity = mat4(<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<p>常量声明过的值在代码中不能再改变，这一点和C语言或C++一样。<br>结构体成员不能被声明为常量，但是结构体变量可以被声明为常量，并且需要在初始化时使用构造器初始化其值。<br>常量必须被初始化为一个常量表达式。数组或者包含数组的结构体不能被声明为常量（因为数组不能在定义时被初始化）。 </p>
<h3 id="attribute-限定符"><a href="#attribute-限定符" class="headerlink" title="attribute 限定符"></a>attribute 限定符</h3><p>GLSL中另一种特殊的变量类型是attribute变量。attribute变量只用于顶点着色器中，用来存储顶点着色器中每个顶点的输入（per-vertex inputs）。attribute通常用来存储位置坐标、法向量、纹理坐标和颜色等。注意attribute是用来存储单个顶点的信息。以下是有位置坐标和纹理坐标attribute的顶点着色器用例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uniform mat4 u_matViewProjection;</span><br><span class="line">attribute vec4 a_position;</span><br><span class="line">attribute vec2 a_texCoord0;</span><br><span class="line">varying vec2 v_texCoord;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = u_matViewProjection * a_position;</span><br><span class="line">	v_texCoord = a_texCoord0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>着色器中的两个attribute变量<code>a_position</code>和<code>a_texCoord0</code>由应用程序加载数值。应用程序会创建一个顶点数组，其中包含了每个顶点的位置坐标和纹理坐标信息。与uniform相似，可使用的最大attribute数量也是有上限的，可以使用 <code>gl_MaxVertexAttribs</code>来获取，也可以使用内置函数<code>glGetIntegerv</code>来询问<code>GL_MAX_VERTEX_ATTRIBS</code>。OpenGL ES 2.0实现支持的最少attribute个数是8个。</p>
<h3 id="uniform-限定符"><a href="#uniform-限定符" class="headerlink" title="uniform 限定符"></a>uniform 限定符</h3><p>Uniform是GLSL中的一种变量类型限定符，用于存储应用程序通过GLSL传递给着色器的只读值。Uniform可以用来存储着色器需要的各种数据，如变换矩阵、光参数和颜色等。传递给着色器的在所有的顶点着色器和片段着色器中保持不变的的任何参数，基本上都应该通过uniform来存储。uniform变量在全局区声明，使用uniform限定符，以下是uniform的一些用例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniform mat4 viewProjMatrix;</span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform vec3 lightPosition;</span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，顶点着色器和片段着色器共享了uniform变量的命名空间。对于连接于同一个着色程序对象的顶点和片段着色器，它们共用同一组uniform变量，因此，如果在顶点着色器和片段着色器中都声明了uniform变量，二者的声明必须一致。当应用程序通过API加载了uniform变量时，该变量的值在顶点和片段着色器中都能够获取到。</p>
<p>另一点需要注意的是，uniform变量通常是存储在硬件中的“常量区”，这一区域是专门分配用来存储常量的，但是由于这一区域尺寸非常有限，因此着色程序中可以使用的uniform的个数也是有限的。可以通过读取内置变量 <code>gl_MaxVertexUniformVectors</code> and<code>gl_MaxFragmentUniformVectors</code>来获得，也可以使用 <code>glGetIntegerv</code>查询<code>GL_MAX_VERTEX_UNIFORM_VECTORS</code> or <code>GL_MAX_FRAGMENT_UNIFORM_VECTORS</code> 。OpenGL ES 2.0的实现必须提供至少128个顶点uniform矢量及16片段uniform矢量。</p>
<h3 id="varying-限定符"><a href="#varying-限定符" class="headerlink" title="varying 限定符"></a>varying 限定符</h3><p>GLSL中最后一个要说的变量限定符是varying。varying存储的是顶点着色器的输出，同时作为片段着色器的输入，通常顶点着色器都会把需要传递给片段着色器的数据存储在一个或多个varying变量中。这些变量在片段着色器中需要有相对应的声明且数据类型一致，然后在光栅化过程中进行插值计算。以下是一些varying变量的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">varying vec2 texCoord;</span><br><span class="line">varying vec4 color;</span><br></pre></td></tr></table></figure>

<p>顶点着色器和片段着色器中都会有varying变量的声明，由于varying是顶点着色器的输出且是片段着色器的输入，所以两处声明必须一致。与uniform和attribute相同，varying也有数量的限制，可以使用<code>gl_MaxVaryingVectors</code>获取或使用<code>glGetIntegerv</code>查询 <code>GL_MAX_VARYING_VECTORS</code> 来获取。OpenGL ES 2.0实现中的varying变量最小支持数为8。</p>
<p>以下代码是顶点着色器和片段着色器中varying变量的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line">uniform mat4 u_matViewProjection;</span><br><span class="line">attribute vec4 a_position;</span><br><span class="line">attribute vec2 a_texCoord0;</span><br><span class="line">varying vec2 v_texCoord; <span class="comment">// Varying in vertex shader</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = u_matViewProjection * a_position;</span><br><span class="line">	v_texCoord = a_texCoord0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line">precision mediump <span class="keyword">float</span>;</span><br><span class="line">varying vec2 v_texCoord; <span class="comment">// Varying in fragment shader</span></span><br><span class="line">uniform sampler2D s_baseMap;</span><br><span class="line">uniform sampler2D s_lightMap;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec4 baseColor;</span><br><span class="line">	vec4 lightColor;</span><br><span class="line">	baseColor = texture2D(s_baseMap, v_texCoord);</span><br><span class="line">	lightColor = texture2D(s_lightMap, v_texCoord);</span><br><span class="line">	gl_FragColor = baseColor * (lightColor + <span class="number">0.25</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>下表展示了GLSL中支持的运算符：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符类别</th>
<th>运算符</th>
<th>结合方向</th>
</tr>
</thead>
<tbody><tr>
<td>1 (最高)</td>
<td>成组操作</td>
<td>()</td>
<td>NA</td>
</tr>
<tr>
<td>2</td>
<td>数组下标，函数调用与构造函数，访问分量或结构体的字段，后置自增和自减</td>
<td>[] () . ++ –</td>
<td>从左向右</td>
</tr>
<tr>
<td>3</td>
<td>前置自增和自减，一元正/负数，一元逻辑非</td>
<td>++ – + - !</td>
<td>从右向左</td>
</tr>
<tr>
<td>4</td>
<td>乘法，除法</td>
<td>* /</td>
<td>从左向右</td>
</tr>
<tr>
<td>5</td>
<td>加法，减法</td>
<td>+ -</td>
<td>从左向右</td>
</tr>
<tr>
<td>6</td>
<td>关系比较操作</td>
<td>&lt; &gt; &lt;= &gt;=</td>
<td>从左向右</td>
</tr>
<tr>
<td>7</td>
<td>相等操作</td>
<td>== !=</td>
<td>从左向右</td>
</tr>
<tr>
<td>8</td>
<td>逻辑与</td>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>9</td>
<td>逻辑异或</td>
<td>^^</td>
<td>从左向右</td>
</tr>
<tr>
<td>10</td>
<td>逻辑或</td>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>11</td>
<td>三元选择操作（问号表达式）</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>12</td>
<td>赋值与算数赋值</td>
<td>= += -= *= /=</td>
<td>从右向左</td>
</tr>
<tr>
<td>13(最低)</td>
<td>操作符序列</td>
<td>,</td>
<td>从左向右</td>
</tr>
</tbody></table>
<p>绝大多数的运算符与C语言中一致。与C语言不同的是：GLSL中对于参与运算的数据类型要求比较严格，即运算符两侧的变量必须有相同的基础类型。对于二目运算符（*，/，+，-），操作数必须为浮点型或整型，除此之外，乘法操作却可以放在不同的数据类型之间如浮点型、矢量和矩阵等，参考以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> myFloat;</span><br><span class="line">vec4 myVec4;</span><br><span class="line">mat4 myMat4;</span><br><span class="line">myVec4 = myVec4 * myFloat; <span class="comment">// Multiplies each component of myVec4 by a scalar myFloat</span></span><br><span class="line">myVec4 = myVec4 * myVec4; <span class="comment">// Multiplies each component of myVec4 together (e.g., myVec4 ^ 2 )</span></span><br><span class="line">myVec4 = myMat4 * myVec4; <span class="comment">// Does a matrix * vector multiply of myMat4 * myVec4</span></span><br><span class="line">myMat4 = myMat4 * myMat4; <span class="comment">// Does a matrix * matrix multiply of myMat4 * myMat4</span></span><br><span class="line">myMat4 = myMat4 * myFloat; <span class="comment">// Multiplies each matrix component by the scalar myFloat</span></span><br></pre></td></tr></table></figure>

<p>比较运算符仅能作用于标量，对于矢量的比较，GLSL中有内置的函数，稍后会介绍。</p>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><p>流程控制语句与C语言非常相似，以下示例代码是<code>if-else</code>的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(color.a &lt; <span class="number">0.25</span>)</span><br><span class="line">&#123;</span><br><span class="line">	color *= color.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	color = vec4(<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断的内容必须是布尔值或布尔表达式，除了基本的<code>if-else</code>语句，还可以使用<code>for</code>循环，在使用<code>for</code>循环时也有一些约束，如循环变量的值必须是编译时已知。下边是一段使用<code>for</code>循环的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在GLSL中使用循环时一定要注意：只有一个循环变量，循环变量必须使用简单的语句来增减（如 i++, i–, i+=constant, i-=constant等），循环终止条件也必须是循环变量和常量的简单比较，在循环内部不能改变循环变量的值。</p>
<p>以下代码是GLSL中不支持的循环用法的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> myArr[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	sum += myArr[i]; <span class="comment">// NOT ALLOWED IN OPENGL ES, CANNOT DO INDEXING WITH NONCONSTANT EXPRESSION</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">uniform <span class="keyword">int</span> loopIter;</span><br><span class="line"><span class="comment">// NOT ALLOWED IN OPENGL ES, loopIter ITERATION COUNT IS NONCONSTANT</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopIter; i++)</span><br><span class="line">&#123;</span><br><span class="line">	sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="参数限定符"><a href="#参数限定符" class="headerlink" title="参数限定符"></a>参数限定符</h3><p>函数的声明与C语言中很相似。如果一个函数在定以前被调用，则需要先声明其原型。</p>
<p>一般而言，函数的使用也与C语言相似，一个重要的的不同点是向函数传入参数的方式。GLSL提供了一种特殊的限定符用来定义某个变量的值是否可以被函数修改，详见下表：</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>默认使用的缺省限定符，指明参数传递的是值，并且函数不会修改传入的值（C语言中传递值）</td>
</tr>
<tr>
<td>inout</td>
<td>指明参数传入的是引用，如果在函数中对参数的值进行了修改，当函数结束后参数的值也会修改（C语言中传递引用）</td>
</tr>
<tr>
<td>out</td>
<td>参数的值不会传入函数，但是在函数内部修改其值，函数结束后其值会被修改</td>
</tr>
</tbody></table>
<p>使用的方式如下边的代码： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">myFunc</span><span class="params">(inout <span class="keyword">float</span> myFloat, <span class="comment">// inout parameter</span></span></span></span><br><span class="line"><span class="function"><span class="params">            out vec4 myVec4, <span class="comment">// out parameter</span></span></span></span><br><span class="line"><span class="function"><span class="params">            mat4 myMat4)</span></span>; <span class="comment">// in parameter (default)</span></span><br></pre></td></tr></table></figure>

<p>以下是一个示例函数，函数定义用来计算基础的漫反射光照：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">diffuse</span><span class="params">(vec3 normal,</span></span></span><br><span class="line"><span class="function"><span class="params">             vec3 light,</span></span></span><br><span class="line"><span class="function"><span class="params">             vec4 baseColor)</span></span></span><br><span class="line"><span class="function">             </span>&#123;</span><br><span class="line">             	<span class="keyword">return</span> baseColor * dot(normal, light);</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的一点是，GLSL中的函数不能够递归调用。</p>
<h2 id="计算的不变性"><a href="#计算的不变性" class="headerlink" title="计算的不变性"></a>计算的不变性</h2><h3 id="invariant-限定符"><a href="#invariant-限定符" class="headerlink" title="invariant 限定符"></a>invariant 限定符</h3><p>invariant可以作用于顶点着色器输出的任何一个varying变量。<br>当着色器被编译时，编译器会对其进行优化，这种优化操作可能引起指令重排序（instruction reordering），指令重排序可能引起的结果是当两个着色器进行相同的计算时无法保证得到相同的结果。<br>例如，在两个顶点着色器中，变量<code>gl_Position</code>使用相同的表达式赋值，并且当着色程序运行时，在表达式中传入相等的变量值，则两个着色器中<code>gl_Position</code>的值无法保证相等，这是因为两个着色器是分别单独编译的。这将会引起multi-pass算法的几何不一致问题。<br>通常情况下，不同着色器之间的这种值的差异是允许存在的。如果要避免这种差异，则可以将变量声明为invariant，可以单独指定某个变量或进行全局设置。</p>
<p>使用invariant限定符可以使输出的变量保持不变。invariant限定符可以作用于之前已声明的变量使其具有不变性，也可以在声明变量时直接作为声明的一部分，可参考以下两段示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">invariant gl_Position; &#x2F;&#x2F; make existing gl_Position be invariant</span><br><span class="line"></span><br><span class="line">varying mediump vec3 Color;</span><br><span class="line"></span><br><span class="line">invariant Color; &#x2F;&#x2F; make existing Color be invariant</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invariant varying mediump vec3 Color;</span><br></pre></td></tr></table></figure>
<p>以上是仅有的使用invariant限定符情境。如果在声明时使用invariant限定符，则必须保证其放在存储限定符（varying）之前。<br>只有以下变量可以声明为invariant：</p>
<ul>
<li>由顶点着色器输出的内置的特殊变量</li>
<li>由顶点着色器输出的varying变量</li>
<li>向片段着色器输入的内置的特殊变量</li>
<li>向片段着色器输入的varying变量</li>
<li>由片段着色器输出的内置的特殊变量<br>为保证由两个着色器输出的特定变量的不变性，必须遵循以下几点：</li>
<li>该输出变量在两个着色器中都被声明为invariant</li>
<li>影响输出变量的所有表达式、流程控制语句的输入值必须相同</li>
<li>对于影响输出值的所有纹理函数，纹理格式、纹理元素值和纹理过滤必须一致</li>
<li>对输入值的所有操作都必须一致。表达式及插值计算的所有操作必须一致，相同的运算数顺序，相同的结合性，并且按相同顺序计算。插值变量和插值函数的声明，必须有相同类型，相同的显式或隐式的精度precision限定符。影响输出值的所有控制流程必须相同，影响决定控制流程的表达式也必须遵循不变性的规则。</li>
</ul>
<p>最基本的一点是：所有的invariant输出量的上游数据流或控制流必须一致。<br>初始的默认状态下，所有的输出变量不具备不变性，可以在所有的声明之前使用以下<code>pragma</code>语句强制所有输出变量invariant：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> STDGL invariant(all)</span></span><br></pre></td></tr></table></figure>
<p>输出变量的不变性通常会以优化过程的灵活性为代价，所以使用invariant会牺牲整体性能。因此慎用以上的全局设置方法，可以将其用作协助debug的一种方法。<br>另一点需要说明的是，这里的不变性指的是对于同一GPU的不变性，并不保证不同OpenGL ES实现之间的不变性。</p>
<h3 id="precision-限定符"><a href="#precision-限定符" class="headerlink" title="precision 限定符"></a>precision 限定符</h3><p>OpenGL ES与桌面版之间的一个区别就是在GLSL中引入了精度限定符。精度限定符可使着色器的编写者明确定义着色器变量计算时使用的精度，变量可以选择被声明为低、中或高精度。精度限定符可告知编译器使其在计算时缩小变量潜在的精度变化范围，当使用低精度时，OpenGL的实现可以更快速和低功耗地运行着色器，效率的提高来自于精度的舍弃，如果精度选择不合理，着色器运行的结果会很失真。</p>
<p>OpenGL ES 对各硬件并未强制要求多种精度的支持。其实现可以使用高精度完成所有的计算并且忽略掉精度限定符，然而某些情况下使用低精度的实现会更有优势，精度限定符可以指定整型或浮点型变量的精度，如<code>lowp</code>，<br><code>mediump</code>，及<code>highp</code>，参见下表：</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>highp</td>
<td>满足顶点着色语言的最低要求。对片段着色语言是可选项</td>
</tr>
<tr>
<td>mediump</td>
<td>满足片段着色语言的最低要求，其对于范围和精度的要求必须不低于lowp并且不高于highp</td>
</tr>
<tr>
<td>lowp</td>
<td>范围和精度可低于mediump，但仍可以表示所有颜色通道的所有颜色值</td>
</tr>
</tbody></table>
<p>具体用法参考以下示例： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">highp vec4 <span class="built_in">position</span>;</span><br><span class="line">varying lowp vec4 color;</span><br><span class="line">mediump <span class="keyword">float</span> specularExp;</span><br></pre></td></tr></table></figure>

<p>除了精度限定符，还可以指定默认使用的精度。如果某个变量没有使用精度限定符指定使用何种精度，则会使用该变量类型的默认精度。默认精度限定符放在着色器代码起始位置，以下是一些用例： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">precision highp <span class="keyword">float</span>;</span><br><span class="line">precision mediump <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>

<p>当为<code>float</code>指定默认精度时，所有基于浮点型的变量都会以此作为默认精度，与此类似，为<code>int</code>指定默认精度时，所有的基于整型的变量都会以此作为默认精度。在顶点着色器中，如果没有指定默认精度，则<code>int</code>和<code>float</code>都使用<code>highp</code>，即顶点着色器中，未使用精度限定符指明精度的变量都默认使用最高精度。在片段着色器中，<code>float</code>并没有默认的精度设置，即片段着色器中必须为<code>float</code>设置默认精度或者为每一个<code>float</code>变量指明精度。OpenGL ES 2.0并未要求其实现在片段着色器中支持高精度，可用是否定义了宏<code>GL_FRAGMENT_PRECISION_HIGH</code>来判断是否支持在片段着色器中使用高精度。</p>
<p>在片段着色器中可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_FRAGMENT_PRECISION_HIGH</span></span><br><span class="line">precision highp <span class="keyword">float</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">precision mediump <span class="keyword">float</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这么做可以确保无论实现支持中精度还是高精度都可以完成着色器的编译。注意不同实现中精度的定义及精度的范围都不统一而是因实现而异的。</p>
<p>精度限定符指明了其实现在存储这些变量时必须使用的最小的范围和精度，但实现可以使用不低于此要求的更高的范围和精度。各精度限定符要求的最小范围及精度如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>浮点数范围</th>
<th>浮点数大小范围</th>
<th>浮点数精度范围</th>
<th>整数范围</th>
</tr>
</thead>
<tbody><tr>
<td>highp</td>
<td>(-2^62 , 2^62)</td>
<td>(2^-62 ,2^62)</td>
<td>相对：2^-16</td>
<td>(-2^16 , 2^16)</td>
</tr>
<tr>
<td>mediump</td>
<td>(-2^14 , 2^14)</td>
<td>(2^-14 ,2^14)</td>
<td>相对：2^-10</td>
<td>(-2^10 , 2^10)</td>
</tr>
<tr>
<td>lowp</td>
<td>(-2, 2)</td>
<td>(2^-8 ,2)</td>
<td>绝对：2^-8</td>
<td>(-2^8 , 2^8)</td>
</tr>
</tbody></table>
<p>在具体实现中，着色器编译器支持的不同着色器类型和数值形式的实际的范围及精度可用以下函数获取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetShaderPrecisionFormat</span><span class="params">( <span class="keyword">enum</span> shadertype, <span class="keyword">enum</span> precisiontype, <span class="keyword">int</span> *range, <span class="keyword">int</span> *precision )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中， <code>shadertype</code>必须是<code>VERTEX_SHADER</code>或<code>FRAGMENT_SHADER</code>；<code>precisiontype</code>必须是<code>LOW_FLOAT</code>、<code>MEDIUM_FLOAT</code>、<code>HIGH_FLOAT</code>、<code>LOW_INT</code>、<code>MEDIUM_INT</code>或<code>HIGH_INT</code>。</p>
<p><code>range</code>是指向含有两个整数的数组的指针，这两个整数将会返回数值的范围。如果用<code>min</code>和<code>max</code>来代表对应格式的最小和最大值，则<code>range</code>中返回的整数值可以定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range[<span class="number">0</span>] = log2(|<span class="built_in">min</span>|)</span><br><span class="line">range[<span class="number">1</span>] = log2(|<span class="built_in">max</span>|)</span><br></pre></td></tr></table></figure>

<p><code>precision</code>是指向一个整数的指针，返回的该整数是对应格式的精度的位数（number of bits）用<code>log2</code>取对数的值。</p>
<h2 id="限定符的次序"><a href="#限定符的次序" class="headerlink" title="限定符的次序"></a>限定符的次序</h2><p>当同时有多个限定符时，各限定符必须按照一定的顺序，具体如下：<br><em>invariant-qualifier</em> -&gt; <em>storage-qualifier</em> -&gt; <em>precision-qualifier</em><br><em>storage-qualifier</em> -&gt; <em>parameter-qualifier</em> -&gt; <em>precision-qualifier</em></p>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf" target="_blank" rel="noopener">OpenGL ES Common Profile Specification</a><br><a href="https://book.douban.com/subject/3175883/" target="_blank" rel="noopener">OpenGL ES 2.0 ProgrammingGuide</a><br><a href="https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf" target="_blank" rel="noopener">The OpenGL ES Shading Language</a><br><a href="https://book.douban.com/subject/26220248" target="_blank" rel="noopener">OpenGL编程指南（原书第8版）</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OpenGL/" rel="tag"># OpenGL</a>
              <a href="/tags/OpenGL-ES/" rel="tag"># OpenGL ES</a>
              <a href="/tags/GLSL/" rel="tag"># GLSL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/2017-01-09-algorithm-complexity-cheatsheet/" rel="prev" title="常见算法复杂度Cheatsheet">
      <i class="fa fa-chevron-left"></i> 常见算法复杂度Cheatsheet
    </a></div>
      <div class="post-nav-item">
    <a href="/post/2017-01-15-opengl-es-glsl-02/" rel="next" title="OpenGL ES 2.0 着色器语言GLSL（二）">
      OpenGL ES 2.0 着色器语言GLSL（二） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#GLSL概览"><span class="nav-number">1.</span> <span class="nav-text">GLSL概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用GLSL构建着色器"><span class="nav-number">2.</span> <span class="nav-text">使用GLSL构建着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量及变量类型"><span class="nav-number">2.1.</span> <span class="nav-text">变量及变量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量构造器及类型转换"><span class="nav-number">2.2.</span> <span class="nav-text">变量构造器及类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矢量和矩阵的分量"><span class="nav-number">2.3.</span> <span class="nav-text">矢量和矩阵的分量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矢量和矩阵的操作"><span class="nav-number">2.4.</span> <span class="nav-text">矢量和矩阵的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体"><span class="nav-number">2.5.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">2.6.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储限定符"><span class="nav-number">3.</span> <span class="nav-text">存储限定符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认限定符"><span class="nav-number">3.1.</span> <span class="nav-text">默认限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-限定符"><span class="nav-number">3.2.</span> <span class="nav-text">const 限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-限定符"><span class="nav-number">3.3.</span> <span class="nav-text">attribute 限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uniform-限定符"><span class="nav-number">3.4.</span> <span class="nav-text">uniform 限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#varying-限定符"><span class="nav-number">3.5.</span> <span class="nav-text">varying 限定符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语句"><span class="nav-number">4.</span> <span class="nav-text">语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">4.1.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程控制语句"><span class="nav-number">4.2.</span> <span class="nav-text">流程控制语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">4.3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数限定符"><span class="nav-number">4.4.</span> <span class="nav-text">参数限定符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算的不变性"><span class="nav-number">5.</span> <span class="nav-text">计算的不变性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#invariant-限定符"><span class="nav-number">5.1.</span> <span class="nav-text">invariant 限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#precision-限定符"><span class="nav-number">5.2.</span> <span class="nav-text">precision 限定符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限定符的次序"><span class="nav-number">6.</span> <span class="nav-text">限定符的次序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#REFERENCE"><span class="nav-number">7.</span> <span class="nav-text">REFERENCE</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Aillieo</p>
  <div class="site-description" itemprop="description">PROGRAMMING | GAMES | DESIGN</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aillieo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'd4356b728d7738b0b7c9',
      clientSecret: '5258ccaf1be51bbe4467ac2c996d54b32602d41e',
      repo        : 'https://github.com/aillieo/aillieo.github.io',
      owner       : 'aillieo',
      admin       : [''],
      id          : '4f3a3b620769659b961710331c292acf',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
