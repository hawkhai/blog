<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" data-theme="light"><head><script type="text/javascript" src="https://m.addthis.com/live/red_lojson/300lo.json?si=60867564ca3f3a6d&amp;bkl=0&amp;bl=1&amp;pdt=829&amp;sid=60867564ca3f3a6d&amp;pub=ra-57e27fcf6e91c81d&amp;rev=v8.28.8-wp&amp;ln=zh&amp;pc=men&amp;cb=0&amp;ab=-&amp;dp=frankorz.com&amp;fp=2021%2F04%2F17%2Fcompute-shader%2F&amp;fr=&amp;of=0&amp;pd=0&amp;irt=0&amp;vcl=0&amp;md=0&amp;ct=1&amp;tct=0&amp;abt=0&amp;cdn=0&amp;pi=1&amp;rb=0&amp;gen=100&amp;chr=UTF-8&amp;mk=%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%2CShader&amp;colc=1619424632610&amp;jsl=1&amp;uvs=6086756494b7b52b000&amp;skipb=1&amp;callback=addthis.cbs.jsonp__9010027688575080"></script><script type="text/javascript" src="https://v1.addthisedge.com/live/boost/ra-57e27fcf6e91c81d/_ate.track.config_resp"></script><script type="text/javascript" src="https://z.moatads.com/addthismoatframe568911941483/moatframe.js"></script><meta charset="UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width,initial-scale=1" /><title>Compute Shader 简介 | 萤火之森</title><meta name="keywords" content="游戏开发,Shader" /><meta name="author" content="猫冬" /><meta name="copyright" content="猫冬" /><meta name="format-detection" content="telephone=no" /><meta name="theme-color" content="#ffffff" /><meta name="description" content="做游戏的时候，我们经常要面对各种优化问题。DOTS 技术栈的出现提供了一种 CPU 端的多线程方案，那么我们是否也能将一些计算转到 GPU 上面，从而平衡好对 CPU 和 GPU 的使用呢？对我而言，以前使用 GPU 无非是通过写 vert/frag shader、做好渲染相关的设置等操作，但实际上我们还能使用 GPU 的计算能力来帮我们解决问题。Compute Shader 就是我们跟 GPU" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Compute Shader 简介" />
<meta property="og:url" content="http://frankorz.com/2021/04/17/compute-shader/index.html" />
<meta property="og:site_name" content="萤火之森" />
<meta property="og:description" content="做游戏的时候，我们经常要面对各种优化问题。DOTS 技术栈的出现提供了一种 CPU 端的多线程方案，那么我们是否也能将一些计算转到 GPU 上面，从而平衡好对 CPU 和 GPU 的使用呢？对我而言，以前使用 GPU 无非是通过写 vert/frag shader、做好渲染相关的设置等操作，但实际上我们还能使用 GPU 的计算能力来帮我们解决问题。Compute Shader 就是我们跟 GPU" />
<meta property="og:locale" content="zh_CN" />
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgscompute-shader-cover.jpg" />
<meta property="article:published_time" content="2021-04-17T22:14:30.000Z" />
<meta property="article:modified_time" content="2021-04-26T03:21:11.414Z" />
<meta property="article:author" content="猫冬" />
<meta property="article:tag" content="游戏开发" />
<meta property="article:tag" content="Shader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgscompute-shader-cover.jpg" /><link rel="shortcut icon" href="/imgs/favicon.ico" /><link rel="canonical" href="http://frankorz.com/2021/04/17/compute-shader/" /><link rel="preconnect" href="//cdn.jsdelivr.net" /><link rel="preconnect" href="//www.google-analytics.com" crossorigin="" /><link rel="preconnect" href="//hm.baidu.com" /><link rel="preconnect" href="//busuanzi.ibruce.info" /><link rel="stylesheet" href="/css/index.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="all" onload="this.media='all'" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="all" onload="this.media='all'" /><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script src="https://hm.baidu.com/hm.js?91a6af339098c7b3314fd48d6640bbf8"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?91a6af339098c7b3314fd48d6640bbf8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-69634396-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-69634396-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-26 03:21:11'
}</script><noscript>&lt;style type="text/css"&gt;
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
&lt;/style&gt;</noscript><script>(win=&gt;{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() &gt; item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url =&gt; new Promise((resolve, reject) =&gt; {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState &amp;&amp; loadState !== 'loaded' &amp;&amp; loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="all" onload="this.media='all'" /><meta name="generator" content="Hexo 5.4.0" /><link rel="alternate" href="/atom.xml" title="萤火之森" type="application/atom+xml" />
<script src="https://frankorz.disqus.com/embed.js" data-timestamp="1619424611480"></script><script src="https://frankorz.disqus.com/count.js" id="dsq-count-scr"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" async=""></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js" async=""></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css" /><style type="text/css">.at-icon{fill:#fff;border:0}.at-icon-wrapper{display:inline-block;overflow:hidden}a .at-icon-wrapper{cursor:pointer}.at-rounded,.at-rounded-element .at-icon-wrapper{border-radius:12%}.at-circular,.at-circular-element .at-icon-wrapper{border-radius:50%}.addthis_32x32_style .at-icon{width:2pc;height:2pc}.addthis_24x24_style .at-icon{width:24px;height:24px}.addthis_20x20_style .at-icon{width:20px;height:20px}.addthis_16x16_style .at-icon{width:1pc;height:1pc}#at16lb{display:none;position:absolute;top:0;left:0;width:100%;height:100%;z-index:1001;background-color:#000;opacity:.001}#at_complete,#at_error,#at_share,#at_success{position:static!important}.at15dn{display:none}#at15s,#at16p,#at16p form input,#at16p label,#at16p textarea,#at_share .at_item{font-family:arial,helvetica,tahoma,verdana,sans-serif!important;font-size:9pt!important;outline-style:none;outline-width:0;line-height:1em}* html #at15s.mmborder{position:absolute!important}#at15s.mmborder{position:fixed!important;width:250px!important}#at15s{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABtJREFUeNpiZGBgaGAgAjAxEAlGFVJHIUCAAQDcngCUgqGMqwAAAABJRU5ErkJggg==);float:none;line-height:1em;margin:0;overflow:visible;padding:5px;text-align:left;position:absolute}#at15s a,#at15s span{outline:0;direction:ltr;text-transform:none}#at15s .at-label{margin-left:5px}#at15s .at-icon-wrapper{width:1pc;height:1pc;vertical-align:middle}#at15s .at-icon{width:1pc;height:1pc}.at4-icon{display:inline-block;background-repeat:no-repeat;background-position:top left;margin:0;overflow:hidden;cursor:pointer}.addthis_16x16_style .at4-icon,.addthis_default_style .at4-icon,.at4-icon,.at-16x16{width:1pc;height:1pc;line-height:1pc;background-size:1pc!important}.addthis_32x32_style .at4-icon,.at-32x32{width:2pc;height:2pc;line-height:2pc;background-size:2pc!important}.addthis_24x24_style .at4-icon,.at-24x24{width:24px;height:24px;line-height:24px;background-size:24px!important}.addthis_20x20_style .at4-icon,.at-20x20{width:20px;height:20px;line-height:20px;background-size:20px!important}.at4-icon.circular,.circular .at4-icon,.circular.aticon{border-radius:50%}.at4-icon.rounded,.rounded .at4-icon{border-radius:4px}.at4-icon-left{float:left}#at15s .at4-icon{text-indent:20px;padding:0;overflow:visible;white-space:nowrap;background-size:1pc;width:1pc;height:1pc;background-position:top left;display:inline-block;line-height:1pc}.addthis_vertical_style .at4-icon,.at4-follow-container .at4-icon{margin-right:5px}html&gt;body #at15s{width:250px!important}#at15s.atm{background:none!important;padding:0!important;width:10pc!important}#at15s_inner{background:#fff;border:1px solid #fff;margin:0}#at15s_head{position:relative;background:#f2f2f2;padding:4px;cursor:default;border-bottom:1px solid #e5e5e5}.at15s_head_success{background:#cafd99!important;border-bottom:1px solid #a9d582!important}.at15s_head_success a,.at15s_head_success span{color:#000!important;text-decoration:none}#at15s_brand,#at15sptx,#at16_brand{position:absolute}#at15s_brand{top:4px;right:4px}.at15s_brandx{right:20px!important}a#at15sptx{top:4px;right:4px;text-decoration:none;color:#4c4c4c;font-weight:700}#at15sptx:hover{text-decoration:underline}#at16_brand{top:5px;right:30px;cursor:default}#at_hover{padding:4px}#at_hover .at_item,#at_share .at_item{background:#fff!important;float:left!important;color:#4c4c4c!important}#at_share .at_item .at-icon-wrapper{margin-right:5px}#at_hover .at_bold{font-weight:700;color:#000!important}#at_hover .at_item{width:7pc!important;padding:2px 3px!important;margin:1px;text-decoration:none!important}#at_hover .at_item.athov,#at_hover .at_item:focus,#at_hover .at_item:hover{margin:0!important}#at_hover .at_item.athov,#at_hover .at_item:focus,#at_hover .at_item:hover,#at_share .at_item.athov,#at_share .at_item:hover{background:#f2f2f2!important;border:1px solid #e5e5e5;color:#000!important;text-decoration:none}.ipad #at_hover .at_item:focus{background:#fff!important;border:1px solid #fff}.at15t{display:block!important;height:1pc!important;line-height:1pc!important;padding-left:20px!important;background-position:0 0;text-align:left}.addthis_button,.at15t{cursor:pointer}.addthis_toolbox a.at300b,.addthis_toolbox a.at300m{width:auto}.addthis_toolbox a{margin-bottom:5px;line-height:initial}.addthis_toolbox.addthis_vertical_style{width:200px}.addthis_button_facebook_like .fb_iframe_widget{line-height:100%}.addthis_button_facebook_like iframe.fb_iframe_widget_lift{max-width:none}.addthis_toolbox a.addthis_button_counter,.addthis_toolbox a.addthis_button_facebook_like,.addthis_toolbox a.addthis_button_facebook_send,.addthis_toolbox a.addthis_button_facebook_share,.addthis_toolbox a.addthis_button_foursquare,.addthis_toolbox a.addthis_button_linkedin_counter,.addthis_toolbox a.addthis_button_pinterest_pinit,.addthis_toolbox a.addthis_button_tweet{display:inline-block}.addthis_toolbox span.addthis_follow_label{display:none}.addthis_toolbox.addthis_vertical_style span.addthis_follow_label{display:block;white-space:nowrap}.addthis_toolbox.addthis_vertical_style a{display:block}.addthis_toolbox.addthis_vertical_style.addthis_32x32_style a{line-height:2pc;height:2pc}.addthis_toolbox.addthis_vertical_style .at300bs{margin-right:4px;float:left}.addthis_toolbox.addthis_20x20_style span{line-height:20px}.addthis_toolbox.addthis_32x32_style span{line-height:2pc}.addthis_toolbox.addthis_pill_combo_style .addthis_button_compact .at15t_compact,.addthis_toolbox.addthis_pill_combo_style a{float:left}.addthis_toolbox.addthis_pill_combo_style a.addthis_button_tweet{margin-top:-2px}.addthis_toolbox.addthis_pill_combo_style .addthis_button_compact .at15t_compact{margin-right:4px}.addthis_default_style .addthis_separator{margin:0 5px;display:inline}div.atclear{clear:both}.addthis_default_style .addthis_separator,.addthis_default_style .at4-icon,.addthis_default_style .at300b,.addthis_default_style .at300bo,.addthis_default_style .at300bs,.addthis_default_style .at300m{float:left}.at300b img,.at300bo img{border:0}a.at300b .at4-icon,a.at300m .at4-icon{display:block}.addthis_default_style .at300b,.addthis_default_style .at300bo,.addthis_default_style .at300m{padding:0 2px}.at300b,.at300bo,.at300bs,.at300m{cursor:pointer}.addthis_button_facebook_like.at300b:hover,.addthis_button_facebook_like.at300bs:hover,.addthis_button_facebook_send.at300b:hover,.addthis_button_facebook_send.at300bs:hover{opacity:1}.addthis_20x20_style .at15t,.addthis_20x20_style .at300bs{overflow:hidden;display:block;height:20px!important;width:20px!important;line-height:20px!important}.addthis_32x32_style .at15t,.addthis_32x32_style .at300bs{overflow:hidden;display:block;height:2pc!important;width:2pc!important;line-height:2pc!important}.at300bs{overflow:hidden;display:block;background-position:0 0;height:1pc;width:1pc;line-height:1pc!important}.addthis_default_style .at15t_compact,.addthis_default_style .at15t_expanded{margin-right:4px}#at_share .at_item{width:123px!important;padding:4px;margin-right:2px;border:1px solid #fff}#at16p{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABtJREFUeNpiZGBgaGAgAjAxEAlGFVJHIUCAAQDcngCUgqGMqwAAAABJRU5ErkJggg==);z-index:10000001;position:absolute;top:50%;left:50%;width:300px;padding:10px;margin:0 auto;margin-top:-185px;margin-left:-155px;font-family:arial,helvetica,tahoma,verdana,sans-serif;font-size:9pt;color:#5e5e5e}#at_share{margin:0;padding:0}#at16pt{position:relative;background:#f2f2f2;height:13px;padding:5px 10px}#at16pt a,#at16pt h4{font-weight:700}#at16pt h4{display:inline;margin:0;padding:0;font-size:9pt;color:#4c4c4c;cursor:default}#at16pt a{position:absolute;top:5px;right:10px;color:#4c4c4c;text-decoration:none;padding:2px}#at15sptx:focus,#at16pt a:focus{outline:thin dotted}#at15s #at16pf a{top:1px}#_atssh{width:1px!important;height:1px!important;border:0!important}.atm{width:10pc!important;padding:0;margin:0;line-height:9pt;letter-spacing:normal;font-family:arial,helvetica,tahoma,verdana,sans-serif;font-size:9pt;color:#444;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABtJREFUeNpiZGBgaGAgAjAxEAlGFVJHIUCAAQDcngCUgqGMqwAAAABJRU5ErkJggg==);padding:4px}.atm-f{text-align:right;border-top:1px solid #ddd;padding:5px 8px}.atm-i{background:#fff;border:1px solid #d5d6d6;padding:0;margin:0;box-shadow:1px 1px 5px rgba(0,0,0,.15)}.atm-s{margin:0!important;padding:0!important}.atm-s a:focus{border:transparent;outline:0;transition:none}#at_hover.atm-s a,.atm-s a{display:block;text-decoration:none;padding:4px 10px;color:#235dab!important;font-weight:400;font-style:normal;transition:none}#at_hover.atm-s .at_bold{color:#235dab!important}#at_hover.atm-s a:hover,.atm-s a:hover{background:#2095f0;text-decoration:none;color:#fff!important}#at_hover.atm-s .at_bold{font-weight:700}#at_hover.atm-s a:hover .at_bold{color:#fff!important}.atm-s a .at-label{vertical-align:middle;margin-left:5px;direction:ltr}.at_PinItButton{display:block;width:40px;height:20px;padding:0;margin:0;background-image:url(//s7.addthis.com/static/t00/pinit00.png);background-repeat:no-repeat}.at_PinItButton:hover{background-position:0 -20px}.addthis_toolbox .addthis_button_pinterest_pinit{position:relative}.at-share-tbx-element .fb_iframe_widget span{vertical-align:baseline!important}#at16pf{height:auto;text-align:right;padding:4px 8px}.at-privacy-info{position:absolute;left:7px;bottom:7px;cursor:pointer;text-decoration:none;font-family:helvetica,arial,sans-serif;font-size:10px;line-height:9pt;letter-spacing:.2px;color:#666}.at-privacy-info:hover{color:#000}.body .wsb-social-share .wsb-social-share-button-vert{padding-top:0;padding-bottom:0}.body .wsb-social-share.addthis_counter_style .addthis_button_tweet.wsb-social-share-button{padding-top:40px}.body .wsb-social-share.addthis_counter_style .addthis_button_facebook_like.wsb-social-share-button{padding-top:21px}@media print{#at4-follow,#at4-share,#at4-thankyou,#at4-whatsnext,#at4m-mobile,#at15s,.at4,.at4-recommended{display:none!important}}@media screen and (max-width:400px){.at4win{width:100%}}@media screen and (max-height:700px) and (max-width:400px){.at4-thankyou-inner .at4-recommended-container{height:122px;overflow:hidden}.at4-thankyou-inner .at4-recommended .at4-recommended-item:first-child{border-bottom:1px solid #c5c5c5}}</style><style type="text/css">.at-branding-logo{font-family:helvetica,arial,sans-serif;text-decoration:none;font-size:10px;display:inline-block;margin:2px 0;letter-spacing:.2px}.at-branding-logo .at-branding-icon{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAMAAAC67D+PAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRF////+GlNUkcc1QAAAB1JREFUeNpiYIQDBjQmAwMmkwEM0JnY1WIxFyDAABGeAFEudiZsAAAAAElFTkSuQmCC")}.at-branding-logo .at-branding-icon,.at-branding-logo .at-privacy-icon{display:inline-block;height:10px;width:10px;margin-left:4px;margin-right:3px;margin-bottom:-1px;background-repeat:no-repeat}.at-branding-logo .at-privacy-icon{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAKCAMAAABR24SMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABhQTFRF8fr9ot/xXcfn2/P5AKva////////AKTWodjhjAAAAAd0Uk5T////////ABpLA0YAAAA6SURBVHjaJMzBDQAwCAJAQaj7b9xifV0kUKJ9ciWxlzWEWI5gMF65KUTv0VKkjVeTerqE/x7+9BVgAEXbAWI8QDcfAAAAAElFTkSuQmCC")}.at-branding-logo span{text-decoration:none}.at-branding-logo .at-branding-addthis,.at-branding-logo .at-branding-powered-by{color:#666}.at-branding-logo .at-branding-addthis:hover{color:#333}.at-cv-with-image .at-branding-addthis,.at-cv-with-image .at-branding-addthis:hover{color:#fff}a.at-branding-logo:visited{color:initial}.at-branding-info{display:inline-block;padding:0 5px;color:#666;border:1px solid #666;border-radius:50%;font-size:10px;line-height:9pt;opacity:.7;transition:all .3s ease;text-decoration:none}.at-branding-info span{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.at-branding-info:before{content:'i';font-family:Times New Roman}.at-branding-info:hover{color:#0780df;border-color:#0780df}</style><style type="text/css"></style></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgshead.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar" /></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr /><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.notion.so/frankorz/e9a64743c07743f08605f5df7cb57eaf"><i class="fa-fw far fa-sticky-note"></i><span> 公开笔记</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/pixel-art/"><i class="fa-fw fas fa-palette"></i><span> 像素画</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://img.frankorz.com/compute-shader-cover.png')"><nav id="nav" class="show"><span id="blog_name"><a id="site-name" href="/">萤火之森</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.notion.so/frankorz/e9a64743c07743f08605f5df7cb57eaf"><i class="fa-fw far fa-sticky-note"></i><span> 公开笔记</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/pixel-art/"><i class="fa-fw fas fa-palette"></i><span> 像素画</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Compute Shader 简介</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-17T22:14:30.000Z" title="发表于 2021-04-17 22:14:30"> 2021-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-26T03:21:11.414Z" title="更新于 2021-04-26 03:21:11"> 2021-04-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label"> 字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25 分钟</span></span><span class="post-meta-separator"> |</span><span class="post-meta-pv-cv" id="" data-flag-title="Compute Shader 简介"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label"> 阅读量:</span><span id="busuanzi_value_page_pv">41</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label"> 评论数:</span><span class="disqus-comment-count"><a href="http://frankorz.com/2021/04/17/compute-shader/#disqus_thread"></a></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p> 做游戏的时候，我们经常要面对各种优化问题。DOTS 技术栈的出现提供了一种 CPU 端的多线程方案，那么我们是否也能将一些计算转到 GPU 上面，从而平衡好对 CPU 和 GPU 的使用呢？对我而言，以前使用 GPU 无非是通过写 vert/frag shader、做好渲染相关的设置等操作，但实际上我们还能使用 GPU 的计算能力来帮我们解决问题。Compute Shader 就是我们跟 GPU 请求计算的一种手段。</p>
<p>本文将从并行架构开始，依次讲解一个最简单的 Compute Shader 的编写、线程与线程组的概念、GPU 结构和其计算流水线，并讲解一个鸟群 Flocking 的实例，最后介绍 Compute Shader 的应用。全文较长，读者可以通过目录挑想看的看。</p>
<p>Compute Shader 也和传统着色器的写法十分不一样，写传统 Shader 写怕了的同学请放心～</p>
<span id="more"></span>
<h2 id="介绍">介绍</h2>
<p>当今的 GPU 已经针对单址或连续地址的大量内存处理（亦称为流式操作，streaming operation）进行了优化，这与 CPU 面向内存随机访问的设计理念则刚好背道而驰。再者，考虑到要对顶点与像素分别进行单独的处理，因此 GPU 现已经采用了大规模并行处理架构。例如，NVIDIA 公司开发的 “Fermi” 架构最多可支持 16 个流式多处理器（streaming multiprocessor, SM），而每个流式处理器又均含有 32 个 CUDA 核心，也就是共 512 个 CUDA 核心。</p>
<p>CUDA 与 OpenCL 其实就是通过访问 GPU 来编写通用计算程序的两组不同的 API。</p>
<p><a href="http://img.frankorz.com/cpu-gpu-compare.png" data-fancybox="group" data-caption="CPU compare GPU" class="fancybox"><img src="http://img.frankorz.com/cpu-gpu-compare.png" alt="CPU compare GPU" /></a></p>
<p>现代的 CPU 有 4-8 个 Core，每个 Core 可以同时执行 4-8 个浮点操作，因此我们假设 CPU 有 64 个浮点执行单元，然而 GPU 却可以有上千个这样的执行单元。仅仅只是比较 GPU 和 CPU 的 Core 数量是不公平的，因为它们的职能不同，组织形式也不同。</p>
<p>显然，图形的绘制优势完全得益于 GPU 架构，因为这架构就是专为绘图而精心设计的。但是，一些非图形应用程序同样可以从 GPU 并行架构所提供的强大计算能力中受益。我们将 GPU 用于非图形应用程序的情况称为<strong>通用 GPU 程序设计</strong>（通用 GPU 编程。General Purpose GPU programming, GPGPU programming）。当然，并不是所有的算法都适合由 GPU 来执行，只有数据并行算法（data-parallel algorithm） 才能发挥出 GPU 并行架构的优势。也就是说，仅当拥有大量待执行相同操作的数据时，才最适宜采用并行处理。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>粒子系统是一个例子，我们可简化粒子之间的关系模型，使它们彼此毫无关联，不会相互影响，以此使每个粒子的物理特征都可以分别独立地计算出来。</p>
<p>对于 GPGPU 编程而言，用户通常需要将计算结果返回 CPU 供其访问。这就需将数据由显存复制到系统内存，虽说这个过程的速度较慢（见下图），但是 GPU 在运算时所缩短的时间相比却是微不足道的。 针对图形处理任务来说，我们一般将运算结果作为渲染流水线的输入，所以无须再由 GPU 向 CPU 传输数据。例如，我们可以用计算着色器（Compute Shader）对纹理进行模糊处理（blur），再将着色器资源视图（shader resource view，DirectX 的概念），与模糊处理后的纹理相绑定，以作为着色器的输入。</p>
<p><a href="http://img.frankorz.com/cpu-gpu-speed.png" data-fancybox="group" data-caption="CPU 与 GPU 的数据传输" class="fancybox"><img src="http://img.frankorz.com/cpu-gpu-speed.png" alt="CPU 与 GPU 的数据传输" /></a></p>
<p>计算着色器虽然是一种可编程的着色器，但 Direct3D 并没有将它直接归为渲染流水线中的一部分。虽然如此，但位于流水线之外的计算着色器却可以读写 GPU 资源。从本质上来说，计算着色器能够使我们访问 GPU 来实现数据并行算法，而不必渲染出任何图形。正如前文所说，这一点即为 GPGPU 编程中极为实用的功能。另外，计算着色器还能实现许多图形特效 —— 因此对于图形程序员来说，它也是极具使用价值的。前面提到，由于计算着色器是 Direct3D 的组成部分，也可以读写 Direct3D 资源，由此我们就可以将其输出的数据直接绑定到渲染流水线上。</p>
<p><a href="http://img.frankorz.com/compute-shader-pipeline.png" data-fancybox="group" data-caption="计算着色器并非渲染流水线的组成部分，但是却可以读写GPU 资源。而且计算着色器也可以参与图形的渲染或单独用于 GPGPU 编程" class="fancybox"><img src="http://img.frankorz.com/compute-shader-pipeline.png" alt="计算着色器并非渲染流水线的组成部分，但是却可以读写GPU 资源。而且计算着色器也可以参与图形的渲染或单独用于 GPGPU 编程" /></a></p>
<h2 id="最简单的-Compute-Shader">最简单的 Compute Shader</h2>
<p>现在我们来看看一个最简单的 Compute Shader 的结构。</p>
<p>Unity 右键 → Create → Shader → Compute Shader 就可以创建一个最简单的 Compute Shader。</p>
<p>Compute Shader 文件扩展名为 .compute，它们是以 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/current/Manual/SL-ShadingLanguage.html">DirectX 11 样式 HLSL 语言</a>编写的。</p>
<figure class="highlight glsl"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">glsl</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma kernel CSMain</span></span><br /><span class="line"></span><br /><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br /><span class="line"></span><br /><span class="line">[numthreads(<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>)]</span><br /><span class="line"><span class="type">void</span> CSMain(uint3 id : SV_DispatchThreadID)</span><br /><span class="line">{</span><br /><span class="line">    <span class="comment">// 为了演示，我把模板中下面这行改了</span></span><br /><span class="line">    Result[id.xy] = float4(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1.0</span>);</span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table></figure>
<p>第 1 行：一个计算着色器资源文件必须包含至少一个可以调用的 compute kernel，实际上这个 kernel 对应的就是一个函数，该函数由 <code>#pragma</code> 指示，名字要和函数名一致。一个 Shader 中可以有多个内核，只需定义多个 <code>#pragma kernel functionName</code> 和对应的函数即可，C# 脚本可以通过 kernel 的名字来找到对应要执行的函数（ <code>shader.FindKernel(functionName)</code>）。</p>
<p>第 3 行： RWTexture2D 是一种可供 Compute Shader 读写的纹理，C# 脚本可以通过 <code>SetTexture()</code> 设置一个可读写的 RenderTexture 供  Compute Shader 修改像素颜色。其中 RW 代表可读写。</p>
<p>第 5 行：<code>numthreads</code> 设置线程组中的线程数。组中的线程可以被设置为 1D、2D 或 3D 的网格布局。线程组和线程的概念下文会提到。</p>
<p>第 6 行：CSMain 为函数名，需要和 pragma 定义的 kernel 名一一对应。一个函数体代表一个线程要执行的语句，传进来的 <code>SV_DispatchThreadID</code> 是三维的线程 id，下文会提到。</p>
<p>第 9 行：根据当前线程 id 索引到可读写纹理对应的像素，并设置颜色。</p>
<p>C# 脚本这边</p>
<figure class="highlight c#"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c#</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /><span class="line">11</span><br /><span class="line">12</span><br /></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitShader</span>(<span class="params"></span>)</span></span><br /><span class="line"><span class="function"></span>{</span><br /><span class="line">    _image = GetComponent&lt;Image&gt;();</span><br /><span class="line">    _kernelIndex = computeShader.FindKernel(<span class="string">"CSMain"</span>);</span><br /><span class="line">    <span class="built_in">int</span> width = <span class="number">1024</span>, height = <span class="number">1024</span>;</span><br /><span class="line">    _rt = <span class="keyword">new</span> RenderTexture(width, height, <span class="number">0</span>) {enableRandomWrite = <span class="literal">true</span>};</span><br /><span class="line">    _rt.Create();</span><br /><span class="line"></span><br /><span class="line">    _image.material.SetTexture(<span class="string">"_MainTex"</span>, _rt);</span><br /><span class="line">    computeShader.SetTexture(_kernelIndex, <span class="string">"Result"</span>, _rt);</span><br /><span class="line">    computeShader.Dispatch(_kernelIndex, width / <span class="number">8</span>, height / <span class="number">8</span>, <span class="number">1</span>);</span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table></figure>
<p>第 4 行：一个 Compute Shader 可能有多个 Kernel，这里根据名字找到需要的 KernelIndex，这样脚本才知道要把数据送给哪一个函数运算。</p>
<p>第 6、7 行：创建一个支持随机读写的 <code>RenderTexture</code> 。</p>
<p>第 10 行：为 Compute Shader 设置要读写的纹理。</p>
<p>第 11 行：设置好要执行的线程组的数量，并开始执行 Compute Shader。线程组数量的设置下文会提到。</p>
<p>将 Compute Shader 在 Inspector 赋值给脚本，然后将脚本挂在一个有 Image 组件的 GameObject 下，就能看到蓝色的图片。</p>
<p><a href="http://img.frankorz.com/simple-compute-shader-demo.png" data-fancybox="group" data-caption="简单的着色器示例" class="fancybox"><img src="http://img.frankorz.com/simple-compute-shader-demo.png" alt="简单的着色器示例" /></a></p>
<p>到现在我们应该大概明白了：</p>
<ul>
<li>kernel 函数里面执行的是一个线程的要执行的逻辑。</li>
<li>我们需要设置线程组的数量（Dispatch）、和线程组内线程的数量（numthreads）。</li>
<li>我们可以为 Compute Shader 设置纹理等可读写资源。</li>
</ul>
<p>那么什么是线程组和线程呢？我们又该如何设置数量？</p>
<h2 id="如何划分工作：线程与线程组">如何划分工作：线程与线程组</h2>
<p>在 GPU 编程的过程中，根据程序具体的执行需求，可将 <strong>线程</strong> 划分为由 <strong>线程组（thread group）</strong> 构成 的网格（grid）。</p>
<p><code>numthread</code> 和 <code>Dispatch</code> 的三维 Grid 的设置方式只是方便逻辑上的划分，硬件执行的时候还会把所有线程当成一维的。因此 <code>numthread(8, 8, 1)</code> 和 <code>numthread(64, 1, 1)</code> 只是对我们来说索引线程的方式不一样而已，除外没区别。</p>
<h3 id="线程组构成的-3D-网格">线程组构成的 3D 网格</h3>
<p>下图是 <code>Dispatch(5,3,2)</code>， <code>numthreads(10,8,3)</code> 时的情况。</p>
<p>注意下图 Y 轴是 DirectX 的方向，向下递增，而 Compute Shader 中 Y 轴是相反的，向上递增，这里参考网格内的结构和线程组与线程的关系即可。</p>
<p><a href="http://img.frankorz.com/dx-grid-of-thread-group.png" data-fancybox="group" data-caption="线程组 3D 网格" class="fancybox"><img src="http://img.frankorz.com/dx-grid-of-thread-group.png" alt="线程组 3D 网格" /></a></p>
<p>上图中还显示了 <code>SV_DispatchThreadID</code> 是如何计算的。</p>
<p>不难看出，我们能够根据需求定义出不同的线程组布局。例如，可以定义一个具有 X 个线程的单行 线程组 <code>[numthreads(X, 1, 1)]</code> 或内含 Y 个线程的单列线程组 <code>[numthreads(1, Y, 1)]</code>。</p>
<p>还可以通过将维度 z 设为 1 来定义规模为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X × Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 2D 线程组，形如 <code>[numthreads(X, Y, 1)]</code>。我们应结合所遇到的具体问题来选择适当的线程组布局。</p>
<p>例如当我们处理 2D 图像时，需要让每一个线程单独处理一个像素，就可以定义 2D 的线程组。假设我们 <code>numthreads</code> 设置为 (8, 8, 1)，那么一个线程组就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8×8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 个线程，能处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8×8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 的像素块（内含 64 个像素点）。</p>
<p>那么如果我们要处理一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>×</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">texResolution × texResolution</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span> 分辨率的纹理，那么需要多少个线程组呢？</p>
<p>x 和 y 方向都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">texResolution / 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">8</span></span></span></span>  个线程组。</p>
<a href="http://img.frankorz.com/thread-group-explain.png" data-fancybox="group" data-caption="" class="fancybox"><img class="inline-img" src="http://img.frankorz.com/thread-group-explain.png" style="height:250px" /></a>
<!-- ![Thread Group of image](http://img.frankorz.com/thread-group-explain.png) -->
<p>可以通过线程组来划分要处理哪些像素块（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8×8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>）</p>
<p><a href="http://img.frankorz.com/thread-group-explain-1.png" data-fancybox="group" data-caption="线程组解释" class="fancybox"><img src="http://img.frankorz.com/thread-group-explain-1.png" alt="线程组解释" /></a></p>
<p><a href="http://img.frankorz.com/thread-group-explain-2.png" data-fancybox="group" data-caption="线程组解释" class="fancybox"><img src="http://img.frankorz.com/thread-group-explain-2.png" alt="线程组解释" /></a></p>
<p>numthreads 有最大线程限制，具体查阅不同平台的文档：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/sm5-attributes-numthreads">numthreads</a> 。</p>
<p>前面介绍了如何设置线程组和线程的数量，现在介绍线程组和线程在硬件的运行形式。</p>
<h3 id="线程组的-GPU-之旅">线程组的 GPU 之旅</h3>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/Fermi-c97604af538148cf96805b7b14ce332e">Fermi 架构</a></p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/Ampere-3e00af14b1fb455db5b0a928a26d65aa">Ampere 架构</a></p>
<p>我们知道 GPU 会有上千个 “核心”，用 NVIDIA 的说法就是 CUDA Core。</p>
<ul>
<li><strong>SP</strong>：最基本的处理单元，streaming processor，也称为 CUDA core。最后具体的指令和任务都是在 SP 上处理的。GPU 进行并行计算，也就是很多个 SP 同时做处理。我们所说的几百核心的 GPU 值指的都是 SP 的数量；</li>
<li><strong>SM</strong>：多个 SP 加上其他的一些资源组成一个 streaming multiprocessor。也叫 GPU 大核，其他资源如：warp scheduler，register，shared memory 等。SM 可以看做 GPU 的心脏（对比 CPU 核心），register 和 shared memory 是 SM 的稀缺资源。CUDA 将这些资源分配给所有驻留在 SM 中的 threads。因此，这些有限的资源就使每个 SM 中 active warps 有非常严格的限制，也就限制了并行能力。</li>
</ul>
<p>这些核心被组织在流式多处理器（streaming multiprocessor, SM）中，一个线程组运行于一个多处理器（SM）之上。每一个核心同一时间可以运行一个线程。</p>
<p>流式多处理器（streaming multiprocessor, SM）是 Nvidia 的说法，AMD 对应的单元则是 Compute Unit。</p>
<p>因此，对于拥有 16 个 SM 的 GPU 来说，我们至少应将任务分解为 16 个线程组，来让每个多处理器都充分地运转起来。但是，要获得更佳的性能，我们还应当令每个多处理器至少拥有两个线程组，使它能够切换到不同的线程组进行处理，以连续不停地工作（线程组在运行的过程中可能会发生停顿，例如，着色器在继续执行下一个指令之前会等待纹理的处理结果，此时即可切换至另一个线程组）。</p>
<p>SM 会将它从 Gigathread 引擎（NVIDIA 技术，专门管理整个流水线）那收到的大线程块，拆分成许多更小的堆，每个堆包含 32 个线程，这样的堆也被称为：<strong>warp</strong> (AMD 则称为 <strong>wavefront</strong>)。多处理器会以 SIMD32 的方式（即 32 个线程同时执行相同的指令序列）来处理 warp，每个 CUDA 核心都可处理一个线程。</p>
<p>“Fermi” 架构中的每个多处理器都具有 32 个 CUDA 核心。</p>
<p>每一个线程组都会被划分到一个 Compute Unit 来计算，线程组中的线程由 Compute Unit 中的 SIMD 部分来执行。<br />
如果我们定义 <code>numthreads(8, 2, 4)</code>，那么每个线程组就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>4</mn><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">8×2×4=64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 个线程，这一整个线程组会被分成两个 warp，调度到单个 SIMD 单元计算。</p>
<p><a href="https://img-blog.csdnimg.cn/20200126195846919.gif" data-fancybox="group" data-caption="Memory Stall（内存延迟）" class="fancybox"><img src="https://img-blog.csdnimg.cn/20200126195846919.gif" alt="Memory Stall（内存延迟）" /></a></p>
<p>单个 SM 处理逐个 warp，当一个 warp 暂时需要等待数据的时候，就可以先换其他 warp 继续执行。</p>
<h3 id="如何设置好线程组的大小">如何设置好线程组的大小</h3>
<p>我们应当总是将线程组的大小设置为 <strong>warp 尺寸的整数倍</strong>。让 SM 同时容纳多个 warp，能够以防一些情况。例如有时候为了等待某些数据就绪，你不得不停下来。比如说，我们需要通过法线纹理贴图来计算法线光照，即使该法线纹理已经在 Cache 中了，访问该资源仍然会有所耗时，而如果它不在 Cache 中，那就更加耗时了。用专业术语讲就是 <strong>Memory Stall（内存延迟）</strong>。与其什么事情也不做，不如将当前的 Warp 换成其它已经准备就绪的 Warp 继续执行。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p><a href="http://img.frankorz.com/thread-group-size-talk.png" data-fancybox="group" data-caption="Dispatch/Thread Group SIze Heuristics" class="fancybox"><img src="http://img.frankorz.com/thread-group-size-talk.png" alt="Dispatch/Thread Group SIze Heuristics" /></a></p>
<p>上图来自：<a target="_blank" rel="noopener" href="https://channel9.msdn.com/Blogs/gclassy/DirectCompute-Lecture-Series-210-GPU-Optimizations-and-Performance">DirectCompute Lecture Series 210: GPU Optimizations and Performance</a></p>
<blockquote>
<p>NVIDIA 在 Maxwell 更改了 SM 的组织方式，即 SMM—— 全新的 SM 架构。每个 SM 分为四个独立的处理块，每个处理块具备自己的指令缓冲区、调度器以及 32 个 CUDA 核心。因此 Maxwell 中可以同时运行 4 个以上的 Warp，实际上，在 GTC2013 大会上的一个 CUDA 优化视频里讲到，在常用 case 中推荐使用 30 个以上的有效 Warp，这样才能确保 Pipeline 的满载利用率。<br />
—— <a target="_blank" rel="noopener" href="http://www.ece.rice.edu/~gw2/">Guohui Wang</a></p>
</blockquote>
<p>NVIDIA 公司生产的图形硬件所用的 warp 单位共有 32 个线程。而 ATI 公司采用的 “wavefront” 单位则具有 64 个线程，且建议为其分配的线程组大小应总为 wavefront 尺寸的整数倍。另外，值得一提的是，不管是 warp 还是 wavefront，它们的大小在未来几代中都有可能发生改变。</p>
<p>总之，每个 SM 的操作度是 warp，但是每个 SM 可以同时处理多个 warp。然后因为有内存等待（memory stall）的问题，同一个 thread block 有可能需要等待内存才做，因此可以使用多个线程组交叉运行。warp 对我们是不可见和不可编程的，我们可编程的只有线程组。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<h2 id="GPU-Compute-Unit">GPU Compute Unit</h2>
<p>接下来我们看一下 GPU 内部的结构，这里的内容来自 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=0DLOJPSxJEg">Compute Shaders: Optimize your engine using compute / Lou Kramer, AMD</a>，<a target="_blank" rel="noopener" href="https://twitter.com/lou_auroyup">Lou Kramer</a> 以 AMD 的 GCN 架构为例，介绍了 GPU 大体的结构。</p>
<p>这里 GCN 就是一个 Compute Unit，Vega 64 显卡有 64 个 Compute Unit。</p>
<p><a href="http://img.frankorz.com/gpu-talk-1.png" data-fancybox="group" data-caption="gpu-talk-1" class="fancybox"><img src="http://img.frankorz.com/gpu-talk-1.png" alt="gpu-talk-1" /></a></p>
<p>GCN 有 4 个 SIMD-16 单元（即 16 个线程同时执行相同的指令序列）。</p>
<p><a href="http://img.frankorz.com/gpu-talk-2.png" data-fancybox="group" data-caption="gpu-talk-2" class="fancybox"><img src="http://img.frankorz.com/gpu-talk-2.png" alt="gpu-talk-2" /></a></p>
<h3 id="线程间交流">线程间交流</h3>
<h4 id="多个线程组间的交流">多个线程组间的交流</h4>
<p>上面提到，线程并不能访问其他组中的共享内存。如果线程组需要互相交流，那么就需要 L2 cache 来支持。但是 L2 cache 性能肯定会有折扣，因此我们要保证组间的交流尽可能少。</p>
<p><a href="http://img.frankorz.com/gpu-talk-3.png" data-fancybox="group" data-caption="gpu-talk-3" class="fancybox"><img src="http://img.frankorz.com/gpu-talk-3.png" alt="gpu-talk-3" /></a></p>
<h4 id="单个线程组内的交流">单个线程组内的交流</h4>
<p>如果单个线程组内线程需要互相交流，则需要 Local Data Share (LDS) 来完成。</p>
<p><a href="http://img.frankorz.com/gpu-talk-4.png" data-fancybox="group" data-caption="gpu-talk-4" class="fancybox"><img src="http://img.frankorz.com/gpu-talk-4.png" alt="gpu-talk-4" /></a></p>
<p>LDS 会被其他着色阶段（shader stage）使用，例如像素着色器就需要 LDS 来插值。但是 Compute Shader 的用途和传统着色器不一样，不是必须要 LDS，因此我们可以随意地使用 LDS。</p>
<figure class="highlight glsl"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">glsl</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /></pre></td><td class="code"><pre><span class="line">groupshared <span class="type">float</span> data[<span class="number">8</span>][<span class="number">8</span>];</span><br /><span class="line"></span><br /><span class="line">[numthreads(<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>)]</span><br /><span class="line"><span class="type">void</span> main(<span class="type">ivec3</span> <span class="keyword">index</span> : SV_GroupThreadID)</span><br /><span class="line">{</span><br /><span class="line">  data[<span class="keyword">index</span>.x][<span class="keyword">index</span>.y] = <span class="number">0.0</span>;</span><br /><span class="line">  GroupMemoryBarrierWithGroupSync();</span><br /><span class="line">  data[<span class="keyword">index</span>.y][<span class="keyword">index</span>.x] += <span class="keyword">index</span>.x;</span><br /><span class="line">  …</span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table></figure>
<p>需要组内共享的变量前加 <code>groupshared</code> ，同时为了保证其他线程也能读到数据，我们也需要通过 Barrier 来保证他们读的时候 LDS 里面有需要的数据。</p>
<p>LDS 比 L1 cache 还快！</p>
<h3 id="Vector-Register-和-Scalar-Register">Vector Register 和 Scalar Register</h3>
<p>如果有些变量是线程独立的，我们称之为 “non-uniform” 变量。（如果一个线程组内有 64 个线程，就要存 64 份数据）</p>
<p>如果有些变量是线程间共享的的，我们称之为 “uniform” 变量，例如线程组 id 是组内每个线程都一样的。（每个线程组内只存 1 份数据）</p>
<p>“non-uniform” 变量会被储存到 Vector Register（VGPR, vector general purpose register）中。</p>
<p>“uniform” 变量会被储存到 Scalar Register（SGPR, scalar general purpose register）中。</p>
<p><a href="http://img.frankorz.com/gpu-talk-5.png" data-fancybox="group" data-caption="gpu-talk-5" class="fancybox"><img src="http://img.frankorz.com/gpu-talk-5.png" alt="gpu-talk-5" /></a></p>
<p>如果用了过多 “non-uniform” 变量导致 Vector Register 装不下，就会导致分配给 SIMD 的线程组数量降低。</p>
<h3 id="与传统着色器执行流程的异同">与传统着色器执行流程的异同</h3>
<h4 id="Vert-Frag-Shader">Vert-Frag Shader</h4>
<ol>
<li>
<p>首先 Command Processor 会收集并处理所有命令，发送到 GPU，并告知下一步要做什么。</p>
</li>
<li>
<p><code>Draw()</code> 命令发送后，Command Processor 告知 Graphics Processor 要做的事情。</p>
<p>我们可以将 Graphics Processor 看作是输入装配器（Input Assembler）的硬件对应的部分。</p>
</li>
<li>
<p>然后类似于顶点着色器这些就会被送到 Compute Unit 去计算，处理完会到 Rasterizer (光栅器)，并返回处理好的像素到 Compute Unit 执行像素着色（Pixel shader）。</p>
</li>
<li>
<p>最后才会输出到 RenderTarget 。</p>
</li>
</ol>
<p>下图中，AMD 显卡架构中的 Compute Unit 相当于 nVIDIA GPUs 中的流式多处理器（streaming multiprocessor, SM）。</p>
<p><a href="http://img.frankorz.com/gpu-talk-6.png" data-fancybox="group" data-caption="gpu-talk-6" class="fancybox"><img src="http://img.frankorz.com/gpu-talk-6.png" alt="gpu-talk-6" /></a></p>
<h4 id="Compute-Shader">Compute Shader</h4>
<ol>
<li>首先 Command Processor 仍会收集并处理所有命令，发送到 GPU。</li>
<li>我们不需要传数据到 Graphics Processor，因为这不是一个 Graphics Command，而是直接传到 Compute Unit。</li>
<li>Compute Unit 开始处理 Compute Shader，输入可以有 constants 和 resources（对应 DirectX 的 Resource 可以绑定到渲染管线的资源，例如顶点数组等），输出可以有 writable resources（UAV, Unordered Access View 能被着色器写入的资源视图）。</li>
</ol>
<h3 id="总结">总结</h3>
<p>因此，如果我们用了 Compute Shader，<strong>可以不通过渲染管线，跳过 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Render_output_unit">Render Output</a>，使用更少硬件资源</strong>，利用 GPU 来完成一些渲染不相关的工作。</p>
<p><a href="http://img.frankorz.com/gpu-talk-7.png" data-fancybox="group" data-caption="gpu-talk-7" class="fancybox"><img src="http://img.frankorz.com/gpu-talk-7.png" alt="gpu-talk-7" /></a></p>
<p>此外，Compute Shader 的流水线<strong>需要的信息也更少</strong>。</p>
<p><a href="http://img.frankorz.com/gpu-talk-8.png" data-fancybox="group" data-caption="gpu-talk-8" class="fancybox"><img src="http://img.frankorz.com/gpu-talk-8.png" alt="gpu-talk-8" /></a></p>
<h2 id="Boids-示例">Boids 示例</h2>
<p>讲完了理论，这里来看看我们在 Unity 中使用 Compute Shader 来做一个鸟群（Boids）的 demo。</p>
<p>群落算法可以参考：<a target="_blank" rel="noopener" href="https://www.red3d.com/cwr/boids/">Boids (Flocks, Herds, and Schools: a Distributed Behavioral Model)</a></p>
<p>代码示例地址：<a target="_blank" rel="noopener" href="https://github.com/Latias94/FlockingComputeShaderCompare">Latias94/FlockingComputeShaderCompare</a></p>
<p>群落算法简单来讲，就是模拟生物群落的自组织特性的移动。</p>
<p><a target="_blank" rel="noopener" href="https://www.red3d.com/cwr/index.html">Craig Reynolds</a> 在 1986 年对诸如鱼群和鸟群的运动进行了建模，提出了三点特征来描述群落中个体的位置和速度：</p>
<ol>
<li>排斥（separation）：每个个体会避免离得太近。离得太近需要施加反方向的力使其分开。</li>
<li>对齐（Alignment）：每个个体的方向会倾向于附近群落的平均方向。</li>
<li>凝聚（Cohesion）：每个个体会倾向于移动到附近群落的平均位置。</li>
</ol>
<p>在这个示例中，我们可以将每一只鸟的位置和方向用一个线程来计算，Compute Shader 负责遍历这只鸟的周围鸟的信息，计算出这只鸟的平均方向和位置。C# 脚本则负责每一帧传入凝聚（Cohesion）的位置、经过的时间，再从 Compute Shader 获取每一只鸟的位置和朝向，设置到每一只鸟的 Transform 上。</p>
<h3 id="设置数据">设置数据</h3>
<p>文章开头的例子中，脚本给 Shader 设置了 <code>RWTexture2D&lt;float4&gt;</code> ，让 Compute Shader 能直接在 Render Tecture 设置颜色。</p>
<p>对于其他类型的数据，我们首先要定义一个结构（Struct），再通过 <code>ComputeBuffer</code>  与 Compute Shader 交流数据。</p>
<figure class="highlight c#"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c#</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /><span class="line">11</span><br /><span class="line">12</span><br /><span class="line">13</span><br /><span class="line">14</span><br /><span class="line">15</span><br /><span class="line">16</span><br /><span class="line">17</span><br /><span class="line">18</span><br /><span class="line">19</span><br /><span class="line">20</span><br /><span class="line">21</span><br /><span class="line">22</span><br /><span class="line">23</span><br /><span class="line">24</span><br /><span class="line">25</span><br /><span class="line">26</span><br /><span class="line">27</span><br /><span class="line">28</span><br /><span class="line">29</span><br /><span class="line">30</span><br /><span class="line">31</span><br /><span class="line">32</span><br /><span class="line">33</span><br /><span class="line">34</span><br /><span class="line">35</span><br /><span class="line">36</span><br /><span class="line">37</span><br /><span class="line">38</span><br /><span class="line">39</span><br /><span class="line">40</span><br /><span class="line">41</span><br /><span class="line">42</span><br /><span class="line">43</span><br /><span class="line">44</span><br /><span class="line">45</span><br /><span class="line">46</span><br /><span class="line">47</span><br /><span class="line">48</span><br /><span class="line">49</span><br /><span class="line">50</span><br /><span class="line">51</span><br /><span class="line">52</span><br /><span class="line">53</span><br /><span class="line">54</span><br /></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlockingGPU.cs</span></span><br /><span class="line"><span class="keyword">struct</span> Boid</span><br /><span class="line">{</span><br /><span class="line">    <span class="keyword">public</span> Vector3 position;</span><br /><span class="line">    <span class="keyword">public</span> Vector3 direction;</span><br /><span class="line">};</span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlockingGPU</span> : <span class="title">MonoBehaviour</span></span><br /><span class="line">{</span><br /><span class="line">    <span class="keyword">public</span> ComputeShader shader;</span><br /><span class="line">    <span class="keyword">private</span> Boid[] _boidsArray;</span><br /><span class="line">    <span class="keyword">private</span> GameObject[] _boids;</span><br /><span class="line">    <span class="keyword">private</span> ComputeBuffer _boidsBuffer;</span><br /><span class="line">    <span class="comment">// ...</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br /><span class="line"><span class="function"></span>    {</span><br /><span class="line">        _kernelHandle = shader.FindKernel(<span class="string">"CSMain"</span>);</span><br /><span class="line"></span><br /><span class="line">        <span class="built_in">uint</span> x;</span><br /><span class="line">        <span class="comment">// 获取 Compute Shader 中定义的 numthreads</span></span><br /><span class="line">        shader.GetKernelThreadGroupSizes(_kernelHandle, <span class="keyword">out</span> x, <span class="keyword">out</span> _, <span class="keyword">out</span> _);</span><br /><span class="line">        _groupSizeX = Mathf.CeilToInt(boidsCount / (<span class="built_in">float</span>) x);</span><br /><span class="line">        <span class="comment">// 塞满每个线程组，免得 Compute Shader 中有线程读不到数据，造成读取数据越界</span></span><br /><span class="line">        _numOfBoids = _groupSizeX * (<span class="built_in">int</span>) x;</span><br /><span class="line"></span><br /><span class="line">        InitBoids();</span><br /><span class="line">        InitShader();</span><br /><span class="line">    }</span><br /><span class="line"></span><br /><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitBoids</span>(<span class="params"></span>)</span></span><br /><span class="line"><span class="function"></span>    {</span><br /><span class="line">        <span class="comment">// 初始化 _Boids GameObject[]、_boidsArray Boid[]</span></span><br /><span class="line">    }</span><br /><span class="line"></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitShader</span>(<span class="params"></span>)</span></span><br /><span class="line"><span class="function"></span>    {   <span class="comment">// 定义大小，鸟的数量和每个鸟结构的大小，一个 Vector3 就是 3 * sizeof(float)</span></span><br /><span class="line">        <span class="comment">// 10000 只鸟，每只占6 * 4 bytes，总共也就占 0.234mib GPU 显存 </span></span><br /><span class="line">        _boidsBuffer = <span class="keyword">new</span> ComputeBuffer(_numOfBoids, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="built_in">float</span>));</span><br /><span class="line">        _boidsBuffer.SetData(_boidsArray); <span class="comment">// 设置结构数组到 Compute Buffer 中</span></span><br /><span class="line">        <span class="comment">// 设置 buffer 到 Compute Shader，同时设置要调用的计算的函数 Kernel</span></span><br /><span class="line">        shader.SetBuffer(_kernelHandle, <span class="string">"boidsBuffer"</span>, _boidsBuffer);</span><br /><span class="line">        shader.SetFloat(<span class="string">"boidSpeed"</span>, boidSpeed); <span class="comment">// 设置其他常量</span></span><br /><span class="line">        shader.SetVector(<span class="string">"flockPosition"</span>, target.transform.position);</span><br /><span class="line">        shader.SetFloat(<span class="string">"neighbourDistance"</span>, neighbourDistance);</span><br /><span class="line">        shader.SetInt(<span class="string">"boidsCount"</span>, boidsCount);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// ...</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br /><span class="line"><span class="function"></span>    {</span><br /><span class="line">        <span class="keyword">if</span> (_boidsBuffer != <span class="literal">null</span>)</span><br /><span class="line">        {    <span class="comment">// 用完主动释放 buffer</span></span><br /><span class="line">            _boidsBuffer.Dispose();</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table></figure>
<h3 id="获取数据">获取数据</h3>
<p>在开头最简单的 Compute Shader 一节中，我介绍了需要 <code>Dispatch</code> 去执行 Compute Shader 的 Kernel。</p>
<p>下面的 <code>Update</code>，设置了每一帧会变的参数，Dispatch 之后，再通过 <code>GetData</code> 阻塞等待 Compute Shader kernel 的计算结果，最后对每一个 Boid 结构赋值。</p>
<figure class="highlight c#"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c#</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /><span class="line">11</span><br /><span class="line">12</span><br /><span class="line">13</span><br /><span class="line">14</span><br /><span class="line">15</span><br /><span class="line">16</span><br /><span class="line">17</span><br /><span class="line">18</span><br /><span class="line">19</span><br /><span class="line">20</span><br /><span class="line">21</span><br /></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlockingGPU.cs</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlockingGPU</span> : <span class="title">MonoBehaviour</span></span><br /><span class="line">{</span><br /><span class="line">    <span class="comment">// ...</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br /><span class="line"><span class="function"></span>    {   <span class="comment">// 设置每一帧会变的变量</span></span><br /><span class="line">        shader.SetFloat(<span class="string">"deltaTime"</span>, Time.deltaTime);</span><br /><span class="line">        shader.SetVector(<span class="string">"flockPosition"</span>, target.transform.position);</span><br /><span class="line">        shader.Dispatch(_kernelHandle, _groupSizeX, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 调用 Compute Shader Kernel 来计算</span></span><br /><span class="line">        <span class="comment">// 阻塞等待 Compute Shader 计算结果从 GPU 传回来</span></span><br /><span class="line">        _boidsBuffer.GetData(_boidsArray);</span><br /><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _boidsArray.Length; i++)</span><br /><span class="line">        {   <span class="comment">// 设置鸟的 position 和 rotation</span></span><br /><span class="line">            _boids[i].transform.localPosition = _boidsArray[i].position;</span><br /><span class="line">            <span class="keyword">if</span> (!_boidsArray[i].direction.Equals(Vector3.zero))</span><br /><span class="line">            {</span><br /><span class="line">                _boids[i].transform.rotation = Quaternion.LookRotation(_boidsArray[i].direction);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table></figure>
<p>在 Compute Shader 中，也要定义一个 Boid 结构和相对应的 <code>RWStructuredBuffer&lt;Boid&gt;</code> 来用脚本传来的 Compute Buffer。Shader 主要就是对一只鸟遍历一定范围内的鸟群的信息，计算出结果返回给脚本。</p>
<figure class="highlight glsl"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">glsl</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /><span class="line">11</span><br /><span class="line">12</span><br /><span class="line">13</span><br /><span class="line">14</span><br /><span class="line">15</span><br /><span class="line">16</span><br /><span class="line">17</span><br /><span class="line">18</span><br /><span class="line">19</span><br /><span class="line">20</span><br /><span class="line">21</span><br /><span class="line">22</span><br /><span class="line">23</span><br /><span class="line">24</span><br /><span class="line">25</span><br /><span class="line">26</span><br /><span class="line">27</span><br /><span class="line">28</span><br /><span class="line">29</span><br /><span class="line">30</span><br /><span class="line">31</span><br /><span class="line">32</span><br /><span class="line">33</span><br /></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleFlocking.compute</span></span><br /><span class="line"><span class="meta">#pragma kernel CSMain</span></span><br /><span class="line"><span class="meta">#define GROUP_SIZE 256</span></span><br /><span class="line"></span><br /><span class="line">struct Boid</span><br /><span class="line">{   <span class="comment">// Compute Shader 也定义好相关的结构</span></span><br /><span class="line">    float3 position;</span><br /><span class="line">    float3 direction;</span><br /><span class="line">};</span><br /><span class="line"></span><br /><span class="line">RWStructuredBuffer&lt;Boid&gt; boidsBuffer; <span class="comment">// 允许读写的数据 buffer</span></span><br /><span class="line"><span class="type">float</span> deltaTime;</span><br /><span class="line">float3 flockPosition;</span><br /><span class="line"></span><br /><span class="line">[numthreads(GROUP_SIZE,<span class="number">1</span>,<span class="number">1</span>)]</span><br /><span class="line"><span class="type">void</span> CSMain(uint3 id : SV_DispatchThreadID)</span><br /><span class="line">{</span><br /><span class="line">    Boid boid = boidsBuffer[id.x];</span><br /><span class="line">    <span class="comment">// ...</span></span><br /><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boidsCount; i++)</span><br /><span class="line">    {</span><br /><span class="line">        <span class="keyword">if</span> (i == id.x)</span><br /><span class="line">            <span class="keyword">continue</span>;</span><br /><span class="line">        Boid tempBoid = boidsBuffer[i];</span><br /><span class="line">        <span class="comment">// 通过周围的鸟的信息，计算经过三个特性后，这一只鸟的方向和位置。</span></span><br /><span class="line">        <span class="comment">// ...</span></span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// ...</span></span><br /><span class="line">    boid.direction = lerp(direction, <span class="built_in">normalize</span>(boid.direction), <span class="number">0.94</span>);</span><br /><span class="line">    boid.position += boid.direction * boidSpeed * deltaTime;</span><br /><span class="line">    <span class="comment">// 设置数据到 Buffer，等待 CPU 读取</span></span><br /><span class="line">    boidsBuffer[id.x] = boid;</span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table></figure>
<p><code>Dispatch</code> 之后 <code>GetData</code> 是阻塞的，如果想异步地获取数据，Unity 2019 新引入一个 API：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Rendering.AsyncGPUReadbackRequest.html">AsyncGPUReadbackRequest</a> ，可以让我们先发送一个获取数据的请求，再每一帧去查询数据是否计算完。也有同学用了测出第一次调用耗时较多等问题，具体可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/h5502637/article/details/85637872">Compute Shader 功能测试（二）</a>。</p>
<p>下面是 100 只鸟的结果：</p>
<p><a href="http://img.frankorz.com/boids-run-demo.gif" data-fancybox="group" data-caption="100只鸟的结果" class="fancybox"><img src="http://img.frankorz.com/boids-run-demo.gif" alt="100只鸟的结果" /></a></p>
<p>通过 Compute Shader，我们可以通过 Compute Shader 在 GPU 直接计算好需要计算的东西（例如位置、mesh 顶点等），并与传统着色器共享一个 <code>ComputeBuffer</code> ，直接在 GPU 渲染，这样就省去渲染时 CPU 再次传数据给 GPU 的耗时。我们也可以将 Compute Shader 计算后的数据返回给 CPU 再做额外的计算。总而言之，Compute Shader 十分灵活。</p>
<h3 id="CPU-端计算-vs-GPU-端计算">CPU 端计算 vs GPU 端计算</h3>
<p>假设我们在 CPU 端不用任何 DOTS，直接在每个 Update 中 for 每个鸟计算朝向和位置，这样性能是非常差的。</p>
<p>下图是把计算都放到 C# Update 中的 Profile：</p>
<p><a href="http://img.frankorz.com/boid-profile-1.png" data-fancybox="group" data-caption="C# 每个 Update 中直接计算" class="fancybox"><img src="http://img.frankorz.com/boid-profile-1.png" alt="C# 每个 Update 中直接计算" /></a></p>
<p>如果放到 Compute Shader 计算，每个 Update 更新数据，这样 CPU 消耗小了很多。</p>
<p><a href="http://img.frankorz.com/boid-profile-2.png" data-fancybox="group" data-caption="Compute Shader 计算，每个 Update 更新数据" class="fancybox"><img src="http://img.frankorz.com/boid-profile-2.png" alt="Compute Shader 计算，每个 Update 更新数据" /></a></p>
<p>感兴趣的朋友可以对比下 FlockingCPU.cs 和 FlockingGPU.cs 的代码，会发现两者的代码其实十分相似，只不过前者把 for loop 放到脚本，后者放到了 Compute Shader 中而已，因此如果大家觉得有一些地方十分适合并行计算，就可以考虑把这部分计算放到 GPU 计算。</p>
<h3 id="Profile-Compute-Shader">Profile Compute Shader</h3>
<p>我们可以通过 Profiler 来看 GPU 利用情况，通常这个面板是隐藏的，需要手动打开。</p>
<p>也可以通过 RenderDoc 来看，这里不展示。</p>
<p><a href="http://img.frankorz.com/boid-profile-3.png" data-fancybox="group" data-caption="boid-profile-3" class="fancybox"><img src="http://img.frankorz.com/boid-profile-3.png" alt="boid-profile-3" /></a></p>
<h3 id="优化：DrawMeshInstanced">优化：DrawMeshInstanced</h3>
<p>前面我们用 <code>Instantiate</code> 来初始化鸟群，其实我们也能通过 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/GPUInstancing.html">GPU instancing</a> 来优化，用 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Graphics.DrawMeshInstanced.html">Graphics.DrawMeshInstanced</a> 来实例化 prefab。这个优化未包含在 Github 例子中，这里提供思路。</p>
<p><a href="http://img.frankorz.com/boid-profile-4.png" data-fancybox="group" data-caption="boid-profile-4" class="fancybox"><img src="http://img.frankorz.com/boid-profile-4.png" alt="boid-profile-4" /></a></p>
<p>这么做的话，位置和旋转都要在传统 shader 中计算成变换矩阵应用在顶点上，因此为了防止 Compute Shader 数据传回 CPU 再传到 GPU 的传统 shader 的开销，需要两个 Shader 共享一个 <code>StructuredBuffer</code> 。</p>
<p>这样如果要给模型加动画的话，还得提前烘焙动画，将每一帧动画的顶点和当前帧数提前传到 vertex shader (or surface shader) 里做插值，这样做的话还能根据鸟的速度去控制动画的速率。</p>
<h2 id="应用">应用</h2>
<ul>
<li>遮挡剔除（<em>Occlusion Culling</em>）</li>
<li>环境光遮蔽（<em>Ambient Occlusion</em>）
<ul>
<li><a target="_blank" rel="noopener" href="https://www.anandtech.com/show/2848/2">AMD’s Radeon HD 5850: The Other Shoe Drops</a></li>
</ul>
</li>
<li> 程序化生成：
<ul>
<li>terrain heightmap evaluation with noise, erosion, and voxel algorithms</li>
</ul>
</li>
<li>AI 寻路
<ul>
<li>Compute Shader 做寻路有点不太好的就是往往游戏（CPU）需要知道计算结果，因此还要考虑 GPU 返回结果给 CPU 的延时。可以考虑做 CPU 端并行的方案，例如用 Job System。</li>
</ul>
</li>
<li>GPU 光线追踪
<ul>
<li><a target="_blank" rel="noopener" href="http://blog.three-eyed-games.com/2018/05/03/gpu-ray-tracing-in-unity-part-1/">GPU Ray Tracing in Unity – Part 1</a></li>
</ul>
</li>
<li> 图像处理，例如模糊化等。</li>
<li>其他你想放到 GPU，但是传统着色器干不了的并行的解决方案。</li>
</ul>
<h3 id="原神">原神</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Za4y1s7VL">Unity 线上技术大会 - 游戏专场｜从手机走向主机 -《原神》主机版渲染技术分享</a></p>
<p><a href="http://img.frankorz.com/genshin-render-compute-shader-1.png" data-fancybox="group" data-caption="Genshin 主机渲染管线简介" class="fancybox"><img src="http://img.frankorz.com/genshin-render-compute-shader-1.png" alt="Genshin 主机渲染管线简介" /></a></p>
<h4 id="解压预烘焙的-Shadow-Texture">解压预烘焙的 Shadow Texture</h4>
<p>在离线制作的时候，对于烘焙好的 shadow texture 做一个压缩，尽量地去保持精度，运行的时候解压的速度也非常快，用 Compute Shader 去解压的情况，1K×1K 的 shadow texture，解压只需要 0.05 毫秒。</p>
<p><a href="http://img.frankorz.com/genshin-render-compute-shader-2.png" data-fancybox="group" data-caption="解压预烘焙的 Shadow Texture" class="fancybox"><img src="http://img.frankorz.com/genshin-render-compute-shader-2.png" alt="解压预烘焙的 Shadow Texture" /></a></p>
<h4 id="做模糊处理">做模糊处理</h4>
<p>在进行模糊处理的时候，每个像素需要采取周边多个像素的数值进行混合，可以看到，如果使用传统的 PS，每个像素都会需要多次贴图采样，且这些采样结果实际上是可以在相邻其他像素的计算中进行重用的，因此为了进一步提升计算性能，《原神》这里的做法是将模糊处理放到 Compute Shader 中来完成。</p>
<p>具体的做法是，将相邻像素的采样结果存储在 <strong>局部存储空间（Local Data Share）</strong> 中，之后再模糊的时候取用，一次性完成四个像素的模糊计算，并将结果输出。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<h3 id="天涯明月刀">天涯明月刀</h3>
<p><a target="_blank" rel="noopener" href="http://youxiputao.com/articles/21061">《天涯明月刀》手游引擎技术负责人：如何应用 GPU Driven 优化渲染效果？| TGDC 2020</a></p>
<p><a href="http://img.frankorz.com/gpu-driven-compute-1.png" data-fancybox="group" data-caption="gpu-driven-compute-1" class="fancybox"><img src="http://img.frankorz.com/gpu-driven-compute-1.png" alt="gpu-driven-compute-1" /></a></p>
<p>做遮挡剔除（Occlusion Culling）时，CPU 只能做到 Object Level，而 GPU 可以通过切分 Mesh 做进一步的剔除。</p>
<p><a href="http://img.frankorz.com/gpu-driven-compute-2.png" data-fancybox="group" data-caption="gpu-driven-compute-2" class="fancybox"><img src="http://img.frankorz.com/gpu-driven-compute-2.png" alt="gpu-driven-compute-2" /></a></p>
<p>知乎上也有人尝试了实现：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352850047">Unity 实现 GPUDriven 地形</a>。</p>
<h3 id="Clay-Book">Clay Book</h3>
<p>基于 3D SDF 体渲染的黏土游戏：<a target="_blank" rel="noopener" href="https://www.claybookgame.com/">Claybook Game</a>。</p>
<p>演讲：<a target="_blank" rel="noopener" href="https://youtu.be/Xpf7Ua3UqOA?t=405">DD2018: Sebastian Aaltonen - GPU based clay simulation and ray tracing tech in Claybook</a></p>
<p>动图：<a target="_blank" rel="noopener" href="https://gfycat.com/gaseousterriblechupacabra">https://gfycat.com/gaseousterriblechupacabra</a></p>
<h3 id="Jelly-in-the-sky">Jelly in the sky</h3>
<p><a target="_blank" rel="noopener" href="https://www.reddit.com/r/Unity3D/comments/7j4hay/finished_my_compute_shader_based_game/">Finished my compute shader based game</a> 这帖子的哥们写了六千多行 HLSL 代码做了一个完全在 GPU 执行的基于物理模拟的游戏。</p>
<p>Steam：<a target="_blank" rel="noopener" href="https://store.steampowered.com/app/593530/Jelly_in_the_sky/">Jelly in the sky on Steam</a></p>
<p>动图：<a target="_blank" rel="noopener" href="https://gfycat.com/validsolidcanine">https://gfycat.com/validsolidcanine</a></p>
<h3 id="开源项目">开源项目</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/cinight/MinimalCompute">cinight/MinimalCompute</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/krylov-na/Compute-shader-particles">krylov-na/Compute-shader-particles</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/keijiro/Swarm">keijiro/Swarm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ellioman/Indirect-Rendering-With-Compute-Shaders">ellioman/Indirect-Rendering-With-Compute-Shaders</a></li>
</ul>
<h2 id="缺点">缺点</h2>
<p>虽然 Unity 帮我们做了跨平台的工作，但是我们仍然需要面对一些平台差异。</p>
<p>本小节内容大部分来自 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53785954">Compute Shader : Optimize your game using compute</a>。</p>
<ul>
<li>难 Debug</li>
<li><strong> 数组越界</strong>，DX 上会返回 0，其它平台会出错。</li>
<li>变量名与关键字 / 内置库函数<strong>重名</strong>，DX 无影响，其他平台会出错。</li>
<li>如果 SBuffer 内结构的显存布局与<strong>内存布局不一致</strong>，DX 可能会转换，其他平台会出错。</li>
<li><strong>未初始化</strong>的 SBuffer 或 Texture，在某些平台上会全部是 0，但是另外一些可能是任意值，甚至是 NaN。</li>
<li>Metal 不支持<strong>对纹理的原子操作</strong>，不支持对 SBuffer 调用 <code>GetDimensions</code>。</li>
<li>ES 3.1 在一个 CS 里<strong>至少支持 4 个 SBuffer</strong>（所以，我们需要将相关联的数据定义为 struct）。</li>
<li>ES 从 3.1 开始支持 CS，也就是说，在手机上的支持率并不是很高。部分号称支持 es 3.1+ 的 Android 手机只支持在片元着色器内访问 StructuredBuffer。
<ul>
<li>使用 <code>SystemInfo.supportsComputeShaders</code> 来判断支不支持 <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></li>
</ul>
</li>
</ul>
<h2 id="最后">最后</h2>
<p>我相信 Compute Shader 这个词不少读者应该都会在其他地方见过，但是大都觉得这个技术离我们还很远。我身边的朋友问了问也没怎么了解过，更不要说在项目上用了，这也是这篇文章诞生的原因之一。</p>
<p>开始碎碎念，去年的年终总结也没写，今年到现在就憋出一篇文章，十分不应该。其实也是自己没什么好分享的，自己还需要多学习。当然也很高兴通过博客认识到不同朋友，这是我写作的动力，谢谢你们。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/chenjd/Unity-Boids-Behavior-on-GPGPU">chenjd/Unity-Boids-Behavior-on-GPGPU</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74418914">关于 Compute Shader 的一些基础知识记录</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=0DLOJPSxJEg&amp;t=167s">Compute Shaders: Optimize your engine using compute / Lou Kramer, AMD</a></li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30426701/">《DirectX 12 3D 游戏开发实战》第 13 章 计算着色器</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hexiaolong2009/article/details/104088308">Render Hell —— 史上最通俗易懂的 GPU 入门教程（二）</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/445590537/answer/1742513246#comment-1265841070">知乎 - “问个 CUDA 并行上的小白问题，既然 SM 只能同时处理一个 WARP，那是不是有的 SP 处于闲置？” 的评论</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="http://youxiputao.com/articles/20948">米哈游技术总监分享：《原神》主机版渲染技术要点和解决方案</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68886986">ComputeShader 手机兼容性报告</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">猫冬</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://frankorz.com/2021/04/17/compute-shader/">http://frankorz.com/2021/04/17/compute-shader/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://frankorz.com" target="_blank">萤火之森</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><pangu> </pangu><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-57e27fcf6e91c81d" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgswechat-reward.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgswechat-reward.png" alt="wechat" /></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsalipay-reward.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsalipay-reward.jpg" alt="alipay" /></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/18/learn-pixel-art/"><img class="prev-cover" src="http://img.frankorz.com/day23-dog-in-snow.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" /><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">24 天像素画从入门到放弃</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/03/add-note-section-to-blog/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsadd-note-section-to-blog-cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" /><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">博客新增公开笔记部分</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/04/13/2020-04-tech-reading/" title="2020年4月技术导读"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg" alt="cover" /><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-13</div><div class="title">2020 年 4 月技术导读</div></div></a></div><div><a href="/2020/05/23/2020-05-tech-reading/" title="2020年5月技术导读"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg" alt="cover" /><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-23</div><div class="title">2020 年 5 月技术导读</div></div></a></div><div><a href="/2020/10/03/add-note-section-to-blog/" title="博客新增公开笔记部分"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsadd-note-section-to-blog-cover.png" alt="cover" /><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-03</div><div class="title">博客新增公开笔记部分</div></div></a></div></div></div><hr /><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgshead.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" /><div class="author-info__name">猫冬</div><div class="author-info__description">各种知识火种～</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Latias94"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Latias94" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:superfrankie621@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://weibo.com/u/1825527674" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到萤火之森🐈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text"> 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-Compute-Shader"><span class="toc-number">2.</span> <span class="toc-text"> 最简单的 Compute Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E5%B7%A5%E4%BD%9C%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text"> 如何划分工作：线程与线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E6%9E%84%E6%88%90%E7%9A%84-3D-%E7%BD%91%E6%A0%BC"><span class="toc-number">3.1.</span> <span class="toc-text"> 线程组构成的 3D 网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84-GPU-%E4%B9%8B%E6%97%85"><span class="toc-number">3.2.</span> <span class="toc-text"> 线程组的 GPU 之旅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.3.</span> <span class="toc-text"> 如何设置好线程组的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPU-Compute-Unit"><span class="toc-number">4.</span> <span class="toc-text">GPU Compute Unit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BA%A4%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text"> 线程间交流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%84%E9%97%B4%E7%9A%84%E4%BA%A4%E6%B5%81"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 多个线程组间的交流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%86%85%E7%9A%84%E4%BA%A4%E6%B5%81"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 单个线程组内的交流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Register-%E5%92%8C-Scalar-Register"><span class="toc-number">4.2.</span> <span class="toc-text">Vector Register 和 Scalar Register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9D%80%E8%89%B2%E5%99%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">4.3.</span> <span class="toc-text"> 与传统着色器执行流程的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vert-Frag-Shader"><span class="toc-number">4.3.1.</span> <span class="toc-text">Vert-Frag Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Compute-Shader"><span class="toc-number">4.3.2.</span> <span class="toc-text">Compute Shader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boids-%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">Boids 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.</span> <span class="toc-text"> 设置数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">5.2.</span> <span class="toc-text"> 获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%AB%AF%E8%AE%A1%E7%AE%97-vs-GPU-%E7%AB%AF%E8%AE%A1%E7%AE%97"><span class="toc-number">5.3.</span> <span class="toc-text">CPU 端计算 vs GPU 端计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profile-Compute-Shader"><span class="toc-number">5.4.</span> <span class="toc-text">Profile Compute Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9ADrawMeshInstanced"><span class="toc-number">5.5.</span> <span class="toc-text"> 优化：DrawMeshInstanced</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text"> 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A5%9E"><span class="toc-number">6.1.</span> <span class="toc-text"> 原神</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E9%A2%84%E7%83%98%E7%84%99%E7%9A%84-Shadow-Texture"><span class="toc-number">6.1.1.</span> <span class="toc-text"> 解压预烘焙的 Shadow Texture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E6%A8%A1%E7%B3%8A%E5%A4%84%E7%90%86"><span class="toc-number">6.1.2.</span> <span class="toc-text"> 做模糊处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E6%B6%AF%E6%98%8E%E6%9C%88%E5%88%80"><span class="toc-number">6.2.</span> <span class="toc-text"> 天涯明月刀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clay-Book"><span class="toc-number">6.3.</span> <span class="toc-text">Clay Book</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jelly-in-the-sky"><span class="toc-number">6.4.</span> <span class="toc-text">Jelly in the sky</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"><span class="toc-number">6.5.</span> <span class="toc-text"> 开源项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text"> 缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">8.</span> <span class="toc-text"> 最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">9.</span> <span class="toc-text"> 参考</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright"> ©2020 - 2021 By 猫冬</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span> 主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="beian.miit.gov.cn"><span>粤 ICP 备 19098175 号 - 1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text" /></div></div></div><hr /><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() =&gt; {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost &amp;&amp; panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" /><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css" /><script>(() =&gt; {
  document.querySelectorAll('#article-container span.katex-display').forEach(item =&gt; {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://frankorz.com/2021/04/17/compute-shader/'
    this.page.identifier = '2021/04/17/compute-shader/'
    this.page.title = 'Compute Shader 简介'
  };

  window.disqusReset = () =&gt; {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://frankorz.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://frankorz.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="_atssh" style="visibility: hidden; height: 1px; width: 1px; position: absolute; top: -9999px; z-index: 100000;"><iframe id="_atssh783" title="AddThis utility frame" style="height: 1px; width: 1px; position: absolute; top: 0px; z-index: 100000; border: 0px; left: 0px;" src="https://s7.addthis.com/static/sh.f48a1a04fe8dbf021b4cda1d.html#rand=0.34100411810076503&amp;iit=1619424632590&amp;tmr=load%3D1619424612752%26core%3D1619424612777%26main%3D1619424632576%26ifr%3D1619424632601&amp;cb=0&amp;cdn=0&amp;md=0&amp;kw=%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%2CShader&amp;ab=-&amp;dh=frankorz.com&amp;dr=&amp;du=http%3A%2F%2Ffrankorz.com%2F2021%2F04%2F17%2Fcompute-shader%2F&amp;href=http%3A%2F%2Ffrankorz.com%2F2021%2F04%2F17%2Fcompute-shader%2F&amp;dt=Compute%20Shader%20%E7%AE%80%E4%BB%8B&amp;dbg=0&amp;cap=tc%3D0%26ab%3D0&amp;inst=1&amp;jsl=1&amp;prod=undefined&amp;lng=zh&amp;ogt=image%2Clocale%2Cdescription%2Csite_name%2Curl%2Ctitle%2Ctype%3Darticle&amp;pc=men&amp;pub=ra-57e27fcf6e91c81d&amp;ssl=0&amp;sid=60867564ca3f3a6d&amp;srf=0.01&amp;ver=300&amp;xck=0&amp;xtr=0&amp;og=type%3Darticle%26title%3DCompute%2520Shader%2520%25E7%25AE%2580%25E4%25BB%258B%26url%3Dhttp%253A%252F%252Ffrankorz.com%252F2021%252F04%252F17%252Fcompute-shader%252Findex.html%26site_name%3D%25E8%2590%25A4%25E7%2581%25AB%25E4%25B9%258B%25E6%25A3%25AE%26description%3D%25E5%2581%259A%25E6%25B8%25B8%25E6%2588%258F%25E7%259A%2584%25E6%2597%25B6%25E5%2580%2599%25EF%25BC%258C%25E6%2588%2591%25E4%25BB%25AC%25E7%25BB%258F%25E5%25B8%25B8%25E8%25A6%2581%25E9%259D%25A2%25E5%25AF%25B9%25E5%2590%2584%25E7%25A7%258D%25E4%25BC%2598%25E5%258C%2596%25E9%2597%25AE%25E9%25A2%2598%25E3%2580%2582DOTS%2520%25E6%258A%2580%25E6%259C%25AF%25E6%25A0%2588%25E7%259A%2584%25E5%2587%25BA%25E7%258E%25B0%25E6%258F%2590%25E4%25BE%259B%25E4%25BA%2586%25E4%25B8%2580%25E7%25A7%258D%2520CPU%2520%25E7%25AB%25AF%25E7%259A%2584%25E5%25A4%259A%25E7%25BA%25BF%25E7%25A8%258B%25E6%2596%25B9%25E6%25A1%2588%25EF%25BC%258C%25E9%2582%25A3%25E4%25B9%2588%25E6%2588%2591%25E4%25BB%25AC%25E6%2598%25AF%25E5%2590%25A6%25E4%25B9%259F%25E8%2583%25BD%25E5%25B0%2586%25E4%25B8%2580%25E4%25BA%259B%25E8%25AE%25A1%25E7%25AE%2597%25E8%25BD%25AC%25E5%2588%25B0%2520GPU%2520%25E4%25B8%258A%25E9%259D%25A2%25EF%25BC%258C%25E4%25BB%258E%25E8%2580%258C%25E5%25B9%25B3%25E8%25A1%25A1%25E5%25A5%25BD%25E5%25AF%25B9%2520CPU%2520%25E5%2592%258C%2520GPU%2520%25E7%259A%2584%25E4%25BD%25BF%25E7%2594%25A8%25E5%2591%25A2%25EF%25BC%259F%25E5%25AF%25B9%25E6%2588%2591%25E8%2580%258C%25E8%25A8%2580%25EF%25BC%258C%25E4%25BB%25A5%25E5%2589%258D%25E4%25BD%25BF%25E7%2594%25A8%2520GPU%2520%25E6%2597%25A0%25E9%259D%259E%25E6%2598%25AF%25E9%2580%259A%25E8%25BF%2587%25E5%2586%2599%2520vert%252Ffrag%2520shader%25E3%2580%2581%25E5%2581%259A%25E5%25A5%25BD%25E6%25B8%25B2%25E6%259F%2593%25E7%259B%25B8%25E5%2585%25B3%25E7%259A%2584%25E8%25AE%25BE%25E7%25BD%25AE%25E7%25AD%2589%25E6%2593%258D%25E4%25BD%259C%25EF%25BC%258C%25E4%25BD%2586%25E5%25AE%259E%25E9%2599%2585%25E4%25B8%258A%25E6%2588%2591%25E4%25BB%25AC%25E8%25BF%2598%25E8%2583%25BD%25E4%25BD%25BF%25E7%2594%25A8%2520GPU%2520%25E7%259A%2584%25E8%25AE%25A1%25E7%25AE%2597%25E8%2583%25BD%25E5%258A%259B%25E6%259D%25A5%25E5%25B8%25AE%25E6%2588%2591%25E4%25BB%25AC%25E8%25A7%25A3%25E5%2586%25B3%25E9%2597%25AE%25E9%25A2%2598%25E3%2580%2582Compute%2520Shader%2520%25E5%25B0%25B1%25E6%2598%25AF%25E6%2588%2591%25E4%25BB%25AC%25E8%25B7%259F%2520GPU%26locale%3Dzh_CN%26image%3Dhttps%253A%252F%252Fcdn.jsdelivr.net%252Fgh%252Flatias94%252Fblog-images%2540main%252Ftop%252Ffrankorz%252Fblog%252Fimgscompute-shader-cover.jpg&amp;csi=undefined&amp;rev=v8.28.8-wp&amp;ct=1&amp;xld=1&amp;xd=1"></iframe></div><style id="service-icons-0"></style></body></html>