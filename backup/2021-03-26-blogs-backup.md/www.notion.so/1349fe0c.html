---
title : 自动快照存档
---

* TIME: 2021-04-26 15:57:27
* URL: <https://www.notion.so/ce300124a4444c2cacc90a5ea0a5a19b>

-----

![🖥️](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

图形学常见的变换推导

Comment

Search

Notion

![🖥️](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)![🖥️](https://notion-
emojis.s3-us-west-2.amazonaws.com/v0/svg-twitter/1f5a5-fe0f.svg)

图形学常见的变换推导

[线性变换](/ce300124a4444c2cacc90a5ea0a5a19b#b59e4db5bbde455d8e421e15adc19bb5)

[Scale
Matrix](/ce300124a4444c2cacc90a5ea0a5a19b#5f15f48ec8c04e3da5c73bf2206971a7)

[Scale (Non-
Uniform)](/ce300124a4444c2cacc90a5ea0a5a19b#de9948afa648452ababbd63c4372486e)

[Reflection
Matrix](/ce300124a4444c2cacc90a5ea0a5a19b#ebbcf20f33464d7989fb0551adc58c5d)

[Shear
Matrix](/ce300124a4444c2cacc90a5ea0a5a19b#3c22d5d6b6a04bdaaee740cc67f814ff)

[2D Rotation
Matrix](/ce300124a4444c2cacc90a5ea0a5a19b#0db715ab789641cc83732bdbdd98a041)

[齐次坐标](/ce300124a4444c2cacc90a5ea0a5a19b#3b3965ff8a2e4189b043c73b4eb9b66d)

[Translation](/ce300124a4444c2cacc90a5ea0a5a19b#280149e3e8c540c3902266d0731df7f2)

[Affine Transformations
仿射变换](/ce300124a4444c2cacc90a5ea0a5a19b#bf9521b471d941619c3d82f1f78ea792)

[2D
Transformations](/ce300124a4444c2cacc90a5ea0a5a19b#db4f0888917b4a3f860360b72394f968)

[Scale](/ce300124a4444c2cacc90a5ea0a5a19b#00e1b3579ff34a379a9070b69146a351)

[Rotation](/ce300124a4444c2cacc90a5ea0a5a19b#8095f06432334637906024c157c5cfdb)

[Translation](/ce300124a4444c2cacc90a5ea0a5a19b#7850801daa88456880f1330c48261d1a)

[逆变换](/ce300124a4444c2cacc90a5ea0a5a19b#6a4bc9014a9e4601bee3c686e75f5904)

[三维变换](/ce300124a4444c2cacc90a5ea0a5a19b#8e4fd54efcda492ebe5b581fad72c440)

[Scale](/ce300124a4444c2cacc90a5ea0a5a19b#0d42c61c549a44489bc425b9f06e9e9d)

[Translation](/ce300124a4444c2cacc90a5ea0a5a19b#7b03d850f5d74117a4db7fbf6cab6886)

[Rotation](/ce300124a4444c2cacc90a5ea0a5a19b#945cfe73c6ea4b84ae579287a848a9a2)

[绕轴旋转](/ce300124a4444c2cacc90a5ea0a5a19b#2ea467948c0049c1b67c3ee48c172f3a)

[Rodrigues' Rotation Formula
](/ce300124a4444c2cacc90a5ea0a5a19b#8fa6a1bfb55a49879c98fb50cfefc86f)

[四元数相关](/ce300124a4444c2cacc90a5ea0a5a19b#24d93566d37f4a97b9d89e96f75a5a99)

[View/Camera Transformation
视图变换](/ce300124a4444c2cacc90a5ea0a5a19b#904735b521574f03b472d5735bf02415)

[定义相机](/ce300124a4444c2cacc90a5ea0a5a19b#a5772602b24d4f54b7b5212e9f430615)

[视图变换](/ce300124a4444c2cacc90a5ea0a5a19b#ec74629744234b4aa404ebcefecf4fa9)

[求视图变换矩阵](/ce300124a4444c2cacc90a5ea0a5a19b#a1ff2ff4354c40439365e216c3fea9f0)

[Projection Transformation
投影变换](/ce300124a4444c2cacc90a5ea0a5a19b#249a4c171a4f48738c41333454ae1153)

[Perspective projection vs. orthographic
projection](/ce300124a4444c2cacc90a5ea0a5a19b#1f706ff5650c4db6a8ad842e06f2b78f)

[Orthographic Projection
正交投影](/ce300124a4444c2cacc90a5ea0a5a19b#4e7373e7334c40eba2a39541431a0366)

[方法一](/ce300124a4444c2cacc90a5ea0a5a19b#f859cfcec1c248aea04f5d70e63b066f)

[方法二](/ce300124a4444c2cacc90a5ea0a5a19b#55359a2141474721b66897c6746be505)

[Perspective Projection
透视投影](/ce300124a4444c2cacc90a5ea0a5a19b#d18d16d33d894c8daf995bcf571568a9)

[Recall](/ce300124a4444c2cacc90a5ea0a5a19b#6a1c645e086a451896ab318721deafda)

[怎么做透视投影](/ce300124a4444c2cacc90a5ea0a5a19b#63885745f5fe4c6492e46f3f2d28346a)

[求出任何一个点挤压后的 x', y'
值](/ce300124a4444c2cacc90a5ea0a5a19b#0dac07bcd6534cefbb83b350f46bc936)

[求出任何一个点挤压后的 z’
值](/ce300124a4444c2cacc90a5ea0a5a19b#20174e242e20427296f363a3c7074552)

[定义视锥](/ce300124a4444c2cacc90a5ea0a5a19b#ac9b618e71c54fae80c51076d64d3918)

[完成推导正交投影矩阵](/ce300124a4444c2cacc90a5ea0a5a19b#c95d1b178ac14e46a42b3411a3da389e)

[完成推导透视投影矩阵](/ce300124a4444c2cacc90a5ea0a5a19b#521e50b0b80a438580dc6971f050bb7f)

[后记](/ce300124a4444c2cacc90a5ea0a5a19b#a2b26d93d23c48b8af9fa8ab5d518d2f)

本文是 Games101-现代计算机图形学入门 第三第四节课的笔记，相关视频在下方。

[www.bilibili.comhttps://www.bilibili.com/video/BV1X7411F744?p=3](https://www.bilibili.com/video/BV1X7411F744?p=3)

[www.bilibili.comhttps://www.bilibili.com/video/BV1X7411F744?p=4](https://www.bilibili.com/video/BV1X7411F744?p=4)

本文同时参考了《Unity Shader 入门精要》的第四章，作者公开了第四章的 PDF，可以在下面下载到。

[candycat1992/Unity_Shaders_Book本项目是书籍《Unity Shader入门精要》的配套源代码。最新版本请移步
本项目的Github页面 。 我们推荐您从Github上clone项目源码并及时检查更新。如果下载速度过慢可以移步 百度网盘地址 。
我们提供了包含书中所有插图的彩色版插图集锦： HTML， PDF 。 当年乐观地以为自己有时间写第二版，是我太年轻了......
第一版由于我能力有限的确有很多问题，感谢大家一直以来的支持。当年在我有时间的时候曾经花了一些时间重写了第18章，本来是想要放到第二版里的，但是目前第二版遥遥无期，索性直接把改版后的第18章直接放出来，希望能让读者有新的收获：
改版后的第18章 。 由于数学章是全书的重要基础，我们决定把第四章公开，来及时让读者获取最新的第四章数学章的内容： PDF 。 注意
：我们可能会根据读者勘误随时更新该文档，内容和页号可能会与读者手中的版本不同，实体书中的勘误会在每次重印时进行修正。
尽管我们在本书的编写过程中多次检查内容的正确性，但不可避免书中仍然会出现一些错误，欢迎读者批评指正。任何关于本书内容、源码等方面的问题，欢迎读者反映到本书源码所在的
Github讨论页，也可以发邮件（ lelefeng1992@gmail.com ）联系笔者。 关于目前 已发现的错误我们会及时在网上更新： 勘误列表 。
我们也维护了读者反馈的问题列表： FAQ 。 我们 推荐使用Unity 5.0以上的版本来编译本项目。如果你打算
使用更低版本的Unity，那么在学习本书时可能就会遇到一些问题 ：
你可能发现会有些菜单或变量在你的Unity中找不到，这可能就是由于Unity版本不同造成的。绝大多数情况下，本书的代码和指令仍然可以工作良好，但在一些特殊情况下，Unity可能会更改底层的实现细节，造成同样的代码会得到不一样的效果（例如，在非统一缩放时对法线进行变换）。
还有一些问题是Unity提供的内置变量、宏和函数，例如我们在书中经常会使用UnityObjectToWorldNormal内置函数把法线从模型空间变换到世界空间中，但这个函数是在Unity
5中才被引入的，因此如果读者使用的是Unity 5之前的版本就会报错。类似的情况还有和阴影相关的宏和变量等。 和Unity 4.x版本相比，Unity
5.x最大的变化之一就是很多以前只有在专业版才支持的功能，在免费版也同样提供了。因此，如果读者使用的是Unity
4.x免费版，可能会发现本书中的某些材质会出错。 在本书编写时，我们使用的版本是Unity 5.3，因此使用这些Unity版本的读者请使用本项目
master 分支的相关代码。 Unity 5.4对Shader部分进行了一些比较大的更新，比较明显的变化有：
使用了unity_XXX来代替原有的XXX变换矩阵，例如_Object2World被替换成了unity_ObjectToWorld，_World2Object被替换成了unity_WorldToObject（均在UnityShaderVariables.cginc文件中被声明），_LightMatrix0被替换成了unity_WorldToLight（在AutoLight.cginc文件中被声明）。
使用了一些内置函数来代替某些运算，例如mul(UNITY_MATRIX_MVP,)相关计算被替换成了UnityObjectToClipPos()。
在学习本书时，读者需要注意代码中一些由于更新造成的变化。 从Unity 5.5开始，Unity在某些平台（如DX11、DX12、PS4、Xbox
One、Metal）等平台对深度缓存进行了反转操作，使得在近平面处的深度值为1，而远平面处为0。这样做的原因主要是为了更加充分得利用浮点深度缓存，具体原因可以参见NVIDIA的相关博客
Depth Precision Visualized。Unity在 Upgrading to Unity 5.5和 Platform-specific
rendering differences 文档中对此进行了说明。
在本书代码中，我们在第13章用到了深度纹理，其中对于使用了Linear01Depth、LinearEyeDepth等Unity内置函数的部分不受此变化影响，但我们在Chapter13-MotionBlurWithDepthTexture中直接访问了深度值来计算世界空间下的坐标：
// Get the depth buffer value at this
pixel.![](/image/https%3A%2F%2Fgithub.com%2Ffavicon.ico?table=block&id=b6fee874-d7c1-4012-9f78-377e08077b09&userId=&cache=v2)https://github.com/candycat1992/Unity_Shaders_Book#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%8B%98%E8%AF%AF![](https://avatars1.githubusercontent.com/u/5907064?s=400&v=4)](https://github.com/candycat1992/Unity_Shaders_Book#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%8B%98%E8%AF%AF)

闫老师的推导十分简洁易懂，我也尽量把过程补充到文章中，读者看了我相信肯定也能跟着思路把变换公式推导出来。

在读本文的过程中，也推荐参考上面提到的视频和 pdf 互相参考，本文是视频中推导的详细笔记，冯乐乐的 pdf
中虽然没有投影变换的推导，但是在很多地方都把理论讲的十分清晰，例如必要的数学基础和各种图形学概念的讲解。

线性变换

x′=ax+byy′=cx+dy\begin{array}{l}x^{\prime}=a x+b y \\\ y^{\prime}=c x+d
y\end{array}x′=ax+byy′=cx+dy​

如果我们可以把变换写成这样一种形式，矩阵乘以输入坐标等于输出坐标，这样可以叫做线性变换。

[x′y′]=[abcd][xy]\left[\begin{array}{l}x^{\prime} \\\
y^{\prime}\end{array}\right]=\left[\begin{array}{ll}a & b \\\ c &
d\end{array}\right]\left[\begin{array}{l}x \\\
y\end{array}\right][x′y′​]=[ac​bd​][xy​]

x′=Mx\mathbf{x}^{\prime}=\mathbf{M} \mathbf{x}x′=Mx

Scale Matrix

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F7980791e-d4d5-459e-92a7-dc873238b93d%2FUntitled.png?table=block&id=6c54d524-cd13-4bc0-943e-d5335afa2508&width=4580&userId=&cache=v2)

x′=sxy′=sy\begin{array}{l}x^{\prime}=s x \\\ y^{\prime}=s
y\end{array}x′=sxy′=sy​

其变换矩阵：

[x′y′]=[s00s][xy]\left[\begin{array}{l}x^{\prime} \\\
y^{\prime}\end{array}\right]=\left[\begin{array}{ll}s & 0 \\\ 0 &
s\end{array}\right]\left[\begin{array}{l}x \\\
y\end{array}\right][x′y′​]=[s0​0s​][xy​]

Scale (Non-Uniform)

x y 可以不均匀地缩放

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2Fbf5e9ed4-c0cc-4b1e-8871-918810c0295b%2FUntitled.png?table=block&id=de235101-40b5-4830-aaca-3779e9228df4&width=4560&userId=&cache=v2)

[x′y′]=[sx00sy][xy]\left[\begin{array}{l}x^{\prime} \\\
y^{\prime}\end{array}\right]=\left[\begin{array}{ll}s_{x} & 0 \\\ 0 &
s_{y}\end{array}\right]\left[\begin{array}{l}x \\\
y\end{array}\right][x′y′​]=[sx​0​0sy​​][xy​]

Reflection Matrix

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F0019d9e0-5276-4fdb-8959-113624c42c51%2FUntitled.png?table=block&id=f61a183f-e92c-4178-aab6-07a330c7d0f7&width=4440&userId=&cache=v2)

Horizontal reflection:

x′=−xy′=y\begin{array}{l}x^{\prime}=-x \\\ y^{\prime}=y\end{array}x′=−xy′=y​

[x′y′]=[−1001][xy]\left[\begin{array}{l}x^{\prime} \\\
y^{\prime}\end{array}\right]=\left[\begin{array}{cc}-1 & 0 \\\ 0 &
1\end{array}\right]\left[\begin{array}{l}x \\\
y\end{array}\right][x′y′​]=[−10​01​][xy​]

Shear Matrix

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F32529a83-94b1-45a5-b395-f5b500260cb2%2FUntitled.png?table=block&id=b359667c-b183-4ca1-9d7b-b455b0f0f645&width=2230&userId=&cache=v2)

2D Rotation Matrix

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F5a2649b5-4b3d-4b42-bfbc-2e4cf2118e84%2FUntitled.png?table=block&id=f2ea72d5-2355-4361-a753-b5f140596af0&width=2280&userId=&cache=v2)

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2Fce8cb656-0bc3-4f0d-b34f-cc7fa06f61fd%2FUntitled.png?table=block&id=a1c0da52-be95-4887-8e03-5edcdfb1c979&width=2160&userId=&cache=v2)

齐次坐标

Translation

平移变换非常特殊。

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F0fc232ed-4f78-4c20-a3fe-6c934f75d3d1%2FUntitled.png?table=block&id=33ad5eab-98a0-4d95-8315-dfbbb9ea76db&width=4510&userId=&cache=v2)

x′=x+txy′=y+ty\begin{array}{l}x^{\prime}=x+t_{x} \\\
y^{\prime}=y+t_{y}\end{array}x′=x+tx​y′=y+ty​​

写出来简单，但是两个式子不能写成线性变换的形式。

[x′y′]=[abcd][xy]\left[\begin{array}{l}x^{\prime} \\\
y^{\prime}\end{array}\right]=\left[\begin{array}{ll}a & b \\\ c &
d\end{array}\right]\left[\begin{array}{l}x \\\
y\end{array}\right][x′y′​]=[ac​bd​][xy​]

只能写成：

[x′y′]=[abcd][xy]+[txty]\left[\begin{array}{l}x^{\prime} \\\
y^{\prime}\end{array}\right]=\left[\begin{array}{ll}a & b \\\ c &
d\end{array}\right]\left[\begin{array}{l}x \\\
y\end{array}\right]+\left[\begin{array}{l}t_{x} \\\
t_{y}\end{array}\right][x′y′​]=[ac​bd​][xy​]+[tx​ty​​]

因此平移变换并不是线性变换。

但是我们不希望将平移变换看作一个特殊的例子，那么有没有办法将缩放、错切、平移等变换用一种统一的方式来表示？

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

在计算机科学，永远要考虑“Trade-
Off”。数据结构中不同降低时间复杂度的办法都会引入空间复杂度。如果两者都能低就很好，但更多时候是非此即彼的事情。“No Free Lunch
Theory”。

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F789fbf68-a4dd-4c42-8d17-4d1db7b08a58%2FUntitled.png?table=block&id=f5ad08b5-eb33-48d6-9bab-393048a16adb&width=1950&userId=&cache=v2)

引入齐次坐标，可以通过增加一个维度来将平移变换也写成矩阵乘一个点的形式。

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

向量具有平移不变性，因此后面是 (x, y, 0)，平移变换后也不变。

我们也可以通过 w 分量来推出我们操作的结果：

Valid operation if w-coordinate of result is 1 or 0

•

vector + vector = vector

•

point – point = vector

•

point + vector = point

•

point + point = ??

Affine Transformations 仿射变换

Affine map = linear map + translation

(x′y′)=(abcd)⋅(xy)+(txty)\left(\begin{array}{l}x^{\prime} \\\
y^{\prime}\end{array}\right)=\left(\begin{array}{ll}a & b \\\ c &
d\end{array}\right) \cdot\left(\begin{array}{l}x \\\
y\end{array}\right)+\left(\begin{array}{l}t_{x} \\\
t_{y}\end{array}\right)(x′y′​)=(ac​bd​)⋅(xy​)+(tx​ty​​)

Using homogenous coordinates:

(x′y′1)=(abtxcdty001)⋅(xy1)\left(\begin{array}{l}x^{\prime} \\\ y^{\prime} \\\
1\end{array}\right)=\left(\begin{array}{ccc}a & b & t_{x} \\\ c & d & t_{y}
\\\ 0 & 0 & 1\end{array}\right) \cdot\left(\begin{array}{l}x \\\ y \\\
1\end{array}\right)⎝⎛​x′y′1​⎠⎞​=⎝⎛​ac0​bd0​tx​ty​1​⎠⎞​⋅⎝⎛​xy1​⎠⎞​

2D Transformations

Scale

S(sx,sy)=(sx000sy000 1 )\mathbf{S}\left(s_{x},
s_{y}\right)=\left(\begin{array}{ccc}s_{x} & 0 & 0 \\\ 0 & s_{y} & 0 \\\ 0 & 0
& \text { 1 }\end{array}\right)S(sx​,sy​)=⎝⎛​sx​00​0sy​0​00 1 ​⎠⎞​

Rotation

R(α)=(cos⁡α−sin⁡α0sin⁡αcos⁡α0001)\mathbf{R}(\alpha)=\left(\begin{array}{ccc}\cos
\alpha & -\sin \alpha & 0 \\\ \sin \alpha & \cos \alpha & 0 \\\ 0 & 0 &
1\end{array}\right)R(α)=⎝⎛​cosαsinα0​−sinαcosα0​001​⎠⎞​

Translation

T(tx,ty)=(10tx01ty001)\mathbf{T}\left(t_{x},
t_{y}\right)=\left(\begin{array}{ccc}1 & 0 & t_{x} \\\ 0 & 1 & t_{y} \\\ 0 & 0
& 1\end{array}\right)T(tx​,ty​)=⎝⎛​100​010​tx​ty​1​⎠⎞​

逆变换

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F442dd652-02ee-4412-a2cb-
dba9ce724635%2FUntitled.png?table=block&id=9545ccd1-3646-47f5-9498-dfbe259746ed&width=2150&userId=&cache=v2)

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F324b9f09-3c22-45e3-93ac-c63834fbbd60%2FUntitled.png?table=block&id=16800608-c22f-4a01-95d1-934132ecadef&width=2290&userId=&cache=v2)

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F14e201af-
dcab-416a-8342-9b877c6c2912%2FUntitled.png?table=block&id=cc30360b-7c01-4548-8c01-93857e1ee05a&width=2290&userId=&cache=v2)

因此变换顺序是很重要的，不满足交换律。

R45⋅T(1,0)≠T(1,0)⋅R45R_{45} \cdot T_{(1,0)} \neq T_{(1,0)} \cdot
R_{45}R45​⋅T(1,0)​=T(1,0)​⋅R45​

矩阵是从右到左运算的：

T(1,0)⋅R45[xy1]=[101010001][cos⁡45∘−sin⁡45∘0sin⁡45∘cos⁡45∘0001][xy1]T_{(1,0)}
\cdot R_{45}\left[\begin{array}{l}x \\\ y \\\
1\end{array}\right]=\left[\begin{array}{ccc}1 & 0 & 1 \\\ 0 & 1 & 0 \\\ 0 & 0
& 1\end{array}\right]\left[\begin{array}{ccc}\cos 45^{\circ} & -\sin
45^{\circ} & 0 \\\ \sin 45^{\circ} & \cos 45^{\circ} & 0 \\\ 0 & 0 &
1\end{array}\right]\left[\begin{array}{l}x \\\ y \\\
1\end{array}\right]T(1,0)​⋅R45​⎣⎡​xy1​⎦⎤​=⎣⎡​100​010​101​⎦⎤​⎣⎡​cos45∘sin45∘0​−sin45∘cos45∘0​001​⎦⎤​⎣⎡​xy1​⎦⎤​

矩阵没有交换律，但有结合律。

An(…A2(A1(x)))=An⋯A2⋅A1⋅(xy1)A_{n}\left(\ldots
A_{2}\left(A_{1}(\mathbf{x})\right)\right)=\mathbf{A}_{n} \cdots
\mathbf{A}_{2} \cdot \mathbf{A}_{1} \cdot\left(\begin{array}{l}x \\\ y \\\
1\end{array}\right)An​(…A2​(A1​(x)))=An​⋯A2​⋅A1​⋅⎝⎛​xy1​⎠⎞​

将 An⋯A2⋅A1\mathbf{A}_{n} \cdots \mathbf{A}_{2} \cdot \mathbf{A}_{1}
An​⋯A2​⋅A1​﻿ 结合成一个变换矩阵。

三维变换

齐次坐标系下的三维变换可以写成下面的形式

(x′y′z′1)=(abctxdeftyghitz0001)⋅(xyz1)\left(\begin{array}{l}x^{\prime} \\\
y^{\prime} \\\ z^{\prime} \\\ 1\end{array}\right)=\left(\begin{array}{llll}a &
b & c & t_{x} \\\ d & e & f & t_{y} \\\ g & h & i & t_{z} \\\ 0 & 0 & 0 &
1\end{array}\right) \cdot\left(\begin{array}{l}x \\\ y \\\ z \\\
1\end{array}\right)⎝⎛​x′y′z′1​⎠⎞​=⎝⎛​adg0​beh0​cfi0​tx​ty​tz​1​⎠⎞​⋅⎝⎛​xyz1​⎠⎞​

Scale

S(sx,sy,sz)=(sx0000sy0000sz00001)\mathbf{S}\left(s_{x}, s_{y},
s_{z}\right)=\left(\begin{array}{cccc}s_{x} & 0 & 0 & 0 \\\ 0 & s_{y} & 0 & 0
\\\ 0 & 0 & s_{z} & 0 \\\ 0 & 0 & 0 &
1\end{array}\right)S(sx​,sy​,sz​)=⎝⎛​sx​000​0sy​00​00sz​0​0001​⎠⎞​

Translation

T(tx,ty,tz)=(100tx010ty001tz0001)\mathbf{T}\left(t_{x}, t_{y},
t_{z}\right)=\left(\begin{array}{cccc}1 & 0 & 0 & t_{x} \\\ 0 & 1 & 0 & t_{y}
\\\ 0 & 0 & 1 & t_{z} \\\ 0 & 0 & 0 &
1\end{array}\right)T(tx​,ty​,tz​)=⎝⎛​1000​0100​0010​tx​ty​tz​1​⎠⎞​

Rotation

绕轴旋转

Rotation around x-, y-, or z-axis

Rx(α)=(10000cos⁡α−sin⁡α00sin⁡αcos⁡α00001)\mathbf{R}_{x}(\alpha)=\left(\begin{array}{cccc}1
& 0 & 0 & 0 \\\ 0 & \cos \alpha & -\sin \alpha & 0 \\\ 0 & \sin \alpha & \cos
\alpha & 0 \\\ 0 & 0 & 0 &
1\end{array}\right)Rx​(α)=⎝⎛​1000​0cosαsinα0​0−sinαcosα0​0001​⎠⎞​

Ry(α)=(cos⁡α0sin⁡α00100−sin⁡α0cos⁡α00001)\mathbf{R}_{y}(\alpha)=\left(\begin{array}{cccc}\cos
\alpha & 0 & \sin \alpha & 0 \\\ 0 & 1 & 0 & 0 \\\ -\sin \alpha & 0 & \cos
\alpha & 0 \\\ 0 & 0 & 0 &
1\end{array}\right)Ry​(α)=⎝⎛​cosα0−sinα0​0100​sinα0cosα0​0001​⎠⎞​

Rz(α)=(cos⁡α−sin⁡α00sin⁡αcos⁡α0000100001)\mathbf{R}_{z}(\alpha)=\left(\begin{array}{cccc}\cos
\alpha & -\sin \alpha & 0 & 0 \\\ \sin \alpha & \cos \alpha & 0 & 0 \\\ 0 & 0
& 1 & 0 \\\ 0 & 0 & 0 &
1\end{array}\right)Rz​(α)=⎝⎛​cosαsinα00​−sinαcosα00​0010​0001​⎠⎞​

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F607945bd-0ec9-445b-bbe9-a2a9cbe42a7a%2FUntitled.png?table=block&id=3eb5ad06-e917-4026-8424-b0e490631bdd&width=810&userId=&cache=v2)

绕着 x 轴旋转，说明 y 和 z 都是在进行旋转的，但 x 不变。因此绕 x 轴的旋转矩阵相比二维的旋转矩阵，第一行是不变的。中间部分和二维旋转矩阵一样。

绕 y 轴旋转不一样，这里涉及到我们要如何思考轴的相互顺序。

根据右手螺旋定则，x 叉乘 y 得到 z，y 叉乘 z 得到 x。但 z 叉乘 x 才能得到 y，是反的，因此 Ry 部分不一样。

Rodrigues' Rotation Formula

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

我们能够解决一些简单的问题，复杂的问题可以转化成一些简单问题的组合。

给定根据三个轴的旋转，能否将某一个方向旋转到任意一个方向上去？

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F611047f3-405d-48f4-9f3c-d7ea806bc2ad%2FUntitled.png?table=block&id=8be61fba-7904-453f-9975-787da9b687ee&width=2080&userId=&cache=v2)

Rotation by angle α round axis n

有人将任意一个旋转分解成通过 x y z 轴分别做旋转。

R(n,α)=cos⁡(α)I+(1−cos⁡(α))nnT+sin⁡(α)(0−nznynz0−nx−nynx0)\mathbf{R}(\mathbf{n},
\alpha)=\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n}
\mathbf{n}^{T}+\sin (\alpha)\left(\begin{array}{ccc}0 & -n_{z} & n_{y} \\\
n_{z} & 0 & -n_{x} \\\ -n_{y} & n_{x} &
0\end{array}\right)R(n,α)=cos(α)I+(1−cos(α))nnT+sin(α)⎝⎛​0nz​−ny​​−nz​0nx​​ny​−nx​0​⎠⎞​

证明过程可以参考闫令琪老师的证明：

GAMES101_Lecture_04_supp.pdf

660.9KB

公式给了我们一个旋转矩阵，定义中给了我们一个旋转轴 n 和旋转角度
α。旋转角度好理解，但旋转轴似乎不能这么简单地定义。因为一个旋转轴首先跟起点有关系，然后跟方向有关系，只给一个向量是不是不太合适？

假如说沿着 y 轴旋转，跟沿着 xxx﻿ 和 nnn﻿ 各等于 1 并且也是沿着 y
方向的向量。方向一样，但起点不一样，结果肯定也是不一样的。因此我们说沿着某个轴的方向旋转，就默认了是过原点的，这样起点就在原点上，方向就是 nnn﻿ 方向。

那么如果轴 n
可以平移怎么办？那么我们可以将其进行变换的分解。如果我们要沿着任意轴旋转且轴的起点不在原点，我们可以将所有的东西移到起点为原点的条件下，再旋转，再移回去。

四元数相关

我们上面所用到的旋转矩阵是不太适合做插值的，例如二维旋转 10 度的旋转矩阵加二维旋转 20 度的旋转矩阵求平均，不能得到二维旋转 15
度的旋转矩阵。四元数在这方面方便很多。

View/Camera Transformation 视图变换

定义相机

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F2332df3b-7a09-49fd-93dc-55db9277d2f6%2FUntitled.png?table=block&id=f33bc6a2-8a49-436d-9e45-ef44577c2bf2&width=4550&userId=&cache=v2)

定义一个相机需要三个变量，位置，朝向，和一个向上的方向。

视图变换

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F2dbd3f56-afbd-4662-8b6b-308c947e6d9c%2FUntitled.png?table=block&id=96c4a7cb-e9be-4737-b1fa-279445a16b52&width=4490&userId=&cache=v2)

当相机和要拍的东西一起移动的时候，那拍出来的相片是一样的。也就是说，当我们移动物体时，只要同时以相同的方式移动相机，没有相对位置，那么得出来的结果就是一样的。

如果我们将相机放在一个固定的位置上，那么所有东西在移动时，都可以认为是其他东西在移动，而相机一直在原点不动。相机永远往 −z-z−z﻿ 方向看，以 yyy﻿
轴为向上方向（右手坐标系，符合 OpenGL 传统）。这是约定俗成的。相机放在原点有很多好处，能简化计算。

从坐标空间的角度来看，就是将物体和相机从世界空间转到观察空间（摄像机空间）。

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F1ff99d52-c5c1-4820-8a85-393663a179a3%2FUntitled.png?table=block&id=7a75b8b1-0a5c-49ce-b9da-
efdb930a9eda&width=4430&userId=&cache=v2)

我们要将相机移到原点，就需要先把相机中心 eee﻿ 平移到原点，还得把观察的方向 ggg﻿ 移到 −z-z−z﻿ 上，再把向上方向 ttt﻿ 旋转到
yyy﻿ 方向上，把 g^×t^\hat{g}\times \hat{t}g^​×t^﻿ 的方向移到 xxx﻿ 方向上。

下面将这系列操作转为矩阵操作。

求视图变换矩阵

1.

先把相机中心 eee﻿ 平移到原点

MviewM_{v i e w}Mview​﻿ in math?

•

Let’s write Mview=RviewTviewM_{v i e w}=R_{v i e w} T_{v i e
w}Mview​=Rview​Tview​﻿

•

Translate eee﻿ to origin

Tview=[100−xe010−ye001−ze0001]T_{v i e w}=\left[\begin{array}{cccc}1 & 0 & 0 &
-x_{e} \\\ 0 & 1 & 0 & -y_{e} \\\ 0 & 0 & 1 & -z_{e} \\\ 0 & 0 & 0 &
1\end{array}\right]Tview​=⎣⎡​1000​0100​0010​−xe​−ye​−ze​1​⎦⎤​

平移矩阵写好后，接下来写旋转矩阵。

2\. 把观察的方向 g^\hat{g}g^​﻿ 旋转到 −z-z−z﻿ 上，把向上方向 t^\hat{t}t^﻿ 旋转到 yyy﻿
方向上，g^×t^\hat{g}\times \hat{t}g^​×t^﻿ 的方向旋转到 xxx﻿ 方向上

•

Rotate g^\hat{g}g^​﻿ to −Z-Z−Z﻿ , t^\hat{t}t^﻿ to YYY﻿, g^×t^\hat{g}\times
\hat{t}g^​×t^﻿ To XXX﻿ （世界空间到观察空间）

•

Consider its inverse rotation: XXX﻿ to g^×t^\hat{g}\times \hat{t}g^​×t^﻿ ,
YYY﻿ to t^\hat{t}t^﻿, ZZZ﻿ to −g^-\hat{g}−g^​﻿ （观察空间到世界空间）

我们可以反过来写，例如把 xxx﻿ 轴 (1,0,0)\left( 1,0,0 \right) (1,0,0)﻿ 旋转到
g^×t^\hat{g}\times \hat{t}g^​×t^﻿ 方向上的旋转矩阵，就比 g^×t^\hat{g}\times
\hat{t}g^​×t^﻿ 移到 xxx﻿ 轴的旋转矩阵要好写很多，而这两个旋转矩阵是互逆的。写出 xxx﻿ 轴旋转到
g^×t^\hat{g}\times \hat{t}g^​×t^﻿ 方向的旋转矩阵后，再求其逆变换就是我们所需要的 g^×t^\hat{g}\times
\hat{t}g^​×t^﻿ 移到 xxx﻿ 轴的旋转矩阵。

XXX﻿ to g^×t^\hat{g}\times \hat{t}g^​×t^﻿ , YYY﻿ to t^\hat{t}t^﻿, ZZZ﻿ to
−g^-\hat{g}−g^​﻿ 的旋转矩阵就是：

![⚠️](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

这里 ZZZ﻿ to −g^-\hat{g}−g^​﻿ 是因为我们定义相机的坐标空间为右手坐标系。

Rview−1=[xg^×t^xtx−g0yg^×t^yty−g0zg^×t^ztz−g00001]R_{v i e
w}^{-1}=\left[\begin{array}{cccc}x_{\hat{g} \times \hat{t}} & x_{t} & x_{-g} &
0 \\\ y_{\hat{g} \times \hat{t}} & y_{t} & y_{-g} & 0 \\\ z_{\hat{g} \times
\hat{t}} & z_{t} & z_{-g} & 0 \\\ 0 & 0 & 0 &
1\end{array}\right]Rview−1​=⎣⎡​xg^​×t^​yg^​×t^​zg^​×t^​0​xt​yt​zt​0​x−g​y−g​z−g​0​0001​⎦⎤​

要验证也很简单，用该旋转矩阵变换 xxx﻿ 轴就能得到 g^×t^\hat{g}\times \hat{t}g^​×t^﻿ 的方向。

[xg^×t^xtx−g0yg^×t^yty−g0zg^×t^ztz−g00001][1000]=[xg^×t^yg^×t^zg^×t^0]\left[
\begin{matrix} x_{\hat{g}\times \hat{t}}& x_t& x_{-g}& 0\\\ y_{\hat{g}\times
\hat{t}}& y_t& y_{-g}& 0\\\ z_{\hat{g}\times \hat{t}}& z_t& z_{-g}& 0\\\ 0& 0&
0& 1\\\ \end{matrix} \right] \left[ \begin{array}{c} 1\\\ 0\\\ 0\\\ 0\\\
\end{array} \right] =\left[ \begin{array}{c} \begin{array}{c} x_{\hat{g}\times
\hat{t}}\\\ y_{\hat{g}\times \hat{t}}\\\ \end{array}\\\ z_{\hat{g}\times
\hat{t}}\\\ 0\\\ \end{array} \right]
⎣⎡​xg^​×t^​yg^​×t^​zg^​×t^​0​xt​yt​zt​0​x−g​y−g​z−g​0​0001​⎦⎤​⎣⎡​1000​⎦⎤​=⎣⎡​xg^​×t^​yg^​×t^​​zg^​×t^​0​⎦⎤​

那么我们的旋转矩阵就能通过对上面的矩阵求逆得出：

因为旋转矩阵是正交矩阵，因此要求逆矩阵，对其转置即可。

Rview=[xg^×t^yg^×t^zg^×t^0xtytzt0x−gy−gz−g00001]R_{v i e
w}=\left[\begin{array}{cccc}x_{\hat{g} \times \hat{t}} & y_{\hat{g} \times
\hat{t}} & z_{\hat{g} \times \hat{t}} & 0 \\\ x_{t} & y_{t} & z_{t} & 0 \\\
x_{-g} & y_{-g} & z_{-g} & 0 \\\ 0 & 0 & 0 &
1\end{array}\right]Rview​=⎣⎡​xg^​×t^​xt​x−g​0​yg^​×t^​yt​y−g​0​zg^​×t^​zt​z−g​0​0001​⎦⎤​

这样我们世界空间到观察空间的变换矩阵就能得出来了：Mview=RviewTviewM_{v i e w}=R_{v i e w} T_{v i e
w}Mview​=Rview​Tview​﻿

Mview=RviewTview=[xg^×t^yg^×t^zg^×t^0xtytzt0x−gy−gz−g00001][100−xe010−ye001−ze0001]=[xg^×t^yg^×t^zg^×t^−Vg^×t^Vextytzt−Vt^Vex−gy−gz−g−V−gVe0001]=[xg^×t^yg^×t^zg^×t^−Vg^×t^Vextytzt−Vt^Ve−xg−yg−zgVgVe0001]M_{view}=R_{view}T_{view}
\\\ =\left[ \begin{matrix} x_{\hat{g}\times \hat{t}}& y_{\hat{g}\times
\hat{t}}& z_{\hat{g}\times \hat{t}}& 0\\\ x_t& y_t& z_t& 0\\\ x_{-g}& y_{-g}&
z_{-g}& 0\\\ 0& 0& 0& 1\\\ \end{matrix} \right] \left[ \begin{matrix} 1& 0& 0&
-x_e\\\ 0& 1& 0& -y_e\\\ 0& 0& 1& -z_e\\\ 0& 0& 0& 1\\\ \end{matrix} \right]
\\\ =\left[ \begin{matrix} x_{\hat{g}\times \hat{t}}& y_{\hat{g}\times
\hat{t}}& z_{\hat{g}\times \hat{t}}& -V_{\hat{g}\times \hat{t}}V_e\\\ x_t&
y_t& z_t& -V_{\hat{t}}V_e\\\ x_{-g}& y_{-g}& z_{-g}& -V_{-g}V_e\\\ 0& 0& 0&
1\\\ \end{matrix} \right] \\\ =\left[ \begin{matrix} x_{\hat{g}\times
\hat{t}}& y_{\hat{g}\times \hat{t}}& z_{\hat{g}\times \hat{t}}&
-V_{\hat{g}\times \hat{t}}V_e\\\ x_t& y_t& z_t& -V_{\hat{t}}V_e\\\ -x_g& -y_g&
-z_g& V_gV_e\\\ 0& 0& 0& 1\\\ \end{matrix} \right]
Mview​=Rview​Tview​=⎣⎡​xg^​×t^​xt​x−g​0​yg^​×t^​yt​y−g​0​zg^​×t^​zt​z−g​0​0001​⎦⎤​⎣⎡​1000​0100​0010​−xe​−ye​−ze​1​⎦⎤​=⎣⎡​xg^​×t^​xt​x−g​0​yg^​×t^​yt​y−g​0​zg^​×t^​zt​z−g​0​−Vg^​×t^​Ve​−Vt^​Ve​−V−g​Ve​1​⎦⎤​=⎣⎡​xg^​×t^​xt​−xg​0​yg^​×t^​yt​−yg​0​zg^​×t^​zt​−zg​0​−Vg^​×t^​Ve​−Vt^​Ve​Vg​Ve​1​⎦⎤​

其中 Vg^×t^V_{\hat{g}\times \hat{t}}Vg^​×t^​﻿ 为 g^×t^\hat{g}\times
\hat{t}g^​×t^﻿ 的向量，VeV_eVe​﻿ 为相机原点。

相机需要进行这种变换，变换到约定俗成的位置（原点）上去，那么其他所有物体也需要做这样的变换，这样相对运动不变。这个就是视图变换。

模型变换和视图变换经常一起被称为模型视图变换（ModelView Transformation）。

Projection Transformation 投影变换

Projection in Computer Graphics

•

3D to 2D

•

Orthographic projection

•

Perspective projection

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F6dd18a74-9191-45cd-
ac0d-431c7f012ed1%2FUntitled.png?table=block&id=af80fc15-a5b9-4eef-a61b-65a5942cfa8a&width=4110&userId=&cache=v2)

Perspective projection vs. orthographic projection

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F88831512-c3fe-4721-a196-65861d8de4ae%2FUntitled.png?table=block&id=080d8a96-484e-49b8-b290-7ee94fa2b651&width=3340&userId=&cache=v2)

Orthographic Projection 正交投影

方法一

A simple way of understanding

•

Camera located at origin, looking at -Z, up at Y (looks familiar?)

•

Drop Z coordinate

•

Translate and scale the resulting rectangle to [−1,1]2[-1,1]^{2}[−1,1]2﻿

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F536df52b-0f0a-4774-9060-706480f4c0a6%2FUntitled.png?table=block&id=3664fd41-76a3-4953-b355-23b850c9eaac&width=1430&userId=&cache=v2)

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

将坐标中的 z 扔掉，如何区分物体的前和后？

感兴趣可以参考 [Catlikecoding Render
1](https://catlikecoding.com/unity/tutorials/rendering/part-1/) 中 Orthographic
Camera 部分。

方法二

In general, we want to map a cuboid [l, r] x [b, t] x [f, n] to the “canonical
(正则、规范、标准)” cube [−1,1]3[-1,1]^{3}[−1,1]3﻿

我们在 xxx﻿ 轴上定义左和右 [l,r][l, r][l,r]﻿ （左比右小），yyy﻿ 轴上定义下和上 [b,t][b,
t][b,t]﻿（下比上小），zzz﻿ 轴上定义远和近 [f,n][f, n][f,n]﻿（远比近小）。

不管 x, y 多大，都将其映射到 [−1,1][-1, 1][−1,1]﻿
之间。这也是个约定俗成的事情，能方便计算。这样任何空间中的长方体，都可以映射成一个标准的立方体。

这也是标准化设备坐标（NDC）的定义。

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

上面的左比右小是相对于 xxx﻿ 轴来说的，下比上小是相对于 yyy﻿ 轴说的，但 zzz﻿ 轴上不太直观，因为我们推导的 NDC
是右手坐标系，（相机）看的是 −z-z−z﻿ 方向，因此一个面离我们远，说明 zzz﻿ 值更小。离我们近，说明 zzz﻿ 值更大。

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F5ac5fe17-fe23-4091-8038-3f1f02e8d649%2FUntitled.png?table=block&id=dd8178a5-3ab3-4d6f-b82d-ac501e6ae333&width=4510&userId=&cache=v2)

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

在标准化设备坐标系中 OpenGL 使用的是左手坐标系，因为左手系在这一点上会比较方便。但也会造成别的问题，x×y≠zx\times y\ne
zx×y=z﻿

[learnopengl-cn.github.iohttps://learnopengl-
cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#3d](https://learnopengl-
cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#3d)

Slightly different orders (to the “simple way”)

•

Center cuboid by translating 移到原点

•

Scale into “canonical” cube 映射到 [-1, 1]，也就是缩放

Translate (center to origin) first, then scale (length/width/height to 2) 因为
-1 到 1 的长度就是 2。

因此我们可以用一个平移矩阵和缩放矩阵来求出正交投影矩阵，先平移，再缩放：

Mortho=[2r−l00002t−b00002n−f00001][100−r+l2010−t+b2001−n+f20001]=[2r−l00−r+lr−l02t−b0−t+bt−b002n−f−n+fn−f0001]M_{\text{ortho}}=\left[
\begin{matrix} \frac{2}{r-l}& 0& 0& 0\\\ 0& \frac{2}{t-b}& 0& 0\\\ 0& 0&
\frac{2}{n-f}& 0\\\ 0& 0& 0& 1\\\ \end{matrix} \right] \left[ \begin{matrix}
1& 0& 0& -\frac{r+l}{2}\\\ 0& 1& 0& -\frac{t+b}{2}\\\ 0& 0& 1&
-\frac{n+f}{2}\\\ 0& 0& 0& 1\\\ \end{matrix} \right] \\\ =\left[
\begin{matrix} \frac{2}{r-l}& 0& 0& -\frac{r+l}{r-l}\\\ 0& \frac{2}{t-b}& 0&
-\frac{t+b}{t-b}\\\ 0& 0& \frac{2}{n-f}& -\frac{n+f}{n-f}\\\ 0& 0& 0& 1\\\
\end{matrix} \right]
Mortho​=⎣⎡​r−l2​000​0t−b2​00​00n−f2​0​0001​⎦⎤​⎣⎡​1000​0100​0010​−2r+l​−2t+b​−2n+f​1​⎦⎤​=⎣⎡​r−l2​000​0t−b2​00​00n−f2​0​−r−lr+l​−t−bt+b​−n−fn+f​1​⎦⎤​

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

如果把长方体范围缩成立方体，物体不会被拉伸吗？ 会，这就涉及到另外一个变换。在所有变换做完之后，还要做一个视口变换，还要做一次拉伸。

Perspective Projection 透视投影

•

Most common in Computer Graphics, art, visual system

•

Further objects are smaller

•

Parallel lines not parallel; converge to single point

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2Fbdb2c7c6-302e-42f2-a386-cbf4f2fd0a7b%2FUntitled.png?table=block&id=da7ac371-e368-4b7d-8213-d4a86e7de721&width=860&userId=&cache=v2)

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F62cd1940-77ff-494c-a90d-7882275d6d4a%2FUntitled.png?table=block&id=6e9c1123-1cea-49e0-9eb4-05f636044675&width=4300&userId=&cache=v2)

平行线就是永不相交的两条线，但照片上铁轨是平行的，却交于一点。透视投影的情况下，一个平面相当于被投影到了另外一个平面上，这种情况下就不是平行线了。

Recall

•

Before we move on

•

Recall: property of homogeneous coordinates

•

(x,y,z,1),(kx,ky,kz,k!=0),(xz,yz,z2,z!=0)(x, y, z, 1),(k x, k y, k z, k
!=0),\left(x z, y z, z^{2}, z
!=0\right)(x,y,z,1),(kx,ky,kz,k!=0),(xz,yz,z2,z!=0)﻿ all represent the same
point (x, y, z) in 3D

•

只要一个点乘于一个不为零的 k，那么它们还是一个点。那么我们还可以将其乘以 z，其表示的点还是空间中同样的点。下面我们会用到。

•

e.g. (1, 0, 0, 1) and (2, 0, 0, 2) both represent (1, 0, 0)

•

Simple, but useful

怎么做透视投影

How to do perspective projection

•

First “squish” the frustum into a cuboid (n→n,f→f)(Mpersp→ortho)\left(
\text{n}\rightarrow \text{n},\text{f}\rightarrow \text{f} \right) \left(
\text{M}_{\text{persp}\rightarrow \text{ortho}} \right)
(n→n,f→f)(Mpersp→ortho​)﻿

•

Do orthographic projection ( Mortho\text{M}_{ortho}Mortho​﻿, already known!)

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2Fd1cb86e3-8c18-44c9-82c7-e48e895bf8a6%2FUntitled.png?table=block&id=314cd078-2dde-478e-aafb-5ae92a7fcded&width=3920&userId=&cache=v2)

透视投影的视锥体中，远的平面比近的平面要大。

我们可以把远的平面往里“挤”，“挤”到同一高度且同近平面大小，“挤”成空间中的长方体，再做正交投影就解决了。

我们已经知道正交投影怎么做了，因此剩下的就是“挤”这个操作。

在这个过程中，需要规定：

•

近平面上任何一个点不变。

•

Z 值不变

•

远平面的中心也不会发生变化

求出任何一个点挤压后的 x′,y′x', y'x′,y′﻿ 值

要做“挤”的操作，首先要知道任何一个点的 x,yx, yx,y﻿ 值是怎么变化的。因为我们任何一个面都要挤成近平面大小，我们也可以将(x,y,z)
(x,y,z) (x,y,z)﻿投影到近平面上求出变换后的 x′,y′x', y'x′,y′﻿ 值。对于 x,yx, yx,y﻿ 值来说，这种变换是线性的。

因此，在视锥体的上面一部分中，我们可以通过相似三角形求出变换后的 x′,y′x', y'x′,y′﻿ 值。（z′z'z′﻿ 值不是线性变化的，后面会提到）

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2Fdc3ebabf-23a3-46e6-aaf1-7069160aab6e%2FUntitled.png?table=block&id=a287558b-e5dd-457e-8d9e-50b5737cd82f&width=4620&userId=&cache=v2)

上图中，nnn﻿ 为近平面的 zzz﻿ 值，zzz﻿ 为任何一个点(x,y,z)(x,y,z)(x,y,z)﻿中的 zzz﻿ 值。

挤压后的 y’y’y’﻿ 值，我们可以通过相似三角形原理得出：

y′=nzyy^{\prime}=\frac{n}{z} yy′=zn​y

同理可得挤压后的 x’x’x’﻿ 值：

x′=nzxx^{\prime}=\frac{n}{z} xx′=zn​x

在齐次坐标系中，对于变换后的 (x’,y’,z’)(x’, y’, z’) (x’,y’,z’)﻿ 我们只剩下 z’z’z’﻿ 未知。

这里给矩阵乘了 z，其表示的点还是空间中同样的点。

(xyz1)⇒(x’y’z’1)=(nx/zny/z unknown1)=mult by z=(nxny still unknownz)\left(
\begin{array}{l} x\\\ y\\\ z\\\ 1\\\ \end{array} \right) \Rightarrow \left(
\begin{array}{l} x’\\\ y’\\\ z’\\\ 1\\\ \end{array} \right) =\left(
\begin{array}{c} nx/z\\\ ny/z\\\ \,\,\text{unknown}\\\ 1\\\ \end{array}
\right) =mult\,\,by\,\,z=\left( \begin{array}{c} nx\\\ ny\\\ \,\,\text{still }
\text{unknown}\\\ z\\\ \end{array} \right)
⎝⎛​xyz1​⎠⎞​⇒⎝⎛​x’y’z’1​⎠⎞​=⎝⎛​nx/zny/zunknown1​⎠⎞​=multbyz=⎝⎛​nxnystill
unknownz​⎠⎞​

也就是说 (x,y,z,1)(x,y,z,1)(x,y,z,1)﻿ 经过 Mpersp→ortho(4×4)M_{persp\rightarrow
ortho}^{\left( 4\times 4 \right)}Mpersp→ortho(4×4)​﻿ 矩阵“挤压”后，会被映射到
(nx,ny,??,z)(nx,ny,??,z)(nx,ny,??,z)﻿：

Mpersp→ortho(4×4)(xyz1)=(nxny unknown z)M_{p e r s p \rightarrow o r t h
o}^{(4 \times 4)}\left(\begin{array}{c}x \\\ y \\\ z \\\
1\end{array}\right)=\left(\begin{array}{c}n x \\\ n y \\\ \text { unknown }
\\\ z\end{array}\right)Mpersp→ortho(4×4)​⎝⎛​xyz1​⎠⎞​=⎝⎛​nxny unknown z​⎠⎞​

根据上式，我们可以得出部分的 Mpersp→orthoM_{p e r s p \rightarrow o r t h o}Mpersp→ortho​﻿
矩阵：

Mpersp→ortho=(n0000n00????0010)M_{p e r s p \rightarrow o r t h
o}=\left(\begin{array}{llll}n & 0 & 0 & 0 \\\ 0 & n & 0 & 0 \\\ ? & ? & ? & ?
\\\ 0 & 0 & 1 & 0\end{array}\right)Mpersp→ortho​=⎝⎛​n0?0​0n?0​00?1​00?0​⎠⎞​

对于 zzz﻿，我们不知道 zzz﻿ 会怎么变，我们只规定了近的平面上和远的平面上 zzz﻿ 不变。

Observation: the third row is responsible for z’

•

Any point on the near plane will not change

•

近平面的点不变，对于任何 (x,y,n,1)(x,y,n,1)(x,y,n,1)﻿ 运算完了一定还是
(x,y,n,1)(x,y,n,1)(x,y,n,1)﻿

•

Any point’s z on the far plane will not change

•

远平面的点，虽然 x,yx, yx,y﻿ 会变化，但是 zzz﻿ 没有变。

求出任何一个点挤压后的 z’z’z’﻿ 值

由“近平面的点不变，对于任何 (x,y,n,1)(x,y,n,1)(x,y,n,1)﻿ 运算完了一定还是
(x,y,n,1)(x,y,n,1)(x,y,n,1)﻿”可得：

这里给矩阵乘了 n，其表示的点还是空间中同样的点。

(xyn1)⇒(xyn1)=mult by n=(nxnyn2n)\left( \begin{array}{l} x\\\ y\\\ n\\\ 1\\\
\end{array} \right) \Rightarrow \left( \begin{array}{l} x\\\ y\\\ n\\\ 1\\\
\end{array} \right) =mult\,\,by\,\,n=\left( \begin{array}{l} nx\\\ ny\\\
n^2\\\ n\\\ \end{array} \right) ⎝⎛​xyn1​⎠⎞​⇒⎝⎛​xyn1​⎠⎞​=multbyn=⎝⎛​nxnyn2n​⎠⎞​

因此 Mpersp→orthoM_{p e r s p \rightarrow o r t h o}Mpersp→ortho​﻿ 第三行一定是
(0,0,A,B)(0,0,A,B)(0,0,A,B)﻿ 的形式，因为：

(00AB)(xyn1)=n2\left(\begin{array}{llll}0 & 0 & A &
B\end{array}\right)\left(\begin{array}{l}x \\\ y \\\ n \\\
1\end{array}\right)=n^{2}(0​0​A​B​)⎝⎛​xyn1​⎠⎞​=n2

由上式可得：

An+B=n2A n+B=n^{2}An+B=n2

前面我们已经知道第三行前两个数是 0。

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

我们前面已经规定了远平面的中心经过 Mpersp→ortho\text{M}_{\text{persp}\rightarrow
\text{ortho}}Mpersp→ortho​﻿ 变换后也不会发生变化。

另外一个等式可以用远平面可以用其特殊的中心点得出，给中心点再乘个 fff﻿ 可得：

(00f1)⇒(00f1)=mult by f=(00f2f)\left( \begin{array}{l} 0\\\ 0\\\ f\\\ 1\\\
\end{array} \right) \Rightarrow \left( \begin{array}{l} 0\\\ 0\\\ f\\\ 1\\\
\end{array} \right) =mult\,\,by\,\,f=\left( \begin{array}{c} 0\\\ 0\\\ f^2\\\
f\\\ \end{array} \right) ⎝⎛​00f1​⎠⎞​⇒⎝⎛​00f1​⎠⎞​=multbyf=⎝⎛​00f2f​⎠⎞​

由上式可得：

Af+B=f2Af+B=f^2Af+B=f2

根据两式可得 Mpersp→ortho\text{M}_{\text{persp}\rightarrow
\text{ortho}}Mpersp→ortho​﻿ ：

An+B=n2Af+B=f2⇒ A=n+fB=−nf\begin{array}{c} An+B=n^2\\\
Af+B=f^2\\\\\end{array}\Rightarrow \,\,\begin{array}{c} A=n+f\\\
B=-nf\\\\\end{array}An+B=n2Af+B=f2​⇒A=n+fB=−nf​

Mpersp→ortho=(n0000n0000n+f−nf0010)M_{persp\rightarrow ortho}=\left(
\begin{matrix} n& 0& 0& 0\\\ 0& n& 0& 0\\\ 0& 0& n+f& -nf\\\ 0& 0& 1&
0\\\\\end{matrix} \right) Mpersp→ortho​=⎝⎛​n000​0n00​00n+f1​00−nf0​⎠⎞​

Mpersp=MorthoMpersp→orthoM_{p e r s p}=M_{o r t h o} M_{p e r s p \rightarrow
o r t h o}Mpersp​=Mortho​Mpersp→ortho​

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

平截头体（Frustum）被压缩成长方体以后，内部的点的 zzz﻿ 值是更偏向于近平面还是更偏向于远平面？

可以参考 ScratchAPixel 的 [The Perspective and Orthographic Projection
Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-
and-orthographic-projection-matrix/building-basic-perspective-projection-
matrix)

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F9a4c47e3-0c29-43ee-8bef-989141ee5a13%2FUntitled.png?table=block&id=17073006-870b-4bfd-
bb9b-138a8ab1d581&width=1340&userId=&cache=v2)

[Depth Precision VisualizedDepth precision is a pain in the ass that every
graphics programmer has to struggle with sooner or later. Many articles and
papers have been written on the topic, and a variety of different depth buffer
formats and setups are found across different games, engines, and
devices.![](/image/https%3A%2F%2Fdeveloper.nvidia.com%2Fsites%2Fall%2Fthemes%2Fgameworks%2Ffavicon.ico?table=block&id=791e0ef4-75d3-4c04-b97a-d82782f400a8&userId=&cache=v2)https://developer.nvidia.com/content/depth-
precision-
visualized![](/image/https%3A%2F%2Fdeveloper.nvidia.com%2Fsites%2Fdefault%2Ffiles%2Fakamai%2Fgameworks%2Fblog%2FDepthprecision%2Fgraph.jpg?table=block&id=791e0ef4-75d3-4c04-b97a-d82782f400a8&width=500&userId=&cache=v2)](https://developer.nvidia.com/content/depth-
precision-visualized)

定义视锥

前面提到了长方体近平面的 l, r, b, t，有没有更好的方法去定义这些呢？

vertical field-of-view (fovY) and aspect ratio

我们现实中相机有视角的定义，也就是可以看到的角度的范围，也就是 field of view。广角相机就是可视角度比较大，对于视锥体来说，就是张的比较开。

垂直的可视角度就是 fovY。而相机的长宽比就是 aspect ratio。

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

我们也可以通过 fovY 和 aspect ratio，来推出水平的可视角度。

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F81699bf8-ca5f-455e-9b95-dc5804f8b8c1%2FUntitled.png?table=block&id=6c8a6544-7fce-42bb-9809-132ba60b7a92&width=2500&userId=&cache=v2)

How to convert from fovY and aspect to l, r, b, t?

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2Fd9002e7d-85de-4df2-acc8-dc0f2d3e53f0%2FUntitled.png?table=block&id=d06f6a8f-73b3-4a2a-a8a4-c5b857ca2f5f&width=3210&userId=&cache=v2)

上图中，夹角为 fovY2\frac{fovY}{2}2fovY​﻿，红点坐标为(0,t,n)(0,t,n)(0,t,n)﻿，ttt﻿
为屏幕高度的一半，那么根据三角函数的定义就可以得出：

tan⁡fovY2=t∣n∣cot⁡fovY2=∣n∣t aspect=rt\begin{aligned} \tan
\frac{fovY}{2}&=\frac{t}{|n|}\\\ \cot \frac{fovY}{2}&=\frac{|n|}{t}\\\ \,\,
aspect&=\frac{r}{t}\\\ \end{aligned}tan2fovY​cot2fovY​aspect​=∣n∣t​=t∣n∣​=tr​​

完成推导正交投影矩阵

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F479f6ecc-a6ea-4de3-8948-bf66d4018d6c%2FUntitled.png?table=block&id=70a7cb0c-c411-4683-8bbb-6785de66fd2c&width=960&userId=&cache=v2)

正交投影没有 fovY，在 Unity 中，正交投影的参数由 Camera 组件中的参数 Size, Near, Far（Viewport Rect
暂时忽略）和 Game 视图的横纵比（aspect ratio）共同决定。

这里的 Near 是近裁面的距离，也就是 −n-n−n﻿，Far 同理，等于 −f-f−f﻿。

Size 属性用来更改视锥体竖直方向上高度的一半，也就是前面近平面的高度 ttt﻿。

由此可得正交投影近远平面的高度 t−bt-bt−b﻿ 为：2⋅Size=2⋅t2\cdot Size=2\cdot t2⋅Size=2⋅t﻿

正交投影近远平面的宽度 r−lr-lr−l﻿ 为：

Aspect⋅近远平面的高度=2⋅Aspect⋅Size=2⋅Aspect⋅tAspect\cdot \text{近远平面的高度}=2\cdot
Aspect\cdot Size=2\cdot Aspect\cdot tAspect⋅近远平面的高度=2⋅Aspect⋅Size=2⋅Aspect⋅t﻿

![](/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-
static.com%2F309aff06-3fdb-4904-8bb2-03220be30a2b%2FUntitled.png?table=block&id=97726ee4-b851-4435-83a8-4f5b063f3b29&width=2220&userId=&cache=v2)

Mortho=[2r−l00−r+lr−l02t−b0−t+bt−b002n−f−n+fn−f0001]=[1Aspect⋅Size00−r+lr−l01Size0−t+bt−b002n−f−n+fn−f0001]M_{\text{ortho}}=\left[
\begin{matrix} \frac{2}{r-l}& 0& 0& -\frac{r+l}{r-l}\\\ 0& \frac{2}{t-b}& 0&
-\frac{t+b}{t-b}\\\ 0& 0& \frac{2}{n-f}& -\frac{n+f}{n-f}\\\ 0& 0& 0& 1\\\
\end{matrix} \right] =\left[ \begin{matrix} \frac{1}{Aspect\cdot Size}& 0& 0&
-\frac{r+l}{r-l}\\\ 0& \frac{1}{Size}& 0& -\frac{t+b}{t-b}\\\ 0& 0&
\frac{2}{n-f}& -\frac{n+f}{n-f}\\\ 0& 0& 0& 1\\\ \end{matrix} \right]
Mortho​=⎣⎡​r−l2​000​0t−b2​00​00n−f2​0​−r−lr+l​−t−bt+b​−n−fn+f​1​⎦⎤​=⎣⎡​Aspect⋅Size1​000​0Size1​00​00n−f2​0​−r−lr+l​−t−bt+b​−n−fn+f​1​⎦⎤​

注意：这里的 nnn﻿ 和 fff﻿ 是 −z-z−z﻿ 轴上的，代表近裁面和远裁面的 zzz﻿ 值，值为负数。

完成推导透视投影矩阵

前面已经得出：

Mpersp→ortho=(n0000n0000n+f−nf0010)M_{persp\rightarrow ortho}=\left(
\begin{matrix} n& 0& 0& 0\\\ 0& n& 0& 0\\\ 0& 0& n+f& -nf\\\ 0& 0& 1&
0\\\\\end{matrix} \right) Mpersp→ortho​=⎝⎛​n000​0n00​00n+f1​00−nf0​⎠⎞​

Mpersp=MorthoMpersp→ortho=[1Aspect⋅Size00−r+lr−l01Size0−t+bt−b002n−f−n+fn−f0001]
[n0000n0000n+f−nf0010]=[nAspect⋅Size0−r+l2⋅Aspect⋅Size00nSize0000n+fn−f−2nfn−f0010]M_{persp}=M_{ortho}M_{persp\rightarrow
ortho} \\\ =\left[ \begin{matrix} \frac{1}{Aspect\cdot Size}& 0& 0&
-\frac{r+l}{r-l}\\\ 0& \frac{1}{Size}& 0& -\frac{t+b}{t-b}\\\ 0& 0&
\frac{2}{n-f}& -\frac{n+f}{n-f}\\\ 0& 0& 0& 1\\\ \end{matrix} \right]
\,\,\left[ \begin{matrix} n& 0& 0& 0\\\ 0& n& 0& 0\\\ 0& 0& n+f& -nf\\\ 0& 0&
1& 0\\\ \end{matrix} \right] \\\ =\left[ \begin{matrix} \frac{n}{Aspect\cdot
Size}& 0& -\frac{r+l}{2\cdot Aspect\cdot Size}& 0\\\ 0& \frac{n}{Size}& 0&
0\\\ 0& 0& \frac{n+f}{n-f}& \frac{-2nf}{n-f}\\\ 0& 0& 1& 0\\\ \end{matrix}
\right]
Mpersp​=Mortho​Mpersp→ortho​=⎣⎡​Aspect⋅Size1​000​0Size1​00​00n−f2​0​−r−lr+l​−t−bt+b​−n−fn+f​1​⎦⎤​⎣⎡​n000​0n00​00n+f1​00−nf0​⎦⎤​=⎣⎡​Aspect⋅Sizen​000​0Sizen​00​−2⋅Aspect⋅Sizer+l​0n−fn+f​1​00n−f−2nf​0​⎦⎤​

注意：这里的 nnn﻿ 和 fff﻿ 是 −z-z−z﻿ 轴上的，代表近裁面和远裁面的 zzz﻿ 值，值为负数。

通常我们透视投影的参数除了近裁面远裁面的距离外，还会有 fovfovfov﻿ 和 AspectAspectAspect﻿，且
r+l=0r+l=0r+l=0﻿，因此整理公式可得：

Mpersp=[nAspect⋅Size0000nSize0000n+fn−f−2nfn−f0010]
=[1Aspect⋅−∣n∣t0000−∣n∣t0000n+fn−f−2nfn−f0010]
=[−cot⁡fovY2Aspect0000−cot⁡fovY20000n+fn−f−2nfn−f0010] M_{persp}=\left[
\begin{matrix} \frac{n}{Aspect\cdot Size}& 0& 0& 0\\\ 0& \frac{n}{Size}& 0&
0\\\ 0& 0& \frac{n+f}{n-f}& \frac{-2nf}{n-f}\\\ 0& 0& 1& 0\\\\\end{matrix}
\right] \\\=\left[ \begin{matrix} \frac{1}{Aspect}\cdot \frac{-\left| n
\right|}{t}& 0& 0& 0\\\ 0& \frac{-\left| n \right|}{t}& 0& 0\\\ 0& 0&
\frac{n+f}{n-f}& \frac{-2nf}{n-f}\\\ 0& 0& 1& 0\\\\\end{matrix} \right]
\\\=\left[ \begin{matrix} \frac{-\cot \frac{fovY}{2}}{Aspect}& 0& 0& 0\\\ 0&
-\cot \frac{fovY}{2}& 0& 0\\\ 0& 0& \frac{n+f}{n-f}& \frac{-2nf}{n-f}\\\ 0& 0&
1& 0\\\\\end{matrix} \right]
Mpersp​=⎣⎡​Aspect⋅Sizen​000​0Sizen​00​00n−fn+f​1​00n−f−2nf​0​⎦⎤​
=⎣⎡​Aspect1​⋅t−∣n∣​000​0t−∣n∣​00​00n−fn+f​1​00n−f−2nf​0​⎦⎤​
=⎣⎡​Aspect−cot2fovY​​000​0−cot2fovY​00​00n−fn+f​1​00n−f−2nf​0​⎦⎤​

![💡](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

从矩阵来看，这个矩阵对于x, y 坐标做了不同比例的缩放，对于 z 坐标做了一个缩放和一个平移。... [图形学基础拾遗 -
重新认识剪不断理还乱的矩阵变换](https://zhuanlan.zhihu.com/p/223033896)

后记

剩下的应该还剩视口变换还没写，改天再补充。对投影变换的两种变换的推导，大家可以用 n, f 代表近远平面的距离来再推一遍。

有了本文的基础，就能开始尝试写一个简单的软件光栅渲染器，我也在尝试写一个软光栅，并把必要的过程都推导一遍，到时候再总结成文。

