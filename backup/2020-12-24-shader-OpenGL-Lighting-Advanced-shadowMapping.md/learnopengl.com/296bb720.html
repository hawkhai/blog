<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><script src="https://www.googletagservices.com/activeview/js/current/osd.js?cb=%2Fr20100101"></script><script src="https://rules.quantcount.com/rules-p-fTfJtcPmQDwZG.js" async=""></script><script src="https://secure.quantserve.com/quant.js" async="" type="text/javascript"></script><noscript><div><img src="//pixel.quantserve.com/pixel/p-fTfJtcPmQDwZG.gif" border="0" height="1" width="1" alt="Quantcast" /></div></noscript><script async="" type="text/javascript" src="https://quantcast.mgr.consensu.org/tcfv2/cmp2.js"></script><script type="text/javascript" async="" src="//theeighth-net.videoplayerhub.com/videoplayer.js"></script>
    <meta charset="utf-8" />
    <title>LearnOpenGL - Shadow Mapping</title>	<!--<title>Learn OpenGL, extensive tutorial resource for learning Modern OpenGL</title>-->
    <link rel="shortcut icon" type="image/ico" href="/favicon.ico" />
    <meta name="description" content="Learn OpenGL . com provides good and clear modern 3.3+ OpenGL tutorials with clear examples. A great resource to learn modern OpenGL aimed at beginners." />
	<meta name="fragment" content="!" />
    <script async="" type="text/javascript" src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script><script async="" type="text/javascript" src="https://quantcast.mgr.consensu.org/choice/fTfJtcPmQDwZG/learnopengl.com/choice.js"></script><script async="" src="//www.google-analytics.com/analytics.js"></script><script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-51879160-1', 'learnopengl.com');
      ga('send', 'pageview');

    </script>
    <!--<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-7855791439695850",
              enable_page_level_ads: true
         });
    </script>
	<script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
	<script>
	  var googletag = googletag || {};
	  googletag.cmd = googletag.cmd || [];
	</script>
	<script>
	  googletag.cmd.push(function() {
		googletag.defineSlot('/8491498/learnopengl_video', [300, 225], 'div-gpt-ad-1540574378241-0').addService(googletag.pubads());
		googletag.pubads().enableSingleRequest();
		googletag.pubads().collapseEmptyDivs();
		googletag.enableServices();
	  });
	</script>
    <script type="text/javascript" src="https://d31vxm9ubutrmw.cloudfront.net/static/js/1681.js"></script><script src="https://securepubads.g.doubleclick.net/gpt/pubads_impl_2020120801.js" async=""></script><style type="text/css">#waldo-sticky-footer-wrapper {position: fixed; width: 100%; bottom: 0px; left: 0px; text-align: center; z-index: 9999;margin-bottom: 0 !important;}#waldo-sticky-footer-wrapper &gt; div {position: relative; display: inline-block; margin-bottom: 0 !important;}#waldo-sticky-footer-wrapper iframe, #waldo-sticky-footer-wrapper div {margin-left: auto;margin-right: auto;}.waldo-sticky-sidebar{position: fixed; top: 10px;z-index: 90}div[id^="waldo-tag-"] iframe[id^="primis_playerSekindoSPlayer"] {bottom: 80px !important;}div[id^="waldo-tag-"] #flow_close_btn_iframe {bottom: 200px !important;}#nm-ccpa-widget {width: 96%; margin-left: 2%; margin-right: 2%; left: 0 !important; right: unset; bottom: 0 !important;}#nm-ccpa-widget {position: fixed; right: 20px; z-index: 9999; margin-bottom: 15px;box-shadow: 0 3px 36px 0 rgba(0,0,0,0.3); background-color: #fff;border-radius: 10px;bottom: 20px;margin-top: 10px;font-size: 14px;}.nm-ccpa-widget-header {background: #179f84;color: #fff;padding: 20px;}.nm-ccpa-widget-header .nm-ccpa-widget-main-title {margin-bottom: 0;margin-top: 0;font-size: 16px;font-weight: bold;}.nm-ccpa-widget-body {padding: 20px;background: #fff;}.nm-ccpa-widget-body label {font-size: 16px;}.nm-ccpa-widget-submit-btn {margin-top: 15px;padding-left: 25px;}.nm-ccpa-widget-submit-btn input {background: #179f84;color: #fff;padding: 10px 20px;border-radius: 8px;border: 0;outline: 0;}.nm-ccpa-widget-submit-btn input:hover,.nm-ccpa-widget-submit-btn input:focus {cursor: pointer;}.nm-ccpa-widget-checkbox-label {font-size: 20px;}.nm-ccpa-widget-header {position: relative;}.nm-ccpa-widget-close-btn {position: absolute;right: 10px;top: 10px;}.nm-ccpa-widget-close-btn a {color: #fff;font-size: 20px;text-decoration: none;}.nm-ccpa-widget-message {padding-left: 25px;}#waldo-tag-6038 {clear: both !important;}div[class^="app_gdpr-"] a {color: #41afbb !important; text-decoration: underline !important}#waldo-close-button {position: absolute; right: 0;top: -24px;}#waldo-close-button a {border: 1px solid rgba(0,0,0,.35);padding: 3px;font-size: 12px;color: #fff;font-weight: bold;background-color: #777;}#qc-cmp2-persistent-link {z-index: 8000 !important;}</style>
	<script src="/js/jquery-1.11.0.min.js"></script>
	<script src="/js/hoverintent.js"></script>
	<link rel="stylesheet" type="text/css" href="/layout.css" />
    <link rel="stylesheet" type="text/css" href="/js/styles/obsidian.css" />
    <script src="/js/highlight.pack.js"></script>    
    <script src="/js/functions.js"></script>
    <script type="text/javascript" src="/js/mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
    <script>
    // Has to be loaded last due to content bug 
    MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
    </script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>  
        $(document).ready(function() {
            // check if user visited from the old # based urls, re-direct to ?p= form
            if(window.location.hash)
            {
                var name = window.location.hash.substring(2);
                // name = name.replace(/-/g," ");
                var index = name.indexOf('#'); // Remove any hash fragments from the url (Disquss adds hash fragments for comments, but results in 404 pages)
                if(index &gt;= 0)
                    name = name.substring(0, index);
                
                window.location.href = "https://learnopengl.com/" + name;
            } else {
                    // Check if data has been succesfully loaded, if so: change title bar as ajax hash fragment
                    var title = $('#content-url').text();
                  
                    // Refresh syntax highlighting
                    // $('pre').each(function(i, e) {hljs.highlightBlock(e)});
                  
                    // Reset DISQUS
                    // if(title == '/dev/')
                        // title = '';
                    // alert('hoi');
                    
                    // Adjust ads for correct bottom positioning based on content size
                    window.setTimeout(function() {  
                        AdPositioning();
                     }, 3000);
                  
                  
                    // set API resets after time-out (once content is properly loaded)
                    window.setTimeout(function() {  
                        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);       
                        MathJax.Hub.Queue(["resetEquationNumbers", MathJax.InputJax.TeX]);
                        
                        var page_url = title == "" ? "http://www.learnopengl.com/" : "http://www.learnopengl.com/" + title;
                        if(typeof DISQUS !== 'undefined') {                                              
                            DISQUS.reset({
                              reload: true,
                              config: function () {  
                                this.page.identifier = title;  
                                this.page.url = page_url;
                              }
                            });
                            $('#disqus_thread').show();
                        }
                           // Refresh callbacks on &lt;function&gt; tags
                        SetFunctionTagCallbacks();        
                    }, 1000);
                                        
                    // Zet ook de juiste button op 'selected'
                    $('#nav li span, #nav li a').removeClass('selected');                
                    if(title != '')
                    {                    
                        $('#nav li[id=\'' + title + '\']').children('span, a').addClass('selected');
                    }
                    // En open menu waar nodig
                    var parents = $('#nav span.selected, #nav a.selected').parents('li').children('span.closed, a.closed');
                    var index = 0;
                    for(index = parents.length - 1; index &gt;= 0; index--)
                    {             
                        
                        var id = $(parents[index]).attr("id").replace( /^\D+/g, '');
                        MenuClick(id, false);
                    }                          
                
            }
        });
		// var initialized = false;
        // window.onpopstate = function() {
            // if(initialized)
                // LoadPage();
			// else
				// initialized = true;
        // };
        
        // Set up DISQUS
        // $(document).ready(function() {
            var disqus_shortname = 'learnopengl';
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();           
        // });
    </script><script type="text/javascript" async="" src="//learnopengl.disqus.com/embed.js"></script>
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><script type="text/javascript">googletag.cmd.push(function() {googletag.pubads().addEventListener('slotRenderEnded', function(event) {waldoPassbackCheck(event);waldoAddCloseBtn(event);});googletag.pubads().enableSingleRequest();googletag.enableServices();gptAdSlots[1715] = googletag.defineSlot('/124067137/learnopengl300x250FL_1', [[300, 250], [300, 600], [160, 600]], 'waldo-tag-1715').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[300, 250], [300, 600], [160, 600]]).addSize([768, 0], [[300, 250], [300, 600], [160, 600]]).addSize([0, 0], [[300, 250], [300, 600], [160, 600]]).build()).addService(googletag.pubads());googletag.display('waldo-tag-1715');gptAdSlots[2245] = googletag.defineSlot('/124067137/learnopengl300x600FL_1', [[300, 250], [300, 600]], 'waldo-tag-2245').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[300, 250], [300, 600]]).addSize([768, 0], [[300, 250], [300, 600]]).addSize([0, 0], [[300, 250], [300, 600]]).build()).addService(googletag.pubads());googletag.display('waldo-tag-2245');gptAdSlots[2246] = googletag.defineSlot('/124067137/learnopengl300x600FL_2', [[300, 250], [300, 600]], 'waldo-tag-2246').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[300, 250], [300, 600]]).addSize([768, 0], [[300, 250], [300, 600]]).addSize([0, 0], [[300, 250], [300, 600]]).build()).addService(googletag.pubads());googletag.display('waldo-tag-2246');gptAdSlots[2247] = googletag.defineSlot('/124067137/learnopengl300x600FL_3', [[300, 250], [300, 600]], 'waldo-tag-2247').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[300, 250], [300, 600]]).addSize([768, 0], [[300, 250], [300, 600]]).addSize([0, 0], [[300, 250], [300, 600]]).build()).addService(googletag.pubads());googletag.display('waldo-tag-2247');gptAdSlots[6194] = googletag.defineSlot('/124067137/learnopengl728x90FS_2', [[728, 90], [320, 50]], 'waldo-tag-6194').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[728, 90]]).addSize([768, 0], [[320, 50]]).addSize([0, 0], [[320, 50]]).build()).addService(googletag.pubads());googletag.display('waldo-tag-6194');gptAdSlots[6196] = googletag.defineSlot('/124067137/learnopengl728x90FS_1', [[728, 90], [320, 50]], 'waldo-tag-6196').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[728, 90]]).addSize([768, 0], [[320, 50]]).addSize([0, 0], [[320, 50]]).build()).addService(googletag.pubads());googletag.display('waldo-tag-6196');});</script><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom &gt; * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd &gt; * {display: block!important}
.MJXp-script-box &gt; *  {display: table!important; height: 50%}
.MJXp-script-box &gt; * &gt; * {display: table-cell!important; vertical-align: top}
.MJXp-script-box &gt; *:last-child &gt; * {vertical-align: bottom}
.MJXp-script-box &gt; * &gt; * &gt; * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over &gt; * {display: block!important}
.MJXp-munderover &gt; * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable &gt; * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr &gt; .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child &gt; .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr &gt; .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child &gt; .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css"> .qc-cmp-button.qc-cmp-secondary-button:hover {    background-color: #368bd6 !important;    border-color: transparent !important;  }  .qc-cmp-button.qc-cmp-secondary-button:hover {    color: #ffffff !important;  }  .qc-cmp-button.qc-cmp-secondary-button {    color: #368bd6 !important;  }  .qc-cmp-button.qc-cmp-secondary-button {    background-color: #eee !important;    border-color: transparent !important;  } </style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?rev=2.6.1') format('opentype')}
@font-face {font-family: MathJax_Main-bold; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?rev=2.6.1') format('opentype')}
@font-face {font-family: MathJax_Main-italic; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?rev=2.6.1') format('opentype')}
@font-face {font-family: MathJax_Math-italic; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?rev=2.6.1') format('opentype')}
@font-face {font-family: MathJax_Caligraphic; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?rev=2.6.1') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?rev=2.6.1') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?rev=2.6.1') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?rev=2.6.1') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?rev=2.6.1') format('woff'), url('https://learnopengl.com/js/mathjax/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?rev=2.6.1') format('opentype')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><link rel="preload" href="https://adservice.google.com/adsid/integrator.js?domain=learnopengl.com" as="script" /><script type="text/javascript" src="https://adservice.google.com/adsid/integrator.js?domain=learnopengl.com"></script><link rel="prefetch" href="https://1d637ffe1d1a51bb645e22469ce04136.safeframe.googlesyndication.com/safeframe/1-0-37/html/container.html" /><link rel="prefetch" href="https://tpc.googlesyndication.com/safeframe/1-0-37/html/container.html" /></head>
<body style=""><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>
<a href="https://learnopengl.com">
<div id="header">
</div>
</a>

<div id="supercontainer">
    <!-- 728x90/320x50 -->
    <div id="header_ad">
        <div id="waldo-tag-6194" data-processed="true" data-google-query-id="COvQjN7O5e0CFQGCvQodWKgIXA"><div id="google_ads_iframe_/124067137/learnopengl728x90FS_2_0__container__" style="border: 0pt none; display: inline-block; width: 320px; height: 50px;"><iframe frameborder="0" src="https://1d637ffe1d1a51bb645e22469ce04136.safeframe.googlesyndication.com/safeframe/1-0-37/html/container.html" id="google_ads_iframe_/124067137/learnopengl728x90FS_2_0" title="3rd party ad content" name="" scrolling="no" marginwidth="0" marginheight="0" width="320" height="50" data-is-safeframe="true" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" data-google-container-id="6" style="border: 0px; vertical-align: bottom;" data-load-complete="true"></iframe></div></div>
    </div>
    <div id="rightad_container" style="height: 12643px;">
        <div id="rightad">
            <!-- /8491498/learnopengl_video -->
            <!--<div id='div-gpt-ad-1540574378241-0' style='height:225px; width:300px;'>
			<script>
			googletag.cmd.push(function() { googletag.display('div-gpt-ad-1540574378241-0'); });
			</script>
			</div>            
            <br/>-->
           
            <div id="waldo-tag-1715" data-processed="true" data-google-query-id="COfQjN7O5e0CFQGCvQodWKgIXA"><div id="google_ads_iframe_/124067137/learnopengl300x250FL_1_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137/learnopengl300x250FL_1_0" title="3rd party ad content" name="google_ads_iframe_/124067137/learnopengl300x250FL_1_0" width="300" height="600" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" srcdoc="" style="border: 0px; vertical-align: bottom;" data-google-container-id="2" data-load-complete="true"></iframe></div></div>
        </div>

        <div id="admessage">
            If you're running AdBlock, please consider whitelisting this site if you'd like to support LearnOpenGL; and no worries, I won't be mad if you don't :)
            <!--<br/><br/>
            Also, check out this little local multiplayer-only game I've made: <a href="https://store.steampowered.com/app/983590/Tank_Blazers/" target="_blank">Tank Blazers</a>.
            <br/>
            <a href="https://store.steampowered.com/app/983590/Tank_Blazers" target="_blank"><img src="/img/tank_blazers.jpg"  style="width:278px; margin-top: 9px; margin-left: -3px;"/></a>-->
        </div>
        
        <div id="rightonethirdad" style="display: block; top: 3595.33px;">
            <div id="waldo-tag-2246" data-processed="true" data-google-query-id="COnQjN7O5e0CFQGCvQodWKgIXA"><div id="google_ads_iframe_/124067137/learnopengl300x600FL_2_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137/learnopengl300x600FL_2_0" title="3rd party ad content" name="google_ads_iframe_/124067137/learnopengl300x600FL_2_0" width="300" height="600" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" srcdoc="" style="border: 0px; vertical-align: bottom;" data-google-container-id="4" data-load-complete="true"></iframe></div></div>
        </div>
        
        <div id="rightbottomad" style="display: block;">            
			<div id="waldo-tag-2247" data-processed="true" data-google-query-id="COrQjN7O5e0CFQGCvQodWKgIXA"><div id="google_ads_iframe_/124067137/learnopengl300x600FL_3_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137/learnopengl300x600FL_3_0" title="3rd party ad content" name="google_ads_iframe_/124067137/learnopengl300x600FL_3_0" width="300" height="600" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" srcdoc="" style="border: 0px; vertical-align: bottom;" data-google-container-id="5" data-load-complete="true"></iframe></div></div>								
        </div>
    </div>
    <div id="container">
        <div id="loading"></div>
<script> 
$(document).ready(function() {
$('#menu-item4').mousedown(function() { MenuClick(4, true) });
$('#menu-item48').mousedown(function() { MenuClick(48, true) });
$('#menu-item56').mousedown(function() { MenuClick(56, true) });
$('#menu-item63').mousedown(function() { MenuClick(63, true) });
$('#menu-item100').mousedown(function() { MenuClick(100, true) });
$('#menu-item102').mousedown(function() { MenuClick(102, true) });
$('#menu-item113').mousedown(function() { MenuClick(113, true) });
$('#menu-item116').mousedown(function() { MenuClick(116, true) });
$('#menu-item78').mousedown(function() { MenuClick(78, true) });
$('#menu-item81').mousedown(function() { MenuClick(81, true) });
$('#menu-item85').mousedown(function() { MenuClick(85, true) });
$('#menu-item125').mousedown(function() { MenuClick(125, true) });
}); 
</script>   
    <div id="nav" style="height: 12643px;">
         <div id="social">
            <a href="https://github.com/JoeyDeVries/LearnOpenGL" target="_blank">
                    <img src="/img/github.png" class="social_ico" />
            </a>
             <!-- <a href="https://www.facebook.com/Learnopengl-2199631333595544/" target="_blank">
                <img src="/img/facebook.png" class="social_ico">
            </a>-->
            <a href="https://twitter.com/JoeyDeVriez" target="_blank">
                <img src="/img/twitter.png" class="social_ico" />
            </a>
          
        </div>
    <img src="img/nav-button_bottom-arrow.png" style="display: none" /><ol><li id="Introduction"><a id="menu-item1" href="https://learnopengl.com/Introduction">Introduction </a></li><li id="Getting-started"><span id="menu-item4" class="closed">Getting started </span><ol id="menu-items-of4" style="display:none;"><li id="Getting-started/OpenGL"><a id="menu-item49" href="https://learnopengl.com/Getting-started/OpenGL">OpenGL </a></li><li id="Getting-started/Creating-a-window"><a id="menu-item5" href="https://learnopengl.com/Getting-started/Creating-a-window">Creating a window </a></li><li id="Getting-started/Hello-Window"><a id="menu-item6" href="https://learnopengl.com/Getting-started/Hello-Window">Hello Window </a></li><li id="Getting-started/Hello-Triangle"><a id="menu-item38" href="https://learnopengl.com/Getting-started/Hello-Triangle">Hello Triangle </a></li><li id="Getting-started/Shaders"><a id="menu-item39" href="https://learnopengl.com/Getting-started/Shaders">Shaders </a></li><li id="Getting-started/Textures"><a id="menu-item40" href="https://learnopengl.com/Getting-started/Textures">Textures </a></li><li id="Getting-started/Transformations"><a id="menu-item43" href="https://learnopengl.com/Getting-started/Transformations">Transformations </a></li><li id="Getting-started/Coordinate-Systems"><a id="menu-item44" href="https://learnopengl.com/Getting-started/Coordinate-Systems">Coordinate Systems </a></li><li id="Getting-started/Camera"><a id="menu-item47" href="https://learnopengl.com/Getting-started/Camera">Camera </a></li><li id="Getting-started/Review"><a id="menu-item50" href="https://learnopengl.com/Getting-started/Review">Review </a></li></ol></li><li id="Lighting"><span id="menu-item48" class="closed">Lighting </span><ol id="menu-items-of48" style="display:none;"><li id="Lighting/Colors"><a id="menu-item51" href="https://learnopengl.com/Lighting/Colors">Colors </a></li><li id="Lighting/Basic-Lighting"><a id="menu-item52" href="https://learnopengl.com/Lighting/Basic-Lighting">Basic Lighting </a></li><li id="Lighting/Materials"><a id="menu-item53" href="https://learnopengl.com/Lighting/Materials">Materials </a></li><li id="Lighting/Lighting-maps"><a id="menu-item54" href="https://learnopengl.com/Lighting/Lighting-maps">Lighting maps </a></li><li id="Lighting/Light-casters"><a id="menu-item55" href="https://learnopengl.com/Lighting/Light-casters">Light casters </a></li><li id="Lighting/Multiple-lights"><a id="menu-item58" href="https://learnopengl.com/Lighting/Multiple-lights">Multiple lights </a></li><li id="Lighting/Review"><a id="menu-item57" href="https://learnopengl.com/Lighting/Review">Review </a></li></ol></li><li id="Model-Loading"><span id="menu-item56" class="closed">Model Loading </span><ol id="menu-items-of56" style="display:none;"><li id="Model-Loading/Assimp"><a id="menu-item59" href="https://learnopengl.com/Model-Loading/Assimp">Assimp </a></li><li id="Model-Loading/Mesh"><a id="menu-item60" href="https://learnopengl.com/Model-Loading/Mesh">Mesh </a></li><li id="Model-Loading/Model"><a id="menu-item61" href="https://learnopengl.com/Model-Loading/Model">Model </a></li></ol></li><li id="Advanced-OpenGL"><span id="menu-item63" class="closed">Advanced OpenGL </span><ol id="menu-items-of63" style="display:none;"><li id="Advanced-OpenGL/Depth-testing"><a id="menu-item72" href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">Depth testing </a></li><li id="Advanced-OpenGL/Stencil-testing"><a id="menu-item73" href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">Stencil testing </a></li><li id="Advanced-OpenGL/Blending"><a id="menu-item74" href="https://learnopengl.com/Advanced-OpenGL/Blending">Blending </a></li><li id="Advanced-OpenGL/Face-culling"><a id="menu-item77" href="https://learnopengl.com/Advanced-OpenGL/Face-culling">Face culling </a></li><li id="Advanced-OpenGL/Framebuffers"><a id="menu-item65" href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">Framebuffers </a></li><li id="Advanced-OpenGL/Cubemaps"><a id="menu-item66" href="https://learnopengl.com/Advanced-OpenGL/Cubemaps">Cubemaps </a></li><li id="Advanced-OpenGL/Advanced-Data"><a id="menu-item69" href="https://learnopengl.com/Advanced-OpenGL/Advanced-Data">Advanced Data </a></li><li id="Advanced-OpenGL/Advanced-GLSL"><a id="menu-item67" href="https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL">Advanced GLSL </a></li><li id="Advanced-OpenGL/Geometry-Shader"><a id="menu-item68" href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader">Geometry Shader </a></li><li id="Advanced-OpenGL/Instancing"><a id="menu-item70" href="https://learnopengl.com/Advanced-OpenGL/Instancing">Instancing </a></li><li id="Advanced-OpenGL/Anti-Aliasing"><a id="menu-item75" href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">Anti Aliasing </a></li></ol></li><li id="Advanced-Lighting"><span id="menu-item100" class="open">Advanced Lighting </span><ol id="menu-items-of100" style=""><li id="Advanced-Lighting/Advanced-Lighting"><a id="menu-item101" href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">Advanced Lighting </a></li><li id="Advanced-Lighting/Gamma-Correction"><a id="menu-item110" href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">Gamma Correction </a></li><li id="Advanced-Lighting/Shadows"><span id="menu-item102" class="open">Shadows </span><ol id="menu-items-of102" style=""><li id="Advanced-Lighting/Shadows/Shadow-Mapping"><a id="menu-item103" href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping" class="selected">Shadow Mapping </a></li><li id="Advanced-Lighting/Shadows/Point-Shadows"><a id="menu-item104" href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows">Point Shadows </a></li></ol></li><li id="Advanced-Lighting/Normal-Mapping"><a id="menu-item106" href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">Normal Mapping </a></li><li id="Advanced-Lighting/Parallax-Mapping"><a id="menu-item107" href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">Parallax Mapping </a></li><li id="Advanced-Lighting/HDR"><a id="menu-item111" href="https://learnopengl.com/Advanced-Lighting/HDR">HDR </a></li><li id="Advanced-Lighting/Bloom"><a id="menu-item112" href="https://learnopengl.com/Advanced-Lighting/Bloom">Bloom </a></li><li id="Advanced-Lighting/Deferred-Shading"><a id="menu-item108" href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">Deferred Shading </a></li><li id="Advanced-Lighting/SSAO"><a id="menu-item109" href="https://learnopengl.com/Advanced-Lighting/SSAO">SSAO </a></li></ol></li><li id="PBR"><span id="menu-item113" class="closed">PBR </span><ol id="menu-items-of113" style="display:none;"><li id="PBR/Theory"><a id="menu-item114" href="https://learnopengl.com/PBR/Theory">Theory </a></li><li id="PBR/Lighting"><a id="menu-item115" href="https://learnopengl.com/PBR/Lighting">Lighting </a></li><li id="PBR/IBL"><span id="menu-item116" class="closed">IBL </span><ol id="menu-items-of116" style="display:none;"><li id="PBR/IBL/Diffuse-irradiance"><a id="menu-item117" href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">Diffuse irradiance </a></li><li id="PBR/IBL/Specular-IBL"><a id="menu-item118" href="https://learnopengl.com/PBR/IBL/Specular-IBL">Specular IBL </a></li></ol></li></ol></li><li id="In-Practice"><span id="menu-item78" class="closed">In Practice </span><ol id="menu-items-of78" style="display:none;"><li id="In-Practice/Debugging"><a id="menu-item79" href="https://learnopengl.com/In-Practice/Debugging">Debugging </a></li><li id="In-Practice/Text-Rendering"><a id="menu-item80" href="https://learnopengl.com/In-Practice/Text-Rendering">Text Rendering </a></li><li id="In-Practice/2D-Game"><span id="menu-item81" class="closed">2D Game </span><ol id="menu-items-of81" style="display:none;"><li id="In-Practice/2D-Game/Breakout"><a id="menu-item82" href="https://learnopengl.com/In-Practice/2D-Game/Breakout">Breakout </a></li><li id="In-Practice/2D-Game/Setting-up"><a id="menu-item88" href="https://learnopengl.com/In-Practice/2D-Game/Setting-up">Setting up </a></li><li id="In-Practice/2D-Game/Rendering-Sprites"><a id="menu-item83" href="https://learnopengl.com/In-Practice/2D-Game/Rendering-Sprites">Rendering Sprites </a></li><li id="In-Practice/2D-Game/Levels"><a id="menu-item84" href="https://learnopengl.com/In-Practice/2D-Game/Levels">Levels </a></li><li id="In-Practice/2D-Game/Collisions"><span id="menu-item85" class="closed">Collisions </span><ol id="menu-items-of85" style="display:none;"><li id="In-Practice/2D-Game/Collisions/Ball"><a id="menu-item95" href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Ball">Ball </a></li><li id="In-Practice/2D-Game/Collisions/Collision-detection"><a id="menu-item96" href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection">Collision detection </a></li><li id="In-Practice/2D-Game/Collisions/Collision-resolution"><a id="menu-item97" href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-resolution">Collision resolution </a></li></ol></li><li id="In-Practice/2D-Game/Particles"><a id="menu-item89" href="https://learnopengl.com/In-Practice/2D-Game/Particles">Particles </a></li><li id="In-Practice/2D-Game/Postprocessing"><a id="menu-item90" href="https://learnopengl.com/In-Practice/2D-Game/Postprocessing">Postprocessing </a></li><li id="In-Practice/2D-Game/Powerups"><a id="menu-item91" href="https://learnopengl.com/In-Practice/2D-Game/Powerups">Powerups </a></li><li id="In-Practice/2D-Game/Audio"><a id="menu-item94" href="https://learnopengl.com/In-Practice/2D-Game/Audio">Audio </a></li><li id="In-Practice/2D-Game/Render-text"><a id="menu-item92" href="https://learnopengl.com/In-Practice/2D-Game/Render-text">Render text </a></li><li id="In-Practice/2D-Game/Final-thoughts"><a id="menu-item93" href="https://learnopengl.com/In-Practice/2D-Game/Final-thoughts">Final thoughts </a></li></ol></li></ol></li><li id="Guest-Articles"><span id="menu-item125" class="closed">Guest Articles </span><ol id="menu-items-of125" style="display:none;"><li id="Guest-Articles/How-to-publish"><a id="menu-item126" href="https://learnopengl.com/Guest-Articles/How-to-publish">How to publish </a></li></ol></li><li id="Code-repository"><a id="menu-item99" href="https://learnopengl.com/Code-repository">Code repository </a></li><li id="Translations"><a id="menu-item119" href="https://learnopengl.com/Translations">Translations </a></li><li id="About"><a id="menu-item2" href="https://learnopengl.com/About">About </a></li></ol>       <div id="donate">
            <a href="https://www.paypal.me/learnopengl/" target="_blank">
                <div id="donate_img"></div>
                <img style="display: none" src="/img/donate_button_hover.png" />
                <!--<img id="donate_img" src="img/patreon.png"/>-->
            </a>
          <!--<div id="alipay">
            <img style="width: 150px;" class="clean" src="/img/alipay_logo.png"/>
            <img style="width: 150px; margin-top: 5px" src="/img/alipay.png"/>
          </div>-->
        </div> 
      <div id="menu_book">
            <a href="https://www.amazon.com/dp/9090332561/" target="_blank"><img src="/book/below_menu.png" class="clean" /></a>
        </div>
        <div id="alipay">
          
        </div>
        <div id="ad">
							<!--<div id="waldo-tag-1684"></div>-->
			        </div>
      
        <div id="lefttwothirdad" style="display: block; top: 8138.67px;">
            <div id="waldo-tag-2245" data-processed="true" data-google-query-id="COjQjN7O5e0CFQGCvQodWKgIXA"><div id="google_ads_iframe_/124067137/learnopengl300x600FL_1_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137/learnopengl300x600FL_1_0" title="3rd party ad content" name="google_ads_iframe_/124067137/learnopengl300x600FL_1_0" width="300" height="600" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" srcdoc="" style="border: 0px; vertical-align: bottom;" data-google-container-id="3" data-load-complete="true"></iframe></div></div>
        </div>
    </div>
    
    <div id="content">
    <h1 id="content-title">Shadow Mapping</h1>
<h1 id="content-url" style="display:none;">Advanced-Lighting/Shadows/Shadow-Mapping</h1>
<p>
  Shadows are a result of the absence of light due to occlusion. When a light source's light rays do not hit an object because it gets occluded by some other object, the object is in shadow. Shadows add a great deal of realism to a lit scene and make it easier for a viewer to observe spatial relationships between objects. They give a greater sense of depth to our scene and objects. For example, take a look at the following image of a scene with and without shadows:
  
</p>

<img src="/img/advanced-lighting/shadow_mapping_with_without.png" alt="comparrison of shadows in a scene with and without in OpenGL" />
  
<p>
  You can see that with shadows it becomes much more obvious how the objects relate to each other. For instance, the fact that one of the cubes is floating above the others is only really noticeable when we have shadows.
</p>
  
<p>
  Shadows are a bit tricky to implement though, specifically because in current real-time (rasterized graphics) research a perfect shadow algorithm hasn't been developed yet. There are several good shadow approximation techniques, but they all have their little quirks and annoyances which we have to take into account.
</p>
  
<p>
  One technique used by most videogames that gives decent results and is relatively easy to implement is <def>shadow mapping</def>. Shadow mapping is not too difficult to understand, doesn't cost too much in performance and quite easily extends into more advanced algorithms (like <a href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows" target="_blank">Omnidirectional Shadow Maps</a> and Cascaded Shadow Maps). 
</p>
  
<h2>Shadow mapping</h2>
<p>
   The idea behind shadow mapping is quite simple: we render the scene from the light's point of view and everything we see from the light's perspective is lit and everything we can't see must be in shadow. Imagine a floor section with a large box between itself and a light source. Since the light source will see this box and not the floor section when looking in its direction that specific floor section should be in shadow. 
</p>
  
  <img src="/img/advanced-lighting/shadow_mapping_theory.png" class="clean" alt="Shadow mapping illustrated." />
    
<p>
   Here all the blue lines represent the fragments that the light source can see. The occluded fragments are shown as black lines: these are rendered as being shadowed. If we were to draw a line or <def>ray</def> from the light source to a fragment on the right-most box we can see the ray first hits the floating container before hitting the right-most container. As a result, the floating container's fragment is lit and the right-most container's fragment is not lit and thus in shadow.
</p>
    
<p>
  We want to get the point on the ray where it first hit an object and compare this <em>closest point</em> to other points on this ray. We then do a basic test to see if a test point's ray position is further down the ray than the closest point and if so, the test point must be in shadow. Iterating through possibly thousands of light rays from such a light source is an extremely inefficient approach and doesn't lend itself too well for real-time rendering. We can do something similar, but without casting light rays. Instead, we use something we're quite familiar with: the depth buffer.
</p>
    
<p>
  You may remember from the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter that a value in the depth buffer corresponds to the depth of a fragment clamped to [0,1] from the camera's point of view. What if we were to render the scene from the light's perspective and store the resulting depth values in a texture? This way, we can sample the closest depth values as seen from the light's perspective. After all, the depth values show the first fragment visible from the light's perspective. We store all these depth values in a texture that we call a <def>depth map</def> or <def>shadow map</def>.
</p>
    
    <img src="/img/advanced-lighting/shadow_mapping_theory_spaces.png" class="clean" alt="Different coordinate transforms / spaces for shadow mapping." />
      
<p>
  The left image shows a directional light source (all light rays are parallel) casting a shadow on the surface below the cube. Using the depth values stored in the depth map we find the closest point and use that to determine whether fragments are in shadow. We create the depth map by rendering the scene (from the light's perspective) using a view and projection matrix specific to that light source. This projection and view matrix together form a transformation <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" role="math" style="width: 0.811em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.703em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.404em, 1000.7em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">T<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></span></span><script type="math/tex" id="MathJax-Element-1">T</script> that transforms any 3D position to the light's (visible) coordinate space.
</p>
            
<note>
  A directional light doesn't have a position as it's modelled to be infinitely far away. However, for the sake of shadow mapping we need to render the scene from a light's perspective and thus render the scene from a position somewhere along the lines of the light direction.
</note>
      
 <p>
  In the right image we see the same directional light and the viewer. We render a fragment at point <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-4" role="math" style="width: 0.973em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.242em, 1000.76em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-5"><span class="texatom" id="MathJax-Span-6"><span class="mrow" id="MathJax-Span-7"><span class="munderover" id="MathJax-Span-8"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.76em, 4.151em, -999.997em); top: -3.984em; left: 0.003em;"><span class="mstyle" id="MathJax-Span-9" style="color: red;"><span class="mrow" id="MathJax-Span-10" style="color: red;"><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span><span style="position: absolute; clip: rect(3.235em, 1000.43em, 3.613em, -999.997em); top: -4.254em; left: 0.326em;"><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-2">\bar{\color{red}{P}}</script> for which we have to determine whether it is in shadow. To do this, we first transform point <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-13" role="math" style="width: 0.973em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.242em, 1000.76em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-14"><span class="texatom" id="MathJax-Span-15"><span class="mrow" id="MathJax-Span-16"><span class="munderover" id="MathJax-Span-17"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.76em, 4.151em, -999.997em); top: -3.984em; left: 0.003em;"><span class="mstyle" id="MathJax-Span-18" style="color: red;"><span class="mrow" id="MathJax-Span-19" style="color: red;"><span class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span><span style="position: absolute; clip: rect(3.235em, 1000.43em, 3.613em, -999.997em); top: -4.254em; left: 0.326em;"><span class="mo" id="MathJax-Span-21" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-3">\bar{\color{red}{P}}</script> to the light's coordinate space using <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-22" role="math" style="width: 0.811em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.703em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.404em, 1000.7em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-23"><span class="mi" id="MathJax-Span-24" style="font-family: MathJax_Math-italic;">T<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></span></span><script type="math/tex" id="MathJax-Element-4">T</script>. Since point <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-5-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-25" role="math" style="width: 0.973em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.242em, 1000.76em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-26"><span class="texatom" id="MathJax-Span-27"><span class="mrow" id="MathJax-Span-28"><span class="munderover" id="MathJax-Span-29"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.76em, 4.151em, -999.997em); top: -3.984em; left: 0.003em;"><span class="mstyle" id="MathJax-Span-30" style="color: red;"><span class="mrow" id="MathJax-Span-31" style="color: red;"><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span><span style="position: absolute; clip: rect(3.235em, 1000.43em, 3.613em, -999.997em); top: -4.254em; left: 0.326em;"><span class="mo" id="MathJax-Span-33" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-5">\bar{\color{red}{P}}</script> is now as seen from the light's perspective, its <code>z</code> coordinate corresponds to its depth which in this example is <code>0.9</code>. Using point <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-6-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-34" role="math" style="width: 0.973em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.242em, 1000.76em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-35"><span class="texatom" id="MathJax-Span-36"><span class="mrow" id="MathJax-Span-37"><span class="munderover" id="MathJax-Span-38"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.76em, 4.151em, -999.997em); top: -3.984em; left: 0.003em;"><span class="mstyle" id="MathJax-Span-39" style="color: red;"><span class="mrow" id="MathJax-Span-40" style="color: red;"><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span><span style="position: absolute; clip: rect(3.235em, 1000.43em, 3.613em, -999.997em); top: -4.254em; left: 0.326em;"><span class="mo" id="MathJax-Span-42" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-6">\bar{\color{red}{P}}</script> we can also index the depth/shadow map to obtain the closest visible depth from the light's perspective, which is at point <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-7-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;green&quot;&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-43" role="math" style="width: 0.919em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.757em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.242em, 1000.76em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-44"><span class="texatom" id="MathJax-Span-45"><span class="mrow" id="MathJax-Span-46"><span class="munderover" id="MathJax-Span-47"><span style="display: inline-block; position: relative; width: 0.757em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.76em, 4.151em, -999.997em); top: -3.984em; left: 0.003em;"><span class="mstyle" id="MathJax-Span-48" style="color: green;"><span class="mrow" id="MathJax-Span-49" style="color: green;"><span class="mi" id="MathJax-Span-50" style="font-family: MathJax_Math-italic; color: green;">C<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.057em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span><span style="position: absolute; clip: rect(3.235em, 1000.43em, 3.613em, -999.997em); top: -4.254em; left: 0.272em;"><span class="mo" id="MathJax-Span-51" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.191em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="green"><mi>C</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-7">\bar{\color{green}{C}}</script> with a sampled depth of <code>0.4</code>. Since indexing the depth map returns a depth smaller than the depth at point <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-8-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-52" role="math" style="width: 0.973em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.242em, 1000.76em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-53"><span class="texatom" id="MathJax-Span-54"><span class="mrow" id="MathJax-Span-55"><span class="munderover" id="MathJax-Span-56"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.76em, 4.151em, -999.997em); top: -3.984em; left: 0.003em;"><span class="mstyle" id="MathJax-Span-57" style="color: red;"><span class="mrow" id="MathJax-Span-58" style="color: red;"><span class="mi" id="MathJax-Span-59" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span><span style="position: absolute; clip: rect(3.235em, 1000.43em, 3.613em, -999.997em); top: -4.254em; left: 0.326em;"><span class="mo" id="MathJax-Span-60" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-8">\bar{\color{red}{P}}</script> we can conclude point <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-9-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-61" role="math" style="width: 0.973em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.242em, 1000.76em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-62"><span class="texatom" id="MathJax-Span-63"><span class="mrow" id="MathJax-Span-64"><span class="munderover" id="MathJax-Span-65"><span style="display: inline-block; position: relative; width: 0.811em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.76em, 4.151em, -999.997em); top: -3.984em; left: 0.003em;"><span class="mstyle" id="MathJax-Span-66" style="color: red;"><span class="mrow" id="MathJax-Span-67" style="color: red;"><span class="mi" id="MathJax-Span-68" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span><span style="position: absolute; clip: rect(3.235em, 1000.43em, 3.613em, -999.997em); top: -4.254em; left: 0.326em;"><span class="mo" id="MathJax-Span-69" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 3.99em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-9">\bar{\color{red}{P}}</script> is occluded and thus in shadow. 
</p>

    
<p>
  Shadow mapping therefore consists of two passes: first we render the depth map, and in the second pass we render the scene as normal and use the generated depth map to calculate whether fragments are in shadow. It may sound a bit complicated, but as soon as we walk through the technique step-by-step it'll likely start to make sense. 
</p>
    
<h2>The depth map</h2>
<p>
  The first pass requires us to generate a depth map. The depth map is the depth texture as rendered from the light's perspective that we'll be using for testing for shadows. Because we need to store the rendered result of a scene into a texture we're going to need <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> again.
</p>
      
<p>
  First we'll create a framebuffer object for rendering the depth map:
</p>
      
<pre><code class=" hljs cpp">
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> depthMapFBO;
<function id="76">glGenFramebuffers</function>(<span class="hljs-number">1</span>, &amp;depthMapFBO);  
</code></pre>
      
<p>
  Next we create a 2D texture that we'll use as the framebuffer's depth buffer:
</p>
      
<pre><code class=" hljs cpp">
<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> SHADOW_WIDTH = <span class="hljs-number">1024</span>, SHADOW_HEIGHT = <span class="hljs-number">1024</span>;

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> depthMap;
<function id="50">glGenTextures</function>(<span class="hljs-number">1</span>, &amp;depthMap);
<function id="48">glBindTexture</function>(GL_TEXTURE_2D, depthMap);
<function id="52">glTexImage2D</function>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT, 
             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT, <span class="hljs-built_in">GL_FLOAT</span>, NULL);
<function id="15">glTexParameter</function>i(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
<function id="15">glTexParameter</function>i(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
<function id="15">glTexParameter</function>i(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); 
<function id="15">glTexParameter</function>i(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);  
</code></pre>
      
<p>
  Generating the depth map shouldn't look too complicated. Because we only care about depth values we specify the texture's formats as <var>GL_DEPTH_COMPONENT</var>. We also give the texture a width and height of <code>1024</code>: this is the resolution of the depth map. 
</p>
      
<p>
  With the generated depth texture we can attach it as the framebuffer's depth buffer:
</p>

<pre class="cpp"><code class=" hljs ">
<function id="77">glBindFramebuffer</function>(GL_FRAMEBUFFER, depthMapFBO);
<function id="81">glFramebufferTexture2D</function>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="hljs-number">0</span>);
glDrawBuffer(GL_NONE);
glReadBuffer(GL_NONE);
<function id="77">glBindFramebuffer</function>(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);  
</code></pre>

<p>
  We only need the depth information when rendering the scene from the light's perspective so there is no need for a color buffer. A framebuffer object however is not complete without a color buffer so we need to explicitly tell OpenGL we're not going to render any color data. We do this by setting both the read and draw buffer to <var>GL_NONE</var> with <fun>glDrawBuffer</fun> and <fun>glReadbuffer</fun>. 
</p>
      
<p>
  With a properly configured framebuffer that renders depth values to a texture we can start the first pass: generate the depth map. When combined with the second pass, the complete rendering stage will look a bit like this:
</p>
      
<pre><code class=" hljs cpp">
<span class="hljs-comment">// 1. first render to depth map</span>
<function id="22">glViewport</function>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);
<function id="77">glBindFramebuffer</function>(GL_FRAMEBUFFER, depthMapFBO);
    <function id="10">glClear</function>(GL_DEPTH_BUFFER_BIT);
    ConfigureShaderAndMatrices();
    RenderScene();
<function id="77">glBindFramebuffer</function>(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 2. then render scene as normal with shadow mapping (using depth map)</span>
<function id="22">glViewport</function>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT);
<function id="10">glClear</function>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
ConfigureShaderAndMatrices();
<function id="48">glBindTexture</function>(GL_TEXTURE_2D, depthMap);
RenderScene();
</code></pre>
      
<p>
  This code left out some details, but it'll give you the general idea of shadow mapping. What is important to note here are the calls to <fun><function id="22">glViewport</function></fun>. Because shadow maps often have a different resolution compared to what we originally render the scene in (usually the window resolution), we need to change the viewport parameters to accommodate for the size of the shadow map. If we forget to update the viewport parameters, the resulting depth map will be either incomplete or too small.
</p>
    
<h3>Light space transform</h3>
<p>
  An unknown in the previous snippet of code is the <fun>ConfigureShaderAndMatrices</fun> function. In the second pass this is business as usual: make sure proper projection and view matrices are set, and set the relevant model matrices per object. However, in the first pass we need to use a different projection and view matrix to render the scene from the light's point of view.
</p>
      
<p>
  Because we're modelling a directional light source, all its light rays are parallel. For this reason, we're going to use an orthographic projection matrix for the light source where there is no perspective deform:
</p>

<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> near_plane = <span class="hljs-number">1.0f</span>, far_plane = <span class="hljs-number">7.5f</span>;
glm::<span class="hljs-built_in">mat4</span> lightProjection = <function id="59">glm::ortho</function>(-<span class="hljs-number">10.0f</span>, <span class="hljs-number">10.0f</span>, -<span class="hljs-number">10.0f</span>, <span class="hljs-number">10.0f</span>, near_plane, far_plane);  
</code></pre>
      
<p>
  Here is an example orthographic projection matrix as used in this chapter's demo scene. Because a projection matrix indirectly determines the range of what is visible (e.g. what is not clipped) you want to make sure the size of the projection frustum correctly contains the objects you want to be in the depth map. When objects or fragments are not in the depth map they will not produce shadows.
</p>
      
<p>
  To create a view matrix to transform each object so they're visible from the light's point of view, we're going to use the infamous <fun><function id="62">glm::lookAt</function></fun> function; this time with the light source's position looking at the scene's center. 
</p>
      
<pre><code class=" hljs cpp">
glm::<span class="hljs-built_in">mat4</span> lightView = <function id="62">glm::lookAt</function>(glm::<span class="hljs-built_in">vec3</span>(-<span class="hljs-number">2.0f</span>, <span class="hljs-number">4.0f</span>, -<span class="hljs-number">1.0f</span>), 
                                  glm::<span class="hljs-built_in">vec3</span>( <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>), 
                                  glm::<span class="hljs-built_in">vec3</span>( <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">0.0f</span>));  
</code></pre>
      
<p>
  Combining these two gives us a light space transformation matrix that transforms each world-space vector into the space as visible from the light source; exactly what we need to render the depth map.
</p>
      
<pre><code class=" hljs cpp">
glm::<span class="hljs-built_in">mat4</span> lightSpaceMatrix = lightProjection * lightView; 
</code></pre>
      
<p>
  This <var>lightSpaceMatrix</var> is the transformation matrix that we earlier denoted as <span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-10-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-70" role="math" style="width: 0.811em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.703em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.404em, 1000.7em, 2.427em, -999.997em); top: -2.26em; left: 0.003em;"><span class="mrow" id="MathJax-Span-71"><span class="mi" id="MathJax-Span-72" style="font-family: MathJax_Math-italic;">T<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.11em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.266em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></span></span><script type="math/tex" id="MathJax-Element-10">T</script>. With this <var>lightSpaceMatrix</var>, we can render the scene as usual as long as we give each shader the light-space equivalents of the projection and view matrices. However, we only care about depth values and not all the expensive fragment (lighting) calculations. To save performance we're going to use a different, but much simpler shader for rendering to the depth map.
</p>
      
<h3>Render to depth map</h3>
<p>
  When we render the scene from the light's perspective we'd much rather use a simple shader that only transforms the vertices to light space and not much more. For such a simple shader called <var>simpleDepthShader</var> we'll use the following vertex shader:
</p>
      
<pre><code class=" hljs cpp">
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">layout</span> (location = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">vec3</span> aPos;

<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">mat4</span> lightSpaceMatrix;
<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">mat4</span> model;

<span class="hljs-keyword">void</span> main()
{
    gl_Position = lightSpaceMatrix * model * <span class="hljs-built_in">vec4</span>(aPos, <span class="hljs-number">1.0</span>);
}  
</code></pre>
      
<p>
  This vertex shader takes a per-object model, a vertex, and transforms all vertices to light space using <var>lightSpaceMatrix</var>.
</p>      
      
<p>
  Since we have no color buffer and disabled the draw and read buffers, the resulting fragments do not require any processing so we can simply use an empty fragment shader:
</p>

<pre><code class=" hljs cpp">
<span class="hljs-preprocessor">#version 330 core</span>

<span class="hljs-keyword">void</span> main()
{             
    <span class="hljs-comment">// gl_FragDepth = gl_FragCoord.z;</span>
}  
</code></pre>
      
<p>
  This empty fragment shader does no processing whatsoever, and at the end of its run the depth buffer is updated. We could explicitly set the depth by uncommenting its one line, but this is effectively what happens behind the scene anyways.
</p>
      
<p>
  Rendering the depth/shadow map now effectively becomes:
</p>
      
<pre><code class=" hljs cpp">
simpleDepthShader.use();
<function id="44">glUniform</function>Matrix4fv(lightSpaceMatrixLocation, <span class="hljs-number">1</span>, <span class="hljs-built_in">GL_FALSE</span>, glm::value_ptr(lightSpaceMatrix));

<function id="22">glViewport</function>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);
<function id="77">glBindFramebuffer</function>(GL_FRAMEBUFFER, depthMapFBO);
    <function id="10">glClear</function>(GL_DEPTH_BUFFER_BIT);
    RenderScene(simpleDepthShader);
<function id="77">glBindFramebuffer</function>(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);  
</code></pre>
      
<p>
  Here the <fun>RenderScene</fun> function takes a shader program, calls all relevant drawing functions and sets the corresponding model matrices where necessary. 
</p>

<p>
  The result is a nicely filled depth buffer holding the closest depth of each visible fragment from the light's perspective. By rendering this texture onto a 2D quad that fills the screen (similar to what we did in the post-processing section at the end of the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> chapter) we get something like this:
</p>
      
<img src="/img/advanced-lighting/shadow_mapping_depth_map.png" class="clean" alt="Depth (or shadow) map of shadow mapping technique" />
      
<p>
  For rendering the depth map onto a quad we used the following fragment shader:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec4</span> FragColor;
  
<span class="hljs-keyword">in</span> <span class="hljs-built_in">vec2</span> TexCoords;

<span class="hljs-keyword">uniform</span> sampler2D depthMap;

<span class="hljs-keyword">void</span> main()
{             
    <span class="hljs-keyword">float</span> depthValue = texture(depthMap, TexCoords).r;
    FragColor = <span class="hljs-built_in">vec4</span>(<span class="hljs-built_in">vec3</span>(depthValue), <span class="hljs-number">1.0</span>);
}  
</code></pre>
  
<p>
  Note that there are some subtle changes when displaying depth using a perspective projection matrix instead of an orthographic projection matrix as depth is non-linear when using perspective projection. At the end of this chapter we'll discuss some of these subtle differences.
</p>
  
<p>
  You can find the source code for rendering a scene to a depth map <a href="/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.1.shadow_mapping_depth/shadow_mapping_depth.cpp" target="_blank">here</a>.
</p>
      
<h2>Rendering shadows</h2>  
<p>
  With a properly generated depth map we can start rendering the actual shadows. The code to check if a fragment is in shadow is (quite obviously) executed in the fragment shader, but we do the light-space transformation in the vertex shader:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">layout</span> (location = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">vec3</span> aPos;
<span class="hljs-keyword">layout</span> (location = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">vec3</span> aNormal;
<span class="hljs-keyword">layout</span> (location = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">vec2</span> aTexCoords;

<span class="hljs-keyword">out</span> VS_OUT {
    <span class="hljs-built_in">vec3</span> FragPos;
    <span class="hljs-built_in">vec3</span> Normal;
    <span class="hljs-built_in">vec2</span> TexCoords;
    <span class="hljs-built_in">vec4</span> FragPosLightSpace;
} vs_out;

<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">mat4</span> projection;
<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">mat4</span> view;
<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">mat4</span> model;
<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">mat4</span> lightSpaceMatrix;

<span class="hljs-keyword">void</span> main()
{    
    vs_out.FragPos = <span class="hljs-built_in">vec3</span>(model * <span class="hljs-built_in">vec4</span>(aPos, <span class="hljs-number">1.0</span>));
    vs_out.Normal = transpose(inverse(<span class="hljs-built_in">mat3</span>(model))) * aNormal;
    vs_out.TexCoords = aTexCoords;
    vs_out.FragPosLightSpace = lightSpaceMatrix * <span class="hljs-built_in">vec4</span>(vs_out.FragPos, <span class="hljs-number">1.0</span>);
    gl_Position = projection * view * <span class="hljs-built_in">vec4</span>(vs_out.FragPos, <span class="hljs-number">1.0</span>);
}
</code></pre>
  
<p>
  What is new here is the extra output vector <var>FragPosLightSpace</var>. We take the same <var>lightSpaceMatrix</var> (used to transform vertices to light space in the depth map stage) and transform the world-space vertex position to light space for use in the fragment shader. 
</p>
  
<p>
  The main fragment shader we'll use to render the scene uses the Blinn-Phong lighting model. Within the fragment shader we then calculate a <var>shadow</var> value that is either <code>1.0</code> when the fragment is in shadow or <code>0.0</code> when not in shadow. The resulting <var>diffuse</var> and <var>specular</var> components are then multiplied by this shadow component. Because shadows are rarely completely dark (due to light scattering) we leave the <var>ambient</var> component out of the shadow multiplications. 
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec4</span> FragColor;

<span class="hljs-keyword">in</span> VS_OUT {
    <span class="hljs-built_in">vec3</span> FragPos;
    <span class="hljs-built_in">vec3</span> Normal;
    <span class="hljs-built_in">vec2</span> TexCoords;
    <span class="hljs-built_in">vec4</span> FragPosLightSpace;
} fs_in;

<span class="hljs-keyword">uniform</span> sampler2D diffuseTexture;
<span class="hljs-keyword">uniform</span> sampler2D shadowMap;

<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">vec3</span> lightPos;
<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">vec3</span> viewPos;

<span class="hljs-keyword">float</span> ShadowCalculation(<span class="hljs-built_in">vec4</span> fragPosLightSpace)
{
    [...]
}

<span class="hljs-keyword">void</span> main()
{           
    <span class="hljs-built_in">vec3</span> color = texture(diffuseTexture, fs_in.TexCoords).rgb;
    <span class="hljs-built_in">vec3</span> normal = normalize(fs_in.Normal);
    <span class="hljs-built_in">vec3</span> lightColor = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0</span>);
    <span class="hljs-comment">// ambient</span>
    <span class="hljs-built_in">vec3</span> ambient = <span class="hljs-number">0.15</span> * color;
    <span class="hljs-comment">// diffuse</span>
    <span class="hljs-built_in">vec3</span> lightDir = normalize(lightPos - fs_in.FragPos);
    <span class="hljs-keyword">float</span> diff = max(dot(lightDir, normal), <span class="hljs-number">0.0</span>);
    <span class="hljs-built_in">vec3</span> diffuse = diff * lightColor;
    <span class="hljs-comment">// specular</span>
    <span class="hljs-built_in">vec3</span> viewDir = normalize(viewPos - fs_in.FragPos);
    <span class="hljs-keyword">float</span> spec = <span class="hljs-number">0.0</span>;
    <span class="hljs-built_in">vec3</span> halfwayDir = normalize(lightDir + viewDir);  
    spec = <span class="hljs-built_in">pow</span>(max(dot(normal, halfwayDir), <span class="hljs-number">0.0</span>), <span class="hljs-number">64.0</span>);
    <span class="hljs-built_in">vec3</span> specular = spec * lightColor;    
    <span class="hljs-comment">// calculate shadow</span>
    <span class="hljs-keyword">float</span> shadow = ShadowCalculation(fs_in.FragPosLightSpace);       
    <span class="hljs-built_in">vec3</span> lighting = (ambient + (<span class="hljs-number">1.0</span> - shadow) * (diffuse + specular)) * color;    
    
    FragColor = <span class="hljs-built_in">vec4</span>(lighting, <span class="hljs-number">1.0</span>);
}
</code></pre>
  
<p>
  The fragment shader is largely a copy from what we used in the <a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting" target="_blank">advanced lighting</a> chapter, but with an added shadow calculation. We declared a function <fun>ShadowCalculation</fun> that does most of the shadow work. At the end of the fragment shader, we multiply the diffuse and specular contributions by the inverse of the <var>shadow</var> component e.g. how much the fragment is <em>not</em> in shadow. This fragment shader takes as extra input the light-space fragment position and the depth map generated from the first render pass.
</p>

<p>
  The first thing to do to check whether a fragment is in shadow, is transform the light-space fragment position in clip-space to normalized device coordinates. When we output a clip-space vertex position to <var>gl_Position</var> in the vertex shader, OpenGL automatically does a perspective divide e.g. transform clip-space coordinates in the range [<code>-w</code>,<code>w</code>] to [<code>-1</code>,<code>1</code>] by dividing the <code>x</code>, <code>y</code> and <code>z</code> component by the vector's <code>w</code> component. As the clip-space <var>FragPosLightSpace</var> is not passed to the fragment shader through <var>gl_Position</var>, we have to do this perspective divide ourselves:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> ShadowCalculation(<span class="hljs-built_in">vec4</span> fragPosLightSpace)
{
    <span class="hljs-comment">// perform perspective divide</span>
    <span class="hljs-built_in">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    [...]
}
</code></pre>
  
<p>
  This returns the fragment's light-space position in the range [<code>-1</code>,<code>1</code>].
</p>

  <note>
    When using an orthographic projection matrix the <code>w</code> component of a vertex remains untouched so this step is actually quite meaningless. However, it is necessary when using perspective projection so keeping this line ensures it works with both projection matrices.
  </note>
  
<p>
    Because the depth from the depth map is in the range [<code>0</code>,<code>1</code>] and we also want to use <var>projCoords</var> to sample from the depth map, we transform the NDC coordinates to the range [<code>0</code>,<code>1</code>]:
</p>
  
<pre class="cpp"><code class=" hljs ">
projCoords = projCoords * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>; 
</code></pre>
  
<p>
  With these projected coordinates we can sample the depth map as the resulting [<code>0</code>,<code>1</code>] coordinates from <var>projCoords</var> directly correspond to the transformed NDC coordinates from the first render pass. This gives us the closest depth from the light's point of view:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> closestDepth = texture(shadowMap, projCoords.xy).r;   
</code></pre>
  
<p>
  To get the current depth at this fragment we simply retrieve the projected vector's <code>z</code> coordinate which equals the depth of this fragment from the light's perspective.
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> currentDepth = projCoords.z;  
</code></pre>
  
<p>
  The actual comparison is then simply a check whether <var>currentDepth</var> is higher than <var>closestDepth</var> and if so, the fragment is in shadow:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;  
</code></pre>
  
<p>
  The complete <fun>ShadowCalculation</fun> function then becomes:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> ShadowCalculation(<span class="hljs-built_in">vec4</span> fragPosLightSpace)
{
    <span class="hljs-comment">// perform perspective divide</span>
    <span class="hljs-built_in">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    <span class="hljs-comment">// transform to [0,1] range</span>
    projCoords = projCoords * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;
    <span class="hljs-comment">// get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)</span>
    <span class="hljs-keyword">float</span> closestDepth = texture(shadowMap, projCoords.xy).r; 
    <span class="hljs-comment">// get depth of current fragment from light's perspective</span>
    <span class="hljs-keyword">float</span> currentDepth = projCoords.z;
    <span class="hljs-comment">// check whether current frag pos is in shadow</span>
    <span class="hljs-keyword">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;

    <span class="hljs-keyword">return</span> shadow;
}  
</code></pre>
  
<p>
  Activating this shader, binding the proper textures, and activating the default projection and view matrices in the second render pass should give you a result similar to the image below:
</p>
  
  <img src="/img/advanced-lighting/shadow_mapping_shadows.png" class="clean" alt="Shadow mapped images, without improvements." />
    
<p>
  If you did things right you should indeed see (albeit with quite a few artifacts) shadows on the floor and the cubes. You can find the source code of the demo application <a href="/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.2.shadow_mapping_base/shadow_mapping_base.cpp" target="_blank">here</a>.
</p>    
  
<h2>Improving shadow maps</h2>
<p>
  We managed to get the basics of shadow mapping working, but as you can we're not there yet due to several (clearly visible) artifacts related to shadow mapping we need to fix. We'll focus on fixing these artifacts in the next sections.
</p> 
    
<h3>Shadow acne</h3>
<p>
    It is obvious something is wrong from the previous image. A closer zoom shows us a very obvious Moiré-like pattern:
</p>
    
    <img src="/img/advanced-lighting/shadow_mapping_acne.png" alt="Image of shadow acne as Moiré pattern with shadow mapping" />
      
<p>
  We can see a large part of the floor quad rendered with obvious black lines in an alternating fashion. This shadow mapping artifact is called <def>shadow acne</def> and can be explained by the following image:
</p>
      
<img src="/img/advanced-lighting/shadow_mapping_acne_diagram.png" class="clean" alt="Shadow acne explained" />
        
<p>
  Because the shadow map is limited by resolution, multiple fragments can sample the same value from the depth map when they're relatively far away from the light source. The image shows the floor where each yellow tilted panel represents a single texel of the depth map. As you can see, several fragments sample the same depth sample. 
  </p>
  
<p>
  While this is generally okay, it becomes an issue when the light source looks at an angle towards the surface as in that case the depth map is also rendered from an angle. Several fragments then access the same tilted depth texel while some are above and some below the floor; we get a shadow discrepancy. Because of this, some fragments are considered to be in shadow and some are not, giving the striped pattern from the image.
</p>
  
<p>
  We can solve this issue with a small little hack called a <def>shadow bias</def> where we simply offset the depth of the surface (or the shadow map) by a small bias amount such that the fragments are not incorrectly considered below the surface. 
</p>
  
 <img src="/img/advanced-lighting/shadow_mapping_acne_bias.png" class="clean" alt="Shadow mapping, with shadow acne fixed using shadow bias." />
   
<p>
  With the bias applied, all the samples get a depth smaller than the surface's depth and thus the entire surface is correctly lit without any shadows. We can implement such a bias as follows:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> bias = <span class="hljs-number">0.005</span>;
<span class="hljs-keyword">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;  
</code></pre>
  
<p>
  A shadow bias of <code>0.005</code> solves the issues of our scene by a large extent, but you can imagine the bias value is highly dependent on the angle between the light source and the surface. If the surface would have a steep angle to the light source, the shadows may still display shadow acne. A more solid approach would be to change the amount of bias based on the surface angle towards the light: something we can solve with the dot product:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> bias = max(<span class="hljs-number">0.05</span> * (<span class="hljs-number">1.0</span> - dot(normal, lightDir)), <span class="hljs-number">0.005</span>);  
</code></pre>
  
<p>
  Here we have a maximum bias of <code>0.05</code> and a minimum of <code>0.005</code> based on the surface's normal and light direction. This way, surfaces like the floor that are almost perpendicular to the light source get a small bias, while surfaces like the cube's side-faces get a much larger bias. The following image shows the same scene but now with a shadow bias:
</p>
  
   
  <img src="/img/advanced-lighting/shadow_mapping_with_bias.png" class="clean" alt="Shadow mapped images, with (sloped) shadow bias applied." />
  
<p>
  Choosing the correct bias value(s) requires some tweaking as this will be different for each scene, but most of the time it's simply a matter of slowly incrementing the bias until all acne is removed.
</p>
  
<h3>Peter panning</h3>
<p>
  A disadvantage of using a shadow bias is that you're applying an offset to the actual depth of objects. As a result, the bias may become large enough to see a visible offset of shadows compared to the actual object locations as you can see below (with an exaggerated bias value):
</p>
  
  <img src="/img/advanced-lighting/shadow_mapping_peter_panning.png" class="clean" alt="Peter panning with shadow mapping implementation" />
    
<p>
  This shadow artifact is called <def>peter panning</def> since objects seem slightly <em>detached</em> from their shadows. We can use a little trick to solve most of the peter panning issue by using front face culling when rendering the depth map. You may remember from the <a href="https://learnopengl.com/Advanced-OpenGL/Face-Culling" target="_blank">face culling</a> chapter that OpenGL by default culls back-faces. By telling OpenGL we want to cull front faces during the shadow map stage we're switching that order around. 
</p>
    
<p>
  Because we only need depth values for the depth map it shouldn't matter for solid objects whether we take the depth of their front faces or their back faces. Using their back face depths doesn't give wrong results as it doesn't matter if we have shadows inside objects; we can't see there anyways.
</p>
    
    <img src="/img/advanced-lighting/shadow_mapping_culling.png" class="clean" alt="Shadow mapping showing how front face culling helps solve peter panning." />
    
<p>
  To fix peter panning we cull all front faces during the shadow map generation. Note that you need to enable <var>GL_CULL_FACE</var> first.
</p>
    
<pre><code class=" hljs cpp">
<function id="74">glCullFace</function>(GL_FRONT);
RenderSceneToDepthMap();
<function id="74">glCullFace</function>(GL_BACK); <span class="hljs-comment">// don't forget to reset original culling face</span>
</code></pre>
    
<p>
  This effectively solves the peter panning issues, but <strong>only for solid</strong> objects that actually have an inside without openings. In our scene for example, this works perfectly fine on the cubes. However, on the floor it won't work as well as culling the front face completely removes the floor from the equation. The floor is a single plane and would thus be completely culled. If one wants to solve peter panning with this trick, care has to be taken to only cull the front faces of objects where it makes sense. 
</p>    
    
<p>
  Another consideration is that objects that are close to the shadow receiver (like the distant cube) may still give incorrect results. However, with normal bias values you can generally avoid peter panning. 
</p>
      
<h3>Over sampling</h3>
<p>
  Another visual discrepancy which you may like or dislike is that regions outside the light's visible frustum are considered to be in shadow while they're (usually) not. This happens because projected coordinates outside the light's frustum are higher than <code>1.0</code> and will thus sample the depth texture outside its default range of [<code>0</code>,<code>1</code>]. Based on the texture's wrapping method, we will get incorrect depth results not based on the real depth values from the light source.
</p>
      
       <img src="/img/advanced-lighting/shadow_mapping_outside_frustum.png" class="clean" alt="Shadow mapping with edges of depth map visible, texture wrapping" />
<p>
  You can see in the image that there is some sort of imaginary region of light, and a large part outside this area is in shadow; this area represents the size of the depth map projected onto the floor. The reason this happens is that we earlier set the depth map's wrapping options to <var>GL_REPEAT</var>.
</p>
         
<p>
  What we'd rather have is that all coordinates outside the depth map's range have a depth of <code>1.0</code> which as a result means these coordinates will never be in shadow (as no object will have a depth larger than <code>1.0</code>). We can do this by configuring a texture border color and set the depth map's texture wrap options to <var>GL_CLAMP_TO_BORDER</var>:
</p>
      
<pre><code class=" hljs cpp">
<function id="15">glTexParameter</function>i(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
<function id="15">glTexParameter</function>i(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
<span class="hljs-keyword">float</span> borderColor[] = { <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span> };
<function id="15">glTexParameter</function>fv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);  
</code></pre>
      
<p>
  Now whenever we sample outside the depth map's [<code>0</code>,<code>1</code>] coordinate range, the <fun>texture</fun> function will always return a depth of <code>1.0</code>, producing a <var>shadow</var> value of <code>0.0</code>. The result now looks more plausible:
</p>
      
      <img src="/img/advanced-lighting/shadow_mapping_clamp_edge.png" class="clean" alt="Shadow mapping with texture wrapping set to clamp to border color" />
        
<p>
  There seems to still be one part showing a dark region. Those are the coordinates outside the far plane of the light's orthographic frustum. You can see that this dark region always occurs at the far end of the light source's frustum by looking at the shadow directions.
</p>
        
<p>
   A light-space projected fragment coordinate is further than the light's far plane when its <code>z</code> coordinate is larger than <code>1.0</code>. In that case the <var>GL_CLAMP_TO_BORDER</var> wrapping method doesn't work anymore as we compare the coordinate's <code>z</code> component with the depth map values; this always returns true for <code>z</code> larger than <code>1.0</code>.
</p>
        
<p>
  The fix for this is also relatively easy as we simply force the <var>shadow</var> value to <code>0.0</code> whenever the projected vector's <code>z</code> coordinate is larger than <code>1.0</code>:
</p>
 
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> ShadowCalculation(<span class="hljs-built_in">vec4</span> fragPosLightSpace)
{
    [...]
    <span class="hljs-keyword">if</span>(projCoords.z &gt; <span class="hljs-number">1.0</span>)
        shadow = <span class="hljs-number">0.0</span>;
    
    <span class="hljs-keyword">return</span> shadow;
}  
</code></pre>
       
<p>
  Checking the far plane and clamping the depth map to a manually specified border color solves the over-sampling of the depth map. This finally gives us the result we are looking for:
</p>
        
<img src="/img/advanced-lighting/shadow_mapping_over_sampling_fixed.png" class="clean" alt="Shadow mapping with over sampling fixed with border clamp to color and far plane fix." />               
        
<p>
  The result of all this does mean that we only have shadows where the projected fragment coordinates sit inside the depth map range so anything outside the light frustum will have no visible shadows. As games usually make sure this only occurs in the distance it is a much more plausible effect than the obvious black regions we had before.
</p>      
  
<h2>PCF</h2>
<p>
  The shadows right now are a nice addition to the scenery, but it's still not exactly what we want. If you were to zoom in on the shadows the resolution dependency of shadow mapping quickly becomes apparent.
</p>
  
  <img src="/img/advanced-lighting/shadow_mapping_zoom.png" alt="Zoomed in of shadows with shadow mappign technique shows jagged edges." />
    
<p>
  Because the depth map has a fixed resolution, the depth frequently usually spans more than one fragment per texel. As a result, multiple fragments sample the same depth value from the depth map and come to the same shadow conclusions, which produces these jagged blocky edges.
</p>      
    
<p>
  You can reduce these blocky shadows by increasing the depth map resolution, or by trying to fit the light frustum as closely to the scene as possible.
</p>
    
<p>
  Another (partial) solution to these jagged edges is called PCF, or <def>percentage-closer filtering</def>, which is a term that hosts many different filtering functions that produce <em>softer</em> shadows, making them appear less blocky or hard. The idea is to sample more than once from the depth map, each time with slightly different texture coordinates. For each individual sample we check whether it is in shadow or not. All the sub-results are then combined and averaged and we get a nice soft looking shadow.
</p>
    
<p>
  One simple implementation of PCF is to simply sample the surrounding texels of the depth map and average the results:
</p>
    
<pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> shadow = <span class="hljs-number">0.0</span>;
<span class="hljs-built_in">vec2</span> texelSize = <span class="hljs-number">1.0</span> / textureSize(shadowMap, <span class="hljs-number">0</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">1</span>; ++x)
{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = -<span class="hljs-number">1</span>; y &lt;= <span class="hljs-number">1</span>; ++y)
    {
        <span class="hljs-keyword">float</span> pcfDepth = texture(shadowMap, projCoords.xy + <span class="hljs-built_in">vec2</span>(x, y) * texelSize).r; 
        shadow += currentDepth - bias &gt; pcfDepth ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;        
    }    
}
shadow /= <span class="hljs-number">9.0</span>;
</code></pre>
    
<p>
  Here <fun>textureSize</fun> returns a <code>vec2</code> of the width and height of the given sampler texture at mipmap level <code>0</code>. 1 divided over this returns the size of a single texel that we use to offset the texture coordinates, making sure each new sample samples a different depth value. Here we sample 9 values around the projected coordinate's <code>x</code> and <code>y</code> value, test for shadow occlusion, and finally average the results by the total number of samples taken.
</p>
    
<p>
  By using more samples and/or varying the <var>texelSize</var> variable you can increase the quality of the soft shadows. Below you can see the shadows with simple PCF applied:
</p>
    
    <img src="/img/advanced-lighting/shadow_mapping_soft_shadows.png" alt="Soft shadows with PCF using shadow mapping" />
      
<p>
  From a distance the shadows look a lot better and less hard. If you zoom in you can still see the resolution artifacts of shadow mapping, but in general this gives good results for most applications. 
</p>
      
<p>
  You can find the complete source code of the example <a href="/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.3.shadow_mapping/shadow_mapping.cpp" target="_blank">here</a>.
</p>
      
<p>
  There is actually much more to PCF and quite a few techniques to considerably improve the quality of soft shadows, but for the sake of this chapter's length we'll leave that for a later discussion.
</p>
    
<h2>Orthographic vs projection</h2>
<p>
  There is a difference between rendering the depth map with an orthographic or a projection matrix. An orthographic projection matrix does not deform the scene with perspective so all view/light rays are parallel. This makes it a great projection matrix for directional lights. A perspective projection matrix however does deform all vertices based on perspective which gives different results. The following image shows the different shadow regions of both projection methods:
</p>
      
<img src="/img/advanced-lighting/shadow_mapping_projection.png" class="clean" alt="Shadow mapping difference between orthographic and perspective projection." />
  
<p>
  Perspective projections make most sense for light sources that have actual locations, unlike directional lights. Perspective projections are most often used with spotlights and point lights, while orthographic projections are used for directional lights.
</p>
  
<p>
  Another subtle difference with using a perspective projection matrix is that visualizing the depth buffer will often give an almost completely white result. This happens because with perspective projection the depth is transformed to non-linear depth values with most of its noticeable range close to the near plane. To be able to properly view the depth values as we did with the orthographic projection you first want to transform the non-linear depth values to linear as we discussed in the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter:
</p>
  
<pre><code class=" hljs cpp">
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec4</span> FragColor;
  
<span class="hljs-keyword">in</span> <span class="hljs-built_in">vec2</span> TexCoords;

<span class="hljs-keyword">uniform</span> sampler2D depthMap;
<span class="hljs-keyword">uniform</span> <span class="hljs-keyword">float</span> near_plane;
<span class="hljs-keyword">uniform</span> <span class="hljs-keyword">float</span> far_plane;

<span class="hljs-keyword">float</span> LinearizeDepth(<span class="hljs-keyword">float</span> depth)
{
    <span class="hljs-keyword">float</span> z = depth * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>; <span class="hljs-comment">// Back to NDC </span>
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2.0</span> * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));
}

<span class="hljs-keyword">void</span> main()
{             
    <span class="hljs-keyword">float</span> depthValue = texture(depthMap, TexCoords).r;
    FragColor = <span class="hljs-built_in">vec4</span>(<span class="hljs-built_in">vec3</span>(LinearizeDepth(depthValue) / far_plane), <span class="hljs-number">1.0</span>); <span class="hljs-comment">// perspective</span>
    <span class="hljs-comment">// FragColor = vec4(vec3(depthValue), 1.0); // orthographic</span>
}  
</code></pre>
  
<p>
  This shows depth values similar to what we've seen with orthographic projection. Note that this is only useful for debugging; the depth checks remain the same with orthographic or projection matrices as the relative depths do not change.
</p>

<h2>Additional resources</h2>
  <ul>
  <li><a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/" target="_blank">Tutorial 16 : Shadow mapping</a>: similar shadow mapping tutorial by opengl-tutorial.org with a few extra notes.</li>
    <li><a href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html" target="_blank">Shadow Mapping - Part 1</a>: another shadow mapping tutorial by ogldev.</li>
    <li><a href="https://www.youtube.com/watch?v=EsccgeUpdsM" target="_blank">How Shadow Mapping Works</a>: a 3-part YouTube tutorial by TheBennyBox on shadow mapping and its implementation.</li>
    <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324%28v=vs.85%29.aspx" target="_blank">Common Techniques to Improve Shadow Depth Maps</a>: a great article by Microsoft listing a large number of techniques to improve the quality of shadow maps.
</li></ul>       

    </div>
    
    <div id="hover">
        HI
    </div>
   <!-- 728x90/320x50 sticky footer -->
<div id="waldo-sticky-footer-wrapper"><div id="waldo-sticky-footer-inner"><div id="waldo-close-button" style="margin-left: auto; margin-right: auto; text-align: right;"><a style="text-decoration: none;" href="#">Close X</a></div><div id="waldo-tag-6196" data-google-query-id="COzQjN7O5e0CFQGCvQodWKgIXA"><div id="google_ads_iframe_/124067137/learnopengl728x90FS_1_0__container__" style="border: 0pt none; display: inline-block; width: 320px; height: 50px;"><iframe frameborder="0" src="https://1d637ffe1d1a51bb645e22469ce04136.safeframe.googlesyndication.com/safeframe/1-0-37/html/container.html" id="google_ads_iframe_/124067137/learnopengl728x90FS_1_0" title="3rd party ad content" name="" scrolling="no" marginwidth="0" marginheight="0" width="320" height="50" data-is-safeframe="true" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" data-google-container-id="7" style="border: 0px; vertical-align: bottom;" data-load-complete="true"></iframe></div></div></div></div>

   <div id="disqus_thread"></div>

    


</div> <!-- container div -->


</div><iframe name="__tcfapiLocator" style="display: none;"></iframe><img src="https://ad.doubleclick.net/favicon.ico?ad=300x250&amp;ad_box_=1&amp;adnet=1&amp;showad=1&amp;size=250x250" style="display: none !important;" /><img src="https://ad-delivery.net/px.gif?ch=1&amp;e=0.8833739195719152" style="display: none !important;" /> <!-- super container div -->

<iframe src="https://s.adtelligent.com/sync.html?aid=555831" style="display: none; visibility: hidden;"></iframe><div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_Main, sans-serif;"></div></div><iframe id="google_osd_static_frame_9327688809180" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;"></iframe></body><iframe sandbox="allow-scripts allow-same-origin" id="12910f69c6b2f5e7" frameborder="0" allowtransparency="true" marginheight="0" marginwidth="0" width="0" hspace="0" vspace="0" height="0" style="height:0px;width:0px;display:none;" scrolling="no" src="https://sync.rtk.io/cs?us_privacy=1---">
    </iframe></html>